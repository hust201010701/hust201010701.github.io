<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Android Service 持久运行不被杀死方法总结 | orzangleli</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="序：好久没有写文字了，并不代表我不在学习，只是学习的过程有些漫长，加上总结需要时间。

Android Service 持久运行不被杀死方法总结&amp;gt;简介：Android应用开发中，我们经常会遇到各种各样的场景需要保持Service不被杀死的需求。最常见的即时通讯类软件，由于实时性需求，需要保持消息服务类的运行状态。这里我总结了当下几种常见的解决方法及其利弊。首先申明：迄今为止我没有发现能够通">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Service 持久运行不被杀死方法总结">
<meta property="og:url" content="http://yoursite.com/2016/08/22/Android Service 持久运行不被杀死方法总结/index.html">
<meta property="og:site_name" content="orzangleli">
<meta property="og:description" content="序：好久没有写文字了，并不代表我不在学习，只是学习的过程有些漫长，加上总结需要时间。

Android Service 持久运行不被杀死方法总结&amp;gt;简介：Android应用开发中，我们经常会遇到各种各样的场景需要保持Service不被杀死的需求。最常见的即时通讯类软件，由于实时性需求，需要保持消息服务类的运行状态。这里我总结了当下几种常见的解决方法及其利弊。首先申明：迄今为止我没有发现能够通">
<meta property="og:image" content="http://7xrrni.com1.z0.glb.clouddn.com/Screenshot_2016-08-21-22-52-24.png?imageView2/0/w/360">
<meta property="og:updated_time" content="2016-11-03T11:19:54.102Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android Service 持久运行不被杀死方法总结">
<meta name="twitter:description" content="序：好久没有写文字了，并不代表我不在学习，只是学习的过程有些漫长，加上总结需要时间。

Android Service 持久运行不被杀死方法总结&amp;gt;简介：Android应用开发中，我们经常会遇到各种各样的场景需要保持Service不被杀死的需求。最常见的即时通讯类软件，由于实时性需求，需要保持消息服务类的运行状态。这里我总结了当下几种常见的解决方法及其利弊。首先申明：迄今为止我没有发现能够通">
<meta name="twitter:image" content="http://7xrrni.com1.z0.glb.clouddn.com/Screenshot_2016-08-21-22-52-24.png?imageView2/0/w/360">
  
    <link rel="alternative" href="/atom.xml" title="orzangleli" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/favicon.ico">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/assets/avatar.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">orzangleli</a></h1>
		</hgroup>

		
		<p class="header-subtitle">活在梦里的程序员和设计师</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/chats">闲聊</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/hust201010701" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/androidjiqiaogonglue" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
		        
					<a class="mail" target="_blank" href="/orzangleli@163.com" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">orzangleli</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/assets/avatar.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">orzangleli</h1>
			</hgroup>
			
			<p class="header-subtitle">活在梦里的程序员和设计师</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/chats">闲聊</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/hust201010701" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/androidjiqiaogonglue" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="/orzangleli@163.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-Android Service 持久运行不被杀死方法总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android Service 持久运行不被杀死方法总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>序：好久没有写文字了，并不代表我不在学习，只是学习的过程有些漫长，加上总结需要时间。</p>
</blockquote>
<h1 id="Android-Service-持久运行不被杀死方法总结"><a href="#Android-Service-持久运行不被杀死方法总结" class="headerlink" title="Android Service 持久运行不被杀死方法总结"></a>Android Service 持久运行不被杀死方法总结</h1><p>&gt;<br>简介：Android应用开发中，我们经常会遇到各种各样的场景需要保持Service不被杀死的需求。最常见的即时通讯类软件，由于实时性需求，需要保持消息服务类的运行状态。这里我总结了当下几种常见的解决方法及其利弊。首先申明：迄今为止我没有发现能够通过常规方法达到流氓需求(通过长按home键清除都清除不掉)的方法，目前所有方法都是指通过Android的内存回收机制和普通的第三方内存清除等手段后仍然保持运行的方法。</p>
<h2 id="方法1：申明Service为前台服务和提高Service的优先级"><a href="#方法1：申明Service为前台服务和提高Service的优先级" class="headerlink" title="方法1：申明Service为前台服务和提高Service的优先级"></a>方法1：申明Service为前台服务和提高Service的优先级</h2><p>这里说到了两个小分类，申明Service为前台服务和提高Service的优先级，实际上申明Service为前台服务也是提高服务的优先级，因为Android系统中默认的内存回收顺序(越往下越先回收)是：</p>
<blockquote>
<p>( 引用自：<a href="http://blog.csdn.net/mad1989/article/details/22492519" target="_blank" rel="external">http://blog.csdn.net/mad1989/article/details/22492519</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>前台进程( FOREGROUND_APP)</p>
</li>
<li><p>可视进程(VISIBLE_APP )</p>
</li>
<li><p>次要服务进程(SECONDARY_SERVER )</p>
</li>
<li><p>后台进程 (HIDDEN_APP)</p>
</li>
<li><p>内容供应节点(CONTENT_PROVIDER)</p>
</li>
<li><p>空进程(EMPTY_APP)</p>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<p>具体方法是在Service的onStartCommand方法中初始化Notification对象并将其绑定在服务上成为前台(Foreground)服务。<br>具体代码：</p>
<pre><code>@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    //使用Notification.Builder构造Notification
    Notification.Builder builder = new Notification.Builder(this.getApplicationContext());
    builder.setContentInfo(&quot;补充内容&quot;);
    builder.setContentText(&quot;主内容区&quot;);
    builder.setContentTitle(&quot;通知标题&quot;);
    builder.setSmallIcon(R.mipmap.ic_launcher);
    builder.setTicker(&quot;新消息&quot;);
    builder.setAutoCancel(true);
    builder.setWhen(System.currentTimeMillis());
    Intent intent2 = new Intent(this.getApplicationContext(), MainActivity.class);
    PendingIntent pendingIntent = PendingIntent.getActivity(this.getApplicationContext(), 0, intent2, PendingIntent.FLAG_CANCEL_CURRENT);
    builder.setContentIntent(pendingIntent);
    Notification notification = builder.build();
    //设置为前台服务，必须绑定一个notification对象，实际上也就是说如果你想做持久化的Service就得让用户知道，PID是自定义的整数表明notification的ID
    startForeground(PID, notification);

    return START_STICKY;
}
</code></pre><p>代码中提到：<em>设置为前台服务，必须绑定一个notification对象，实际上也就是说如果你想做持久化的Service就得让用户知道，PID是自定义的整数表明notification的ID</em><br>，实际上有一种方法可以达到前台服务不显示通知栏的效果。</p>
<h3 id="前台服务不显示通知栏"><a href="#前台服务不显示通知栏" class="headerlink" title="前台服务不显示通知栏"></a>前台服务不显示通知栏</h3><p>这里用到的黑科技来自博客：<a href="http://blog.csdn.net/wxx614817/article/details/50669420" target="_blank" rel="external">http://blog.csdn.net/wxx614817/article/details/50669420</a>。文中所提的方法即为：再新开一个辅助Service，onStartCommand里面同样设置为前台服务，而且startForeground(PID,<br>notification)的PID和第一个Service相同，然后在辅助Service中关闭前台服务，这样第一个Service还在运行，但是第二个服务会让通知栏关闭，这样就实现了所需功能。具体实现方式为：</p>
<ol>
<li><p>修改第一个Service里的onStartCommand方法，在后面启动辅助Service. </p>
<p>   @Override<br>   public int onStartCommand(Intent intent, int flags, int startId) {<br>   //使用Notification.Builder构造Notification<br>   Notification.Builder builder = new Notification.Builder(this.getApplicationContext());<br>   builder.setContentInfo(“补充内容”);<br>   builder.setContentText(“主内容区”);<br>   builder.setContentTitle(“通知标题”);<br>   builder.setSmallIcon(R.mipmap.ic_launcher);<br>   builder.setTicker(“新消息”);<br>   builder.setAutoCancel(true);<br>   builder.setWhen(System.currentTimeMillis());<br>   Intent intent2 = new Intent(this.getApplicationContext(), MainActivity.class);<br>   PendingIntent pendingIntent = PendingIntent.getActivity(this.getApplicationContext(), 0, intent2, PendingIntent.FLAG_CANCEL_CURRENT);<br>   builder.setContentIntent(pendingIntent);<br>   Notification notification = builder.build();<br>   //设置为前台服务，必须绑定一个notification对象，实际上也就是说如果你想做持久化的Service就得让用户知道，PID是自定义的整数表明notification的ID<br>   startForeground(PID, notification);</p>
<p>   //启动辅助Service<br>   Intent intent3 = new Intent(MyService.this,AssistService.class);<br>   MyService.this.startService(intent3);</p>
<p>   return START_STICKY;<br>}</p>
</li>
</ol>
<ol>
<li><p>在辅助Service中开启一个同样ID的notification，并取消。 </p>
<p>   @Override<br>   public int onStartCommand(Intent intent, int flags, int startId) {</p>
<pre><code>Notification.Builder builder = new Notification.Builder(this.getApplicationContext());
builder.setContentInfo(&quot;补充内容&quot;);
builder.setContentText(&quot;主内容区&quot;);
builder.setContentTitle(&quot;通知标题&quot;);
builder.setSmallIcon(R.mipmap.ic_launcher);
builder.setTicker(&quot;新消息&quot;);
builder.setAutoCancel(true);
builder.setWhen(System.currentTimeMillis());
Intent intent2 = new Intent(this.getApplicationContext(), MainActivity.class);
PendingIntent pendingIntent = PendingIntent.getActivity(this.getApplicationContext(), 0, intent2, PendingIntent.FLAG_CANCEL_CURRENT);
builder.setContentIntent(pendingIntent);
Notification notification = builder.build();
NotificationManager manager =
        (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
//先显示
startForeground(PID, notification);
//再销毁
stopForeground(true);

return START_STICKY;
</code></pre><p>   }</p>
</li>
</ol>
<p>修改Service优先级比较简单：在AndroidManifest.xml文件中添加intent-<br>fliter,priority值在-1000到1000范围内，数值越高优先级越高。</p>
<pre><code>&lt;service android:name=&quot;.MyService&quot;&gt;
    &lt;intent-filter android:priority=&quot;1000&quot;&gt;
        &lt;action android:name=&quot;com.orzangleli.qqservicekeepdemo&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre><p><strong>测试效果：</strong>这种方法经过测试，在手机较高内存使用率时，大概能够运行5分钟左右（测试手机型号：nubia z7 mini ,内存2G）。这实际上也就表明了其缺点，申明为前台服务只能提高优先级，并不能保证在低内存时不被回收。</p>
<h2 id="方法2：通过BroadcastReceiver-重启服务"><a href="#方法2：通过BroadcastReceiver-重启服务" class="headerlink" title="方法2：通过BroadcastReceiver 重启服务"></a>方法2：通过BroadcastReceiver 重启服务</h2><p>首先解释下BroadcastReceiver的两种注册方式，动态注册和静态注册，两者大多数情况下可以通用，但存在以下l两点区别：</p>
<ol>
<li>动态注册在程序关闭时，无法接收到广播，因为注册广播是在程序运行时执行的。</li>
<li>静态注册虽然可以在程序未打开时接收到广播，但是有三种广播无法静态注册： <ul>
<li>android.intent.action.SCREEN_ON</li>
<li>android.intent.action.SCREEN_OFF</li>
<li>android.intent.action.BATTERY_CHANGED</li>
<li>android.intent.action.CONFIGURATION_CHANGED</li>
<li>android.intent.action.TIME_TICK</li>
</ul>
</li>
</ol>
<p>在测试时，我使用android.intent.action.TIME_TICK动态注册广播接受者，在onReceive方法中添加判断目标服务是否在运行的判断，如果不在运行就重新启动。代码如下：</p>
<pre><code>public class MyBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        if(intent.getAction().equals(Intent.ACTION_TIME_TICK))
        {
            Log.i(&quot;lxc&quot;,&quot;接收到广播了&quot;);
            if(!isServiceRunning(context,&quot;com.orzangleli.qqservicekeepdemo.MyService&quot;))
            {
                Intent service = new Intent(context,MyService.class);
                service .setAction(&quot;com.orzangleli.qqservicekeepdemo&quot;);
                context.startService(service);
            }
        }
    }

    public static boolean isServiceRunning(Context context,String serviceClassName){
        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        final List&lt;ActivityManager.RunningServiceInfo&gt; services = activityManager.getRunningServices(Integer.MAX_VALUE);

        for (ActivityManager.RunningServiceInfo runningServiceInfo : services) {
            if (runningServiceInfo.service.getClassName().equals(serviceClassName)){
                return true;
            }
        }
        return false;
    }

}
</code></pre><p>测试结果：在程序不退出但是服务停止的情况下，的确可以重启服务，但是重启不是即时的，而是每隔1分钟(在每分钟的第0秒触发)，没有尝试其他的静态注册方式，因为我没有找到一个静态注册的广播，它的广播频率比这个android.intent.action.TIME_TICK还要高的，如果各位读者有知道的，麻烦告知下。而在程序完全退出时，动态注册的BroadcastReceiver不再接受广播，所以也就不会重启Service.</p>
<h2 id="方法3-双进程守护"><a href="#方法3-双进程守护" class="headerlink" title="方法3.双进程守护"></a>方法3.双进程守护</h2><p>双进程守护是指开启两个进程，这两个进程相互独立但是又相互守护，如果其中一个进程被杀死，另一个进程则重启该进程，因为一般情况下不会发生两个进程同时死亡的场景，所以在Service常驻功能上能够满足。</p>
<p>这里插上一句话：在手机的应用程序中可以看到我们手机里大部分常驻内存的Service都是两个或以上的，比如下图中的微信电话本，Hola桌面和<del>QQ</del>(后面解释了QQ不是用的这种方法).</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/Screenshot_2016-08-21-22-52-24.png?imageView2/0/w/360" alt="运行中的程序"></p>
<p>具体操作步骤为：</p>
<p><strong>1. 申明Service的进程，主服务和辅助服务不要同一个进程</strong></p>
<pre><code>&lt;service android:name=&quot;.MyService&quot;
            android:process=&quot;:myservice&quot;
            &gt;
            &lt;intent-filter android:priority=&quot;1000&quot;&gt;
                &lt;action android:name=&quot;com.orzangleli.qqservicekeepdemo&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/service&gt;
        &lt;service android:name=&quot;.AssistService&quot;
            android:process=&quot;:assistservice&quot;
            &gt;
        &lt;/service&gt;
</code></pre><p><strong>2. 在两个服务中分别启动一个线程检查另一个服务的状态</strong></p>
<pre><code>class MyRunnable implements  Runnable
{
    @Override
    public void run() {
        while(enable) {
            Log.i(TAG, &quot; 时间： &quot; + Calendar.getInstance().get(Calendar.SECOND));
            keepAssistService();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
private  void keepAssistService(){
    boolean isRun = isServiceRunning(this, Process_Name);
    if (isRun == false) {

            Log.i(TAG,&quot;重新启动 AssistService&quot;);
            Intent intent = new Intent(this,AssistService.class);
            intent .setAction(&quot;com.orzangleli.qqservicekeepdemo&quot;);
            this.startService(intent);
    }

}

public static boolean isServiceRunning(Context context,String serviceClassName){
    final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    final List&lt;ActivityManager.RunningServiceInfo&gt; services = activityManager.getRunningServices(Integer.MAX_VALUE);

    for (ActivityManager.RunningServiceInfo runningServiceInfo : services) {
        if (runningServiceInfo.service.getClassName().equals(serviceClassName)){
            return true;
        }
    }
    return false;
}
</code></pre><p>测试结果：经过一个多小时的使用，后台服务仍然在运行状态。比较完美实现了，唯一的确定就是里面有两个线程循环执行，会导致耗电更快。</p>
<h2 id="方法4-QQ的一像素保持前台服务方法"><a href="#方法4-QQ的一像素保持前台服务方法" class="headerlink" title="方法4.QQ的一像素保持前台服务方法"></a>方法4.QQ的一像素保持前台服务方法</h2><p>先推荐阅读文章： <a href="http://www.expreview.com/39438.html" target="_blank" rel="external">手机QQ后台为何清不掉？MIUI工程师：全靠1像素的页面保命</a></p>
<p>文中提到，QQ通过一个像素，在程序退出时，显示这个像素，使得系统认为该服务为前台服务，所以允许常驻内存，这种方法我不很懂。</p>
<p>我在测试的时候，在Service显示一个悬浮窗，用这个悬浮窗代替QQ的一个像素，但是在运行5分钟左右后，悬浮窗消失同时后台服务也停止运行，不是说有可见的UI的后台服务就是为前台服务了么，怎么也会被杀死。而且如果是用这种方法实现的常驻内存，为什么QQ也会使用到双进程呢？(<strong>更新：经过测试，QQ的双进程并没有守护关系，关闭掉Downloader的那个进程并不会重新启动</strong>)。</p>
<p>现在的问题就是：为什么我在Service中启动的悬浮窗会被杀死呢？本文会持续更新。</p>
<h2 id="方法5：使用一些常见的白名单推送包"><a href="#方法5：使用一些常见的白名单推送包" class="headerlink" title="方法5：使用一些常见的白名单推送包"></a>方法5：使用一些常见的白名单推送包</h2><p>据说使用常见的白名单推送包在保持进行活跃上也有一定效果，例如Jpush，或者内置的系统账户同步系统等，定时推送消息然后启动服务。此方法暂未测试，不知道效果如何，暂时留白。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/22/Android Service 持久运行不被杀死方法总结/" class="archive-article-date">
  	<time datetime="2016-08-21T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-22</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/09/05/Android 自定义弹幕 View/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          Android 自定义弹幕 View
        
      </div>
    </a>
  
  
    <a href="/2016/08/16/【源码解析】UIL的图片缓存策略/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">【源码解析】UIL的图片缓存策略</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Android Service 持久运行不被杀死方法总结" data-title="Android Service 持久运行不被杀死方法总结" data-url="http://yoursite.com/2016/08/22/Android Service 持久运行不被杀死方法总结/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"orzangleli"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 orzangleli
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Arduino/" style="font-size: 10px;">Arduino</a> <a href="/tags/HTC-VIVE/" style="font-size: 15px;">HTC VIVE</a> <a href="/tags/Kinect/" style="font-size: 12.5px;">Kinect</a> <a href="/tags/Pyhton/" style="font-size: 10px;">Pyhton</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Shader/" style="font-size: 12.5px;">Shader</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/api请求/" style="font-size: 10px;">api请求</a> <a href="/tags/unity3D/" style="font-size: 17.5px;">unity3D</a> <a href="/tags/其他/" style="font-size: 10px;">其他</a> <a href="/tags/面试/" style="font-size: 12.5px;">面试</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">我是orzangleli，可以关注我的微博~</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>