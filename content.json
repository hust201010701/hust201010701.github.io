{"meta":{"title":"orzangleli","subtitle":"活在梦里的程序员和设计师","description":"华中科技大学 本科10级 硕士14级 一个热爱技术的宅~","author":"orzangleli","url":"http://www.orzangleli.com"},"pages":[{"title":"about","date":"2017-02-15T08:38:18.000Z","updated":"2017-02-15T08:45:32.295Z","comments":true,"path":"about/index.html","permalink":"http://www.orzangleli.com/about/index.html","excerpt":"","content":"About Me个人信息我是本科和硕士都来自于华中科技大学的一名开发者，水平很低，能力有限，姿势水平尚浅，目前正在努力学习，希望日后能够成为行业内名人。 作品栏（暂留白，并没有我自认为比较好的作品，有了第一时间发布） 联系方式Github: https://github.com/hust201010701 Weibo:http://weibo.com/androidjiqiaogonglue/ Wechat:如果需要微信，可以微博私信我 打赏 支付宝 微信 如果你觉得我的博客帮助了你，而且你又有能力回馈我的话，欢迎打赏~ 打赏了我的人都会出现在下面的名单中哦~ 鸣谢名单"},{"title":"tags","date":"2016-12-29T15:27:23.000Z","updated":"2017-02-15T07:26:55.745Z","comments":false,"path":"tags/index.html","permalink":"http://www.orzangleli.com/tags/index.html","excerpt":"","content":""},{"title":"categories","date":"2016-12-29T15:27:17.000Z","updated":"2017-02-15T07:26:26.333Z","comments":false,"path":"categories/index.html","permalink":"http://www.orzangleli.com/categories/index.html","excerpt":"","content":""}],"posts":[{"title":"Android 用 Retrofit 2 实现多文件上传实战","slug":"2017-04-03_Android 用 Retrofit 2 实现多文件上传实战","date":"2017-04-02T16:00:00.000Z","updated":"2017-04-03T13:55:30.843Z","comments":true,"path":"2017/04/03/2017-04-03_Android 用 Retrofit 2 实现多文件上传实战/","link":"","permalink":"http://www.orzangleli.com/2017/04/03/2017-04-03_Android 用 Retrofit 2 实现多文件上传实战/","excerpt":"","content":"前一段时间我翻译了Future Studio的Retrofit2教程，从中也学习到了一些Retrofit2的使用方法，如果你最近也打算入手学习，我博客上Retrofit教程，你也许可以参考下：Retrofit教程 。 本文作为阶段性小结，将使用结合Python中的Flask框架实现Android端多文件上传功能。如果读者没有使用过Python中的Flask也没有关系，可以只看Android客户端部分，毕竟客户端工程师只使用API也是可以的。 1. 实验效果 Android端操作截图 Server端接收到的图片 2. Server端实战Server端负责接收保存客户端上传来的图片并提供访问图片的能力，Server有很多技术可以实现，Python作为一门具有强大的第三方库的语言，拥有很多web服务框架，如Flask,Django等。笔者采用Flask框架，Flask是微框架，实现小型功能十分方便，笔者实现的多文件上传功能，程序不超过30行。 下面具体来看看。 2.1 环境安装笔者使用的Python版本为3.4，可以去 Python3.4下载 选择下载适合自己系统的版本。完整安装Python教程请自行搜索。 Python安装完成后需要安装Server端程序依赖库。通过pip安装： pip install Flask pip install werkzeug 2.2 程序实现首先要引入依赖库： 123from flask import Flask,request,send_from_directory,jsonifyimport osfrom werkzeug import secure_filename 本实验需要上传文件，需要将所上传文件的文件类型以及文件名做出限制，防止某些破坏服务器的程序运行，另外有些非法文件名如：filename = &quot;../../../../home/username/.bashrc&quot;如果黑客们能够操作这样的文件，对服务器系统来说，将是致命打击。所以werkzeug提供了secure_filename对上传文件的文件名进行合法校验。 判断文件后缀是否合法123ALLOWED_EXTENSIONS=set(['png','jpg','jpeg','gif'])def allowed_file(filename): return '.' in filename and filename.rsplit('.',1)[1] in ALLOWED_EXTENSIONS 接收上传文件的函数代码如下：1234567891011@app.route('/upload',methods=['POST'])def upload_file(): if request.method=='POST': for k in request.files: file = request.files[k] image_urls = [] if file and allowed_file(file.filename): filename=secure_filename(file.filename) file.save(os.path.join(app.config['IMAGE_FOLDER'],filename)) image_urls.append(\"images/%s\"%filename) return jsonify(&#123;\"code\":1,\"image_urls\":image_urls&#125;) Flask支持GET,POST,PUT,DELETE等HTTP请求方式，使用装饰器进行修饰，类似于Java中的注解概念，/upload为客户端请求的相对地址，请求方式限制为POST.根据request内置对象，可以访问客户端发来的文件，将文件检查后保存在本地，其中image_urls为上传后的图片的相对地址数组。最后将图片的地址以json格式返回给客户端。 完整的Server端代码如下： 12345678910111213141516171819202122232425262728293031323334from flask import Flask,request,send_from_directory,jsonifyimport osfrom werkzeug import secure_filenameapp = Flask(__name__)app.config['IMAGE_FOLDER'] = os.path.abspath('.')+'\\\\images\\\\'ALLOWED_EXTENSIONS=set(['png','jpg','jpeg','gif'])def allowed_file(filename): return '.' in filename and filename.rsplit('.',1)[1] in ALLOWED_EXTENSIONS@app.route('/upload',methods=['POST'])def upload_file(): if request.method=='POST': for k in request.files: file = request.files[k] print(file) image_urls = [] if file and allowed_file(file.filename): filename=secure_filename(file.filename) file.save(os.path.join(app.config['IMAGE_FOLDER'],filename)) image_urls.append(\"images/%s\"%filename) return jsonify(&#123;\"code\":1,\"image_urls\":image_urls&#125;)#让文件映射访问，否则默认只能访问static文件夹中的文件@app.route(\"/images/&lt;imgname&gt;\",methods=['GET'])def images(imgname): return send_from_directory(app.config['IMAGE_FOLDER'],imgname)if __name__ == \"__main__\": # 检测 IMAGE_FOLDER 是否存在 if not os.path.exists(app.config['IMAGE_FOLDER']): os.mkdir(app.config['IMAGE_FOLDER']) app.run(\"192.168.1.102\",debug=True) 这里有一个小技巧，写完Server端代码后可以使用Postman进行测试，测试成功后再进行客户端程序开发。 3. 客户端开发因为涉及文件的上传，笔者这里以图片为例进行上传实验，图片上传除了重头戏Retrofit之外，还需要选择图片，笔者这里推荐一个模仿微信的图片选择库 ImagePicker . 3.1 添加依赖库图片加载库笔者喜欢使用Glide compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos; compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos; compile &apos;com.github.bumptech.glide:glide:3.7.0&apos; compile &apos;com.lzy.widget:imagepicker:0.4.1&apos; 3.2 程序实现如果没有接触过Retrofit 2，可以来我的博客Retrofit教程 了解。 Retrofit2 是一个支持RESTful API的请求库，实际上只是对API请求方式的封装，真正的网络请求由OkHttp发出。 Retrofit2一般会定义一个ServiceGenerator类，用于动态生成Retrofit对象。 1234567891011121314public class ServiceGenerator &#123; public static final String API_BASE_URL = \"http://192.168.1.102:5000/\"; private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); private static Retrofit.Builder builder = new Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()); public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass) &#123; Retrofit retrofit = builder.client(httpClient.build()).build(); return retrofit.create(serviceClass); &#125;&#125; 具体的API操作由FlaskClient接口操作， 1234567public interface FlaskClient &#123; //上传图片 @Multipart @POST(\"/upload\") Call&lt;UploadResult&gt; uploadMultipleFiles( @PartMap Map&lt;String,RequestBody&gt; files);&#125; 上传文件需要使用@Multipart关键字注解，@POST表明HTTP请求方式为POST,/upload为请求服务器的相对地址，uploadMultipleFiles是自定义的方法名，参数为Map&lt;String,RequestBody&gt; files即多个文件组成的Map对象，@PartMap表明这是多文件上传，如果单文件可以使用@Part MultipartBody.Part file,方法的返回类型默认为Response,由于我们已经开发了Server端，所以知道Server端的返回数据格式为Json，因此我们针对返回数据格式新建一个UploadResut类。 1234public class UploadResult &#123; public int code; // 1 public List&lt;String&gt; image_urls;&#125; 界面布局如图所示： 点击Upload按钮后执行上传操作，核心的方法： public void uploadFiles() { if(imagesList.size() == 0) { Toast.makeText(MainActivity.this, &quot;不能不选择图片&quot;, Toast.LENGTH_SHORT).show(); return; } Map&lt;String, RequestBody&gt; files = new HashMap&lt;&gt;(); final FlaskClient service = ServiceGenerator.createService(FlaskClient.class); for (int i = 0; i &lt; imagesList.size(); i++) { File file = new File(imagesList.get(i).path); files.put(&quot;file&quot; + i + &quot;\\&quot;; filename=\\&quot;&quot; + file.getName(), RequestBody.create(MediaType.parse(imagesList.get(i).mimeType), file)); } Call&lt;UploadResult&gt; call = service.uploadMultipleFiles(files); call.enqueue(new Callback&lt;UploadResult&gt;() { @Override public void onResponse(Call&lt;UploadResult&gt; call, Response&lt;UploadResult&gt; response) { if (response.isSuccessful() &amp;&amp; response.body().code == 1) { Toast.makeText(MainActivity.this, &quot;上传成功&quot;, Toast.LENGTH_SHORT).show(); Log.i(&quot;orzangleli&quot;, &quot;---------------------上传成功-----------------------&quot;); Log.i(&quot;orzangleli&quot;, &quot;基础地址为：&quot; + ServiceGenerator.API_BASE_URL); Log.i(&quot;orzangleli&quot;, &quot;图片相对地址为：&quot; + listToString(response.body().image_urls,&apos;,&apos;)); Log.i(&quot;orzangleli&quot;, &quot;---------------------END-----------------------&quot;); } } @Override public void onFailure(Call&lt;UploadResult&gt; call, Throwable t) { Toast.makeText(MainActivity.this, &quot;上传失败&quot;, Toast.LENGTH_SHORT).show(); } }); } 其中构建上传多文件的方法的参数较为关键，MediaType.parse(imagesList.get(i).mimeType)获取图片的mimeType，如果指定错误，可能会导致上传失败。 123456Map&lt;String, RequestBody&gt; files = new HashMap&lt;&gt;();final FlaskClient service = ServiceGenerator.createService(FlaskClient.class);for (int i = 0; i &lt; imagesList.size(); i++) &#123; File file = new File(imagesList.get(i).path); files.put(\"file\" + i + \"\\\"; filename=\\\"\" + file.getName(), RequestBody.create(MediaType.parse(imagesList.get(i).mimeType), file));&#125; 集成Callback借口的匿名回调类的onResponse方法的第二个参数为服务器响应，通过访问body()方法返回UploadResult类型对象，接着就可以通过组合ServiceGenerator.API_BASE_URL和response.body().image_urls中每一项访问上传完成的图片。 4. 项目地址本项目Client端和Server端均以开源，欢迎各位老总们Star。Client地址: RetrofitMultiFilesUploadClientServer地址: MultiFileUploadServer","categories":[{"name":"Android","slug":"Android","permalink":"http://www.orzangleli.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"第十四篇 Retrofit2——如何上传多个文件到服务器","slug":"2017-02-22_第十四篇 Retrofit2——如何上传多个文件到服务器","date":"2017-02-21T16:00:00.000Z","updated":"2017-02-23T00:40:25.072Z","comments":true,"path":"2017/02/22/2017-02-22_第十四篇 Retrofit2——如何上传多个文件到服务器/","link":"","permalink":"http://www.orzangleli.com/2017/02/22/2017-02-22_第十四篇 Retrofit2——如何上传多个文件到服务器/","excerpt":"","content":"第十四篇 Retrofit2——如何上传多个文件到服务器一、用Retrofit 2上传多个文件在开始多文件上传的细节之前，请确保你已经理解了《如何上传文件到服务器》中的所有原理，这样，多文件上传的方式将是十分相似。 首先，我们得为多文件上传扩展FileUploadService接口。 public interface FileUploadService { // previous code for single file uploads @Multipart @POST(&quot;upload&quot;) Call&lt;ResponseBody&gt; uploadFile( @Part(&quot;description&quot;) RequestBody description, @Part MultipartBody.Part file); // new code for multiple files @Multipart @POST(&quot;upload&quot;) Call&lt;ResponseBody&gt; uploadMultipleFiles( @Part(&quot;description&quot;) RequestBody description, @Part MultipartBody.Part file1, @Part MultipartBody.Part file2); } 对比上面接口中的uploadFile()方法和uploadMultipleFiles()方法，你可以很明显的发现区别。Retrofit 2中添加新的文件十分简单。在接口定义的方面，我们仅仅需要添加一个新的参数@Part MultipartBody.Part file2。uploadMultipleFiles()现在就只能支持两个文件了。你可以自己调整MultipartBody.Part的数量。后面的教程，我们会看看如何添加动态的数量的文件到你的请求中。 接口声明结束，已经完成了一半的工作。另一半就是在Activity或Fragment中实现了。因为我们现在在进行多文件上传，所以我们实现两个帮助方法，让代码更健壮： public static final String MULTIPART_FORM_DATA = &quot;multipart/form-data&quot;; @NonNull private RequestBody createPartFromString(String descriptionString) { return RequestBody.create( MediaType.parse(MULTIPART_FORM_DATA), descriptionString); } @NonNull private MultipartBody.Part prepareFilePart(String partName, Uri fileUri) { // https://github.com/iPaulPro/aFileChooser/blob/master/aFileChooser/src/com/ipaulpro/afilechooser/utils/FileUtils.java // use the FileUtils to get the actual file by uri File file = FileUtils.getFile(this, fileUri); // create RequestBody instance from file RequestBody requestFile = RequestBody.create(MediaType.parse(MULTIPART_FORM_DATA), file); // MultipartBody.Part is used to send also the actual file name return MultipartBody.Part.createFormData(partName, file.getName(), requestFile); } createPartFromString()方法在文件上传时发送描述。prepareFilePart()方法创建了一个MultipartBody.Part对象，可以包含一个文件。在Retrofit 2中上传文件都需要包裹在MultipartBody.Part中。 下面使用这两个帮助方法来发送两个文件： Uri file1Uri = ... // get it from a file chooser or a camera intent Uri file2Uri = ... // get it from a file chooser or a camera intent // create upload service client FileUploadService service = ServiceGenerator.createService(FileUploadService.class); // create part for file (photo, video, ...) MultipartBody.Part body1 = prepareFilePart(&quot;video&quot;, file1Uri); MultipartBody.Part body2 = prepareFilePart(&quot;thumbnail&quot;, file2Uri); // add another part within the multipart request RequestBody description = createPartFromString(&quot;hello, this is description speaking&quot;); // finally, execute the request Call&lt;ResponseBody&gt; call = service.uploadMultipleFiles(description, body1, body2); call.enqueue(new Callback&lt;ResponseBody&gt;() { @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) { Log.v(&quot;Upload&quot;, &quot;success&quot;); } @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) { Log.e(&quot;Upload error:&quot;, t.getMessage()); } }); 现在你要做的就是在一个请求中发送两个文件，当然你也可以再添加一个或者多个文件到接口中，用这种方式，你可以想发送多少文件都可以。 二、用图床实战","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"第十三篇 Retrofit—如何上传文件到服务器","slug":"2017-02-17_第十三篇 Retrofit—如何上传文件到服务器","date":"2017-02-16T16:00:00.000Z","updated":"2017-02-17T01:33:00.471Z","comments":true,"path":"2017/02/17/2017-02-17_第十三篇 Retrofit—如何上传文件到服务器/","link":"","permalink":"http://www.orzangleli.com/2017/02/17/2017-02-17_第十三篇 Retrofit—如何上传文件到服务器/","excerpt":"","content":"第十三篇 Retrofit2——如何上传文件到服务器 一、用Retrofit 2上传文件 二、Android 客户端代码 三、记住Content-Type 四、示例Hapi文件上传服务器 五、文件上传实战 一、用Retrofit 2上传文件Retrofit 2在处理文件上传的方式上与Retrofit v1有很大不同。在我们深入学习Retrofit 2中的文件上传的相关内容之前，简单回顾Retrofit v1中的使用的TypedFile类来上传文件。在Retrofit 2中这个类已经被移除了。而且Retrofit 2把OkHttp作为网络层，因此使用OkHttp的类来实现文件上传。 在Retrofit 2中，你需要使用OkHttp的RequestBody或MultipartBody.Part类，把你的文件封装到请求体中。下面来看看文件上传接口的定义。 123456public interface FileUploadService &#123; @Multipart @POST(\"upload\") Call&lt;ResponseBody&gt; upload(@Part(\"description\") RequestBody description, @Part MultipartBody.Part file);&#125; 我们逐个分析上面的定义，先从description开始。description就是一个包裹在RequestBody实例中的字符串的值。然后，请求中的@Part描述的是真实的file。我们使用MultipartBody.Part来允许我们除了发送二进制文件数据外还能发送真实的文件名。下面你将看到如何创建file对象。 二、Android 客户端代码到现在，你使用Retrofit已经定义过必要的service接口了。现在你可以向文件上传上面探索了。我们使用ServiceGenerator类生成一个服务客户端。我们已经在本系列第一篇文章中介绍过了ServiceGenerator类。 下面的代码片段将展示把文件地址作为参数的uploadFile(Uri fileUri)方法。如果你用intent来选择文件，你可以在onActivityResult()方法中获得文件的地址，这个地址就是你要传递给uploadFile(Uri fileUri)方法的参数。 1234567891011121314151617181920212223242526272829303132333435363738private void uploadFile(Uri fileUri) &#123; // 创建文件上传客户端 FileUploadService service = ServiceGenerator.createService(FileUploadService.class); // https://github.com/iPaulPro/aFileChooser/blob/master/aFileChooser/src/com/ipaulpro/afilechooser/utils/FileUtils.java // use the FileUtils to get the actual file by uri File file = FileUtils.getFile(this, fileUri); // 根据文件创建请求体 RequestBody requestFile = RequestBody.create(MediaType.parse(\"multipart/form-data\"), file); // MultipartBody.Part 还可以上传文件名 MultipartBody.Part body = MultipartBody.Part.createFormData(\"picture\", file.getName(), requestFile); // 在 multipart request中再添加一部分内容 String descriptionString = \"hello, this is description speaking\"; RequestBody description = RequestBody.create( MediaType.parse(\"multipart/form-data\"), descriptionString); // 最后执行请求 Call&lt;ResponseBody&gt; call = service.upload(description, body); call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; Log.v(\"Upload\", \"success\"); &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; Log.e(\"Upload error:\", t.getMessage()); &#125; &#125;);&#125; 上面的代码片段展示了如何初始化body和description,以及如何使用文件上传service.之前提到，RequestBody是OkHttp中的类。它的.create()方法需要两个参数：从multipart/form-data解析的媒体文件类型和真实的数据。 除了description，你还可以添加文件到MultipartBody.Part实例中。这个文件就是你从客户端上传文件时需要的文件。而且，你可以使用createFormData()把原始的文件名添加到请求中，服务器在后端接收后可以使用它。 三、记住Content-Type请注意Retrofit的Content-Type内容类型。如果你在OkHttp客户端中拦截请求，并把内容类型修改为application/json,你的服务器在反序列化过程可能出现问题。请确保你在请求头中没有声明你再发送JSON数据，而是在发送multipart/form-data. 四、示例Hapi文件上传服务器讲的是hapi服务器配合Retrofit使用，因为内容不涉及Android,有兴趣的自行查看： https://futurestud.io/tutorials/retrofit-2-how-to-upload-files-to-server#exemplaryhapiserverforfileuploads 五、文件上传实战我们使用第三方文件上传API。为什么不使用Github的呢？我找了半天也没找到Github上传文件的API,如果各位找到，麻烦通知我一下。我们使用http://www.tietuku.com/这个图床，上传图片文件来试验文件上传功能，需要自行登录网站。 注册登录网站，网站服务免费的。 进入http://www.tietuku.com/manager/createtoken，选择目标相册，上传方式为本地上传，点击立即生成即可获得token. 进入http://www.tietuku.com/manager/album获得相册的ID. 首先，我们要把ServiceGenerator中的基础API地址修改我们使用的图床的API地址：http://up.imgapi.com。 然后，我们使用的客户端不再是之前一直使用的GithubClient了，我们新建一个接口FileUploadService。内容为： 1234567891011public interface FileUploadService &#123; @Multipart @POST(\"/\") Call&lt;ResponseBody&gt; upload(@Part(\"Token\") RequestBody token, @Part MultipartBody.Part file, @Query(\"deadline\") long deadline, @Query(\"aid\") int aid, @Query(\"from\") String from, @Query(\"httptype\") int httptype );&#125; 参数均为API文档中规定的数据。 在MainActivity中调用文件上传接口时，如果是Android 6.0系统及其之上需要检查读写权限，所以代码比较长： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class MainActivity extends AppCompatActivity &#123; List&lt;TaskService.Task&gt; tasks ; private static String TAG = \"ILearnRetrofit\"; TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Utils.init(this); textView = (TextView)this.findViewById(R.id.textView); initPermission(); &#125; private void initPermission() &#123; int permission = ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_EXTERNAL_STORAGE); if (permission != PackageManager.PERMISSION_GRANTED) &#123; //需不需要解释的dialog if (shouldRequest()) return; //请求权限 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 1); &#125; else&#123; if(isFileExists(Environment.getExternalStorageDirectory()+File.separator+\"Download\"+File.separator+\"qq2.png\")) &#123; ToastUtils.showLongToast(\"存在\"); uploadFile(Environment.getExternalStorageDirectory() + File.separator + \"Download\" + File.separator + \"qq2.png\"); &#125; &#125; &#125; private boolean shouldRequest() &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_EXTERNAL_STORAGE)) &#123; //显示一个对话框，给用户解释 explainDialog(); return true; &#125; return false; &#125; private void explainDialog() &#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setMessage(\"应用需要获取您的文件权限,是否授权？\") .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //请求权限 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 1); &#125; &#125;).setNegativeButton(\"取消\", null) .create().show(); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 1 &amp;&amp; grantResults.length &gt; 0) &#123; boolean granted = grantResults[0] == PackageManager.PERMISSION_GRANTED;//是否授权，可以根据permission作为标记 if(granted)&#123; if(isFileExists(Environment.getExternalStorageDirectory()+File.separator+\"Download\"+File.separator+\"qq2.png\")) &#123; ToastUtils.showLongToast(\"存在\"); uploadFile(Environment.getExternalStorageDirectory() + File.separator + \"Download\" + File.separator + \"qq2.png\"); &#125; &#125; &#125; &#125; public void uploadFile(String fileUri)&#123; FileUploadService service = ServiceGenerator.createService(FileUploadService.class); File file = FileUtils.getFileByPath(fileUri); RequestBody requestFile = RequestBody.create(MediaType.parse(\"image/png\"),file); MultipartBody.Part body = MultipartBody.Part.createFormData(\"file\",file.getName(),requestFile); String tokenString = \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"; RequestBody token = RequestBody.create(MediaType.parse(\"multipart-data\"),tokenString); Call&lt;ResponseBody&gt; call = service.upload(token, body,1420041660,xxxxxx,\"file\",2 ); call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; d(TAG,\"success:\"+response.raw()); textView.setText(\"success:\"+response); &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; d(TAG,\"fail:\"+t.getMessage()); textView.setText(\"fail:\"+t.getMessage()); &#125; &#125;); &#125;&#125; 最后，我们在后台检查下是否上传成功了。 的确，可以看到上传的文件了，证明上传成功了。 本篇教程所有源码参见此网页：[留白] Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 @orzanglei。","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"ViewPager+Fragment+TabLayout爬坑","slug":"2017-02-17_ViewPager+Fragment+TabLayout爬坑","date":"2017-02-16T16:00:00.000Z","updated":"2017-02-17T14:17:46.943Z","comments":true,"path":"2017/02/17/2017-02-17_ViewPager+Fragment+TabLayout爬坑/","link":"","permalink":"http://www.orzangleli.com/2017/02/17/2017-02-17_ViewPager+Fragment+TabLayout爬坑/","excerpt":"","content":"ViewPager+Fragment+TabLayout爬坑 1. 在xml布局中定义ViewPager和TabLayout 2. 禁止重复添加相同的Fragment到Viewpager中 3. setupWithViewPager后Tab不显示 3.1 那么怎么来让Tab显示文字和图标呢？ 4. 完整的java 代码 1. 在xml布局中定义ViewPager和TabLayout1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.orzangleli.xiaoxiannv.MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewPager\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" &gt;&lt;/android.support.v4.view.ViewPager&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/tabLayout\" android:layout_width=\"match_parent\" android:layout_height=\"60dp\" android:background=\"@color/titleBlue\" app:tabIndicatorColor=\"@color/white\" app:tabIndicatorHeight=\"2dp\" app:tabMode=\"fixed\" app:tabSelectedTextColor=\"@color/white\" app:tabTextColor=\"@color/gray\" /&gt; &lt;/LinearLayout&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 2. 禁止重复添加相同的Fragment到Viewpager中当时，我的tab有三个，但是另外两个Fragment还没有写好，就偷懒把FragmentPagerAdapter中数组重复添加了第一个fragment三次，结果就出错了： Can&#39;t change tag of fragment SubscribedFragment{41157420 id=0x7f070005 android:switcher:2131165189:0}: was android:switcher:2131165189:0 now android:switcher:2131165189:1 解决方法 新建另外的两个Fragment，与FragmentPagerAdapter绑定。 3. setupWithViewPager后Tab不显示查看源码： 123456789101112131415161718void populateFromPagerAdapter() &#123; removeAllTabs(); if (mPagerAdapter != null) &#123; final int adapterCount = mPagerAdapter.getCount(); for (int i = 0; i &lt; adapterCount; i++) &#123; addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false); &#125; // Make sure we reflect the currently set ViewPager item if (mViewPager != null &amp;&amp; adapterCount &gt; 0) &#123; final int curItem = mViewPager.getCurrentItem(); if (curItem != getSelectedTabPosition() &amp;&amp; curItem &lt; getTabCount()) &#123; selectTab(getTabAt(curItem)); &#125; &#125; &#125; &#125; 注意addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false);,看到没，在setupWithViewPager后，会自动添加三个Tab,Tab上的文字是FragmentPagerAdapter中的PageTitle。 所以，我们不能自己给TabLayout添加tab，因为你只要绑定ViewPager,它会自动再添加一次。 3.1 那么怎么来让Tab显示文字和图标呢？ 只显示文字 如果只显示文字可以直接在定义FragmentPagerAdapter时，添加一个方法就行： 1234567891011121314151617pageAdapter = new FragmentPagerAdapter(this.getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentList.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mTitles[position]; &#125; &#125;; 显示文字和图标 因为FragmentPagerAdapter中无法指定图标，所以，我们可以在执行完setupWithViewPager后，给已经添加上的tab重新设置： 1234tabLayout.setupWithViewPager(viewPager);tabLayout.getTabAt(0).setText(mTitles[0]).setIcon(R.drawable.home_xml);tabLayout.getTabAt(1).setText(mTitles[1]).setIcon(R.drawable.rank_xml);tabLayout.getTabAt(2).setText(mTitles[2]).setIcon(R.drawable.category_xml); 注意 可以看到setIcon的参数为xml，这样就可以实现点击后图标变色了。 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@drawable/home2\" android:state_selected=\"true\" /&gt; &lt;item android:drawable=\"@drawable/home\" /&gt;&lt;/selector&gt; 只显示图标 这就很简单了,去掉setText就可以： 1234tabLayout.setupWithViewPager(viewPager);tabLayout.getTabAt(0).setIcon(R.drawable.home_xml);tabLayout.getTabAt(1).setIcon(R.drawable.rank_xml);tabLayout.getTabAt(2).setIcon(R.drawable.category_xml); 4. 完整的java 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MainActivity extends AppCompatActivity &#123; private String[] mTitles = new String[]&#123;\"首页\", \"排行\",\"分类\"&#125;; TabLayout tabLayout; ViewPager viewPager; List&lt;Fragment&gt; fragmentList; FragmentPagerAdapter pageAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tabLayout = (TabLayout)this.findViewById(R.id.tabLayout); viewPager = (ViewPager)this.findViewById(R.id.viewPager); initFragment(); initAdapter(); tabLayout.setupWithViewPager(viewPager); tabLayout.getTabAt(0).setText(mTitles[0]).setIcon(R.drawable.home_xml); tabLayout.getTabAt(1).setText(mTitles[1]).setIcon(R.drawable.rank_xml); tabLayout.getTabAt(2).setText(mTitles[2]).setIcon(R.drawable.category_xml); &#125; private void initAdapter() &#123; pageAdapter = new FragmentPagerAdapter(this.getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentList.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mTitles[position]; &#125; &#125;; viewPager.setAdapter(pageAdapter); &#125; private void initFragment() &#123; fragmentList = new ArrayList&lt;Fragment&gt;(); RecentPostsFragment recentPostsFragment = new RecentPostsFragment(); RankFragment rankFragment = new RankFragment(); CategoryFragment categoryFragment = new CategoryFragment(); //添加到数组中 fragmentList.add(recentPostsFragment); fragmentList.add(rankFragment); fragmentList.add(categoryFragment); &#125;&#125; Enjoy Coding! 如果在阅读本博客的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 @orzanglei。","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"TabLayout","slug":"TabLayout","permalink":"http://www.orzangleli.com/tags/TabLayout/"}]},{"title":"第十二篇 Retrofit— 仅对开发版本使用日志","slug":"2017-02-14_第十二篇 Retrofit— 仅对开发版本使用日志","date":"2017-02-13T16:00:00.000Z","updated":"2017-02-14T08:23:39.808Z","comments":true,"path":"2017/02/14/2017-02-14_第十二篇 Retrofit— 仅对开发版本使用日志/","link":"","permalink":"http://www.orzangleli.com/2017/02/14/2017-02-14_第十二篇 Retrofit— 仅对开发版本使用日志/","excerpt":"","content":"12. 第十二篇 Retrofit— 仅对开发版本使用日志 一、 开发版和发布版区别 二、使用不同的日志级别 三、在Github中实战 3.1 新建证书文件 3.2 修改app中配置 在前面的文章中，我们已经给你展示了用Retrofit2 启用请求和响应的日志功能。我们也说明了你应该只在开发版本中启用日志功能，推荐你发布版本应该禁用掉日志功能。本文我们就来介绍下如何自动完成这个功能。 一、 开发版和发布版区别自动化是增长开发者的注意力和生产率的最好工具之一。手动启用和禁用Retrofit日志功能可能是乏味重复的工作。而且增加了发布版本仍然记录日志的风险几率。所以，我们来看看自动实现这个过程：在开发过程中，日志记录功能被启用；发布版本就会禁用掉日志功能。 解决方法如此简单：我们利用Android framework提供的Build.DEBUG boolean型变量。返回值为true代表开发版本，false代表发布版本。之前的文章中，我们的代码是这样的： HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); logging.setLevel(Level.BODY); OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); httpClient.addInterceptor(logging); Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .client(httpClient.build()) .build(); 现在我们稍微改变下代码，实现仅在开发版本启用日志功能： OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); if (BuildConfig.DEBUG) { HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); logging.setLevel(Level.BODY); httpClient.addInterceptor(logging); } Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .client(httpClient.build()) .build(); 它会只在开发版本添加日志拦截器。我们真的强烈推荐你把这种技术或者类似技术应用于你的APP中，这不会花很长时间，反而会每天为你省一点时间。你的时间很重要！ 二、使用不同的日志级别如果你在发布版本中仍然想看到一些日志信息，但是是使用另一种日志级别，你可以用下面这种方法。我们再修改下代码： OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); if (BuildConfig.DEBUG) { // development build logging.setLevel(Level.BODY); } else { // production build logging.setLevel(Level.BASIC); } httpClient.addInterceptor(logging); Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .client(httpClient.build()) .build(); 三、在Github中实战3.1 新建证书文件发布版本需要有用户的证书文件，调试版本使用的是默认的证书文件，所以需要建立自己的证书文件，如果之前已经建过的，可以跳过。 点击菜单中 Build–Generate Signed APK,在弹出的对话框中选择 Create new… ,选择证书的保存位置，填好相关信息点击OK后关闭，然后关闭弹出的Generate Signed APK对话框，证书建立完成。 3.2 修改app中配置点击菜单File–Project Structure,选择Module app。 点击Signing 选项卡，点击“+”号，填写刚刚的证书的路径和密码等内容。 点击Build Types选项卡，选择release,然后在Signing Config下拉列表中选择上一步新建的config . 还需要打开Build Variants ,将app 对应的变量修改为 release .打开Build Variants的方式如图： 修改之前的教程中的ServiceGenerator： public class ServiceGenerator { public static final String API_BASIC_URL = &quot;https://api.github.com/&quot;; private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); private static Retrofit.Builder builder =new Retrofit.Builder() .baseUrl(API_BASIC_URL) .addConverterFactory(GsonConverterFactory.create()); static HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass){ if (BuildConfig.DEBUG) { logging.setLevel(HttpLoggingInterceptor.Level.BODY); httpClient.addInterceptor(logging); } Retrofit retrofit = builder.client(httpClient.build()).build(); return retrofit.create(serviceClass); } } 这样，如果版本不是调试版本，就不会有日志打印出来了。 Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 @orzanglei。","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"第十一篇 Retrofit— 使用日志级别调试请求","slug":"2017-02-13_第十一篇 Retrofit— 使用日志级别调试请求","date":"2017-02-12T16:00:00.000Z","updated":"2017-02-13T12:32:05.226Z","comments":true,"path":"2017/02/13/2017-02-13_第十一篇 Retrofit— 使用日志级别调试请求/","link":"","permalink":"http://www.orzangleli.com/2017/02/13/2017-02-13_第十一篇 Retrofit— 使用日志级别调试请求/","excerpt":"","content":"11. 第十一篇 Retrofit— 使用日志级别调试请求 一 、Retrofit 2 中的日志功能 二、日志级别 2.1 None 2.2 Basic 2.3 Headers 2.4 Body 三、总结 四、在Github中实战 在深入挖掘Retrofit的网络请求艺术后，本文我们看看Retrofit的调试功能，顺便复习下之前学到的知识点。 一 、Retrofit 2 中的日志功能Retrofit2 在网络操作上完全依赖OkHttp.OkHttp的开发者已经发布了一个独立的继承OkHttp的日志拦截工程。你可以把它添加到你项目的build.gradle中： compile &apos;com.squareup.okhttp3:logging-interceptor:3.3.1&apos; 在开发APP或者调试程序时，整合了日志功能，能显示请求和响应信息是非常不错的。因为Retrofit 2默认并没有整合日志功能，所以我们需要添加一个日志拦截器到OkHttp上。幸运的是，OkHttp已经为拦截器做好了准备，你需要做的就是激活它。 HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); // set your desired log level logging.setLevel(Level.BODY); OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); // add your other interceptors … // add logging as last interceptor httpClient.addInterceptor(logging); // &lt;-- this is the important line! Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .client(httpClient.build()) .build(); 二、日志级别打印过多信息会爆掉你的Android 监视器，这就是为什么OkHttp的日志拦截器有个日志级别： NONE, BASIC, HEADERS, BODY.现在带你一起看看每一种日志级别并描述它们的输出内容。 2.1 None无日志 使用这个日志级别配置开发环境会让你的app跳过所有的日志操作。 2.2 Basic打印请求type,url,request body大小，响应状态和response body的大小 D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1 (277-byte body) D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (543ms, -1-byte body) 使用Basic级别会打印最少的请求信息。如果你只对equest body的大小，response body的大小和响应状态感兴趣，这种日志级别最适合你。 2.3 Headers记录请求和响应头，请求类型，url，响应状态 使用Headers级别的日志辉记录请求和响应头。Retrofit或OkHttp默认会添加适当的请求头，但是不会在请求上显示出来，也因为它们是后来才在请求链中被添加上去的。如果你不在Android上截获真实的请求，你什么都看不到。如果你自己添加了请求头，请确保日志拦截器是你最后添加拦截器。如果你最先添加日志拦截器，那请求头上就不会有任何的请求头了。 假设你要自己定义请求头，我们使用Accept和Content-Type这两个字段来验证下输出内容。 D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1 D/HttpLoggingInterceptor$Logger: Accept: application/json D/HttpLoggingInterceptor$Logger: Content-Type: application/json D/HttpLoggingInterceptor$Logger: --&gt; END POST D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (1039ms) D/HttpLoggingInterceptor$Logger: content-type: text/html; charset=utf-8 D/HttpLoggingInterceptor$Logger: cache-control: no-cache D/HttpLoggingInterceptor$Logger: vary: accept-encoding D/HttpLoggingInterceptor$Logger: Date: Wed, 28 Oct 2015 08:24:20 GMT D/HttpLoggingInterceptor$Logger: Connection: keep-alive D/HttpLoggingInterceptor$Logger: Transfer-Encoding: chunked D/HttpLoggingInterceptor$Logger: OkHttp-Selected-Protocol: http/1.1 D/HttpLoggingInterceptor$Logger: OkHttp-Sent-Millis: 1446020610352 D/HttpLoggingInterceptor$Logger: OkHttp-Received-Millis: 1446020610369 D/HttpLoggingInterceptor$Logger: &lt;-- END HTTP 除了服务器的响应头，你还可以看到使用什么协议以及在各自的发送请求和接受响应所用的毫秒级时间。 2.4 Body记录日志请求和响应的请求头和请求体 这是最完整的日志级别，会打印所有请求和响应相关的信息。 D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1 D/HttpLoggingInterceptor$Logger: --9df820bb-bc7e-4a93-bb67-5f28f4140795 D/HttpLoggingInterceptor$Logger: Content-Disposition: form-data; name=&quot;description&quot; D/HttpLoggingInterceptor$Logger: Content-Transfer-Encoding: binary D/HttpLoggingInterceptor$Logger: Content-Type: application/json; charset=UTF-8 D/HttpLoggingInterceptor$Logger: Content-Length: 37 D/HttpLoggingInterceptor$Logger: D/HttpLoggingInterceptor$Logger: &quot;hello, this is description speaking&quot; D/HttpLoggingInterceptor$Logger: --9df820bb-bc7e-4a93-bb67-5f28f4140795-- D/HttpLoggingInterceptor$Logger: --&gt; END POST (277-byte body) D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (1099ms) D/HttpLoggingInterceptor$Logger: content-type: text/html; charset=utf-8 D/HttpLoggingInterceptor$Logger: cache-control: no-cache D/HttpLoggingInterceptor$Logger: vary: accept-encoding D/HttpLoggingInterceptor$Logger: Date: Wed, 28 Oct 2015 08:33:40 GMT D/HttpLoggingInterceptor$Logger: Connection: keep-alive D/HttpLoggingInterceptor$Logger: Transfer-Encoding: chunked D/HttpLoggingInterceptor$Logger: OkHttp-Selected-Protocol: http/1.1 D/HttpLoggingInterceptor$Logger: OkHttp-Sent-Millis: 1446021170095 D/HttpLoggingInterceptor$Logger: OkHttp-Received-Millis: 1446021170107 D/HttpLoggingInterceptor$Logger: Perfect! D/HttpLoggingInterceptor$Logger: &lt;-- END HTTP (8-byte body) 这是唯一一种可以获得响应主体的日志界别。当你和后端开发者有不同意见的时候，用这中日志级别可以显示所有接受到的数据。但是Body级别会在接受大量数据时让你的Android 监视器堵塞。只有在有必要的时候才使用这种日志级别。 三、总结我们希望你能把日志用到你的项目开发中，日志级别的信息会帮助你选择正确的日志级别。尝试不同的日志级别，看看哪个最适合你。即使说Body级别可能会堵塞你的日志监视窗口，但是有可能你只有在显示所有请求细节的时候才能找到你想要的信息。 四、在Github中实战要添加日志记录功能，不需要对已有的业务模块进行修改，只要把ServiceGenerator修改下就可以了，看我修改后的代码： public class ServiceGenerator { public static final String API_BASIC_URL = &quot;https://api.github.com/&quot;; private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); private static Retrofit.Builder builder =new Retrofit.Builder() .baseUrl(API_BASIC_URL) .addConverterFactory(GsonConverterFactory.create()); static HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass){ logging.setLevel(HttpLoggingInterceptor.Level.BODY); httpClient.addInterceptor(logging); Retrofit retrofit = builder.client(httpClient.build()).build(); return retrofit.create(serviceClass); } } 记住，在项目的build.gradle中添加对log拦截器的依赖： compile &apos;com.squareup.okhttp3:logging-interceptor:3.3.1&apos; 在控制台中可以看到很多请求和响应的日志，截图： Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 @orzanglei。","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"第十篇 Retrofit—可选的查询参数","slug":"2017-01-18_第十篇 Retrofit—可选的查询参数","date":"2017-01-17T16:00:00.000Z","updated":"2017-01-18T13:50:30.310Z","comments":true,"path":"2017/01/18/2017-01-18_第十篇 Retrofit—可选的查询参数/","link":"","permalink":"http://www.orzangleli.com/2017/01/18/2017-01-18_第十篇 Retrofit—可选的查询参数/","excerpt":"","content":"10. 可选的查询参数 一、 Retrofit查询参数 二、 可选的查询参数 三、 在Github中实战 前几篇文章，带你领略了添加自定义请求头的技术方法。现在，我们来看看在Retofit中如何让参数可选。 一、 Retrofit查询参数Retrofit使用注解定义查询参数。方法参数前面定义的注解，指定了要查询的参数的名字。在请求执行时，我们要查询的参数就会传递到URL中。现在我们来看个具体的例子。下面的代码讲的就是一个以/tasks作为API endpoint的请求，它提供了一个选项sort参数以达到排序的目的。 public interface TaskService { @GET(“/tasks”) Call","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"9 第九篇 Retrofit—同一key多重value字段","slug":"2017-01-17_9 第九篇 Retrofit—同一key多重value字段","date":"2017-01-16T16:00:00.000Z","updated":"2017-01-17T14:32:19.294Z","comments":true,"path":"2017/01/17/2017-01-17_9 第九篇 Retrofit—同一key多重value字段/","link":"","permalink":"http://www.orzangleli.com/2017/01/17/2017-01-17_9 第九篇 Retrofit—同一key多重value字段/","excerpt":"","content":"9. [跟orzangleli一起学Retrofit2] 第九篇 Retrofit—同一key多重value字段 一、 查询参数 二、 多重查询参数 本文描述如何使用Retrofit执行带有同一个key对应单个value的字段和同一key对应多重value的字段的请求。 一、 查询参数在客户端对服务器的访问中，查询参数是最常用的方法之一。现在来看一个例子，我们从https://api.example.com/中请求一个查询id=123的任务。 https://api.example.com/tasks?id=123 这个api是不存在，只是将URL写出来让你看看查询参数是怎么添加到URL中的。我们假设这个API是存在的，那么我们就能获取一个id=123 的单个任务。 在Retrofit中定义查询参数的方法如下: public interface TaskService { @GET(&quot;/tasks&quot;) Call&lt;Task&gt; getTask(@Query(&quot;id&quot;) long taskId); } 上面的代码中getTask(...)方法需要taskId参数。这个参数会被Retrofit映射到@Query注解包围参数名上去，在本例中，这个被@Query包围的参数就是id，最终组成的url像下面这样： /tasks?id=&lt;taskId&gt; 二、 多重查询参数有些情况下，需要在请求中传递同一个参数名对应的多个值。就以刚刚查询任务的api为例，我们可以扩展参数得到一组不同id的任务列表。 我们要创建的请求url像这样： https://api.example.com/tasks?id=123&amp;id=124&amp;id=125 理想的服务器返回数据应该是从url查询参数给定的ids=[123, 124, 125]对应的一组任务列表。具体代码如下： public interface TaskService { @GET(&quot;/tasks&quot;) Call&lt;List&lt;Task&gt;&gt; getTask(@Query(&quot;id&quot;) List&lt;Long&gt; taskIds); } 只要将方法的参数和返回值替换成List包围的就可以了。但前提是你的服务器或者API支持这种多值参数的查询，我在网上找了一些API测试发现，他们都不支持这种多值查询，会自动将查询结果变为最后一个参数的查询结果。所以，如果读者发现有可用的支持多值查询的API可以联系我，我将添加案例。 Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 @orzanglei。","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"8 第八篇_Retrofit 2— 用@HeaderMap实现动态请求头","slug":"2017-01-16_8 第八篇_Retrofit 2— 用@HeaderMap实现动态请求头","date":"2017-01-15T16:00:00.000Z","updated":"2017-01-17T14:32:19.258Z","comments":true,"path":"2017/01/16/2017-01-16_8 第八篇_Retrofit 2— 用@HeaderMap实现动态请求头/","link":"","permalink":"http://www.orzangleli.com/2017/01/16/2017-01-16_8 第八篇_Retrofit 2— 用@HeaderMap实现动态请求头/","excerpt":"","content":"8. Retrofit 2 — 用@HeaderMap实现动态请求头 一、 动态的请求头 二、 展望 三、 在Github中实战 之前，我们研究了如何用Retrofit添加请求头以及静态修改请求头。本篇文章，我们将深入研究如何给Retrofit的请求添加动态数量的请求头。 这是Retrofit 2.1的新特性，所以在咱们做实验之前，请确保你已经做了升级工作。 一、 动态的请求头我们在之前的教程中给你展示的都是静态的请求头。虽然你可以改变请求头的字段的值，但是你能动态地选择你想要发送的请求头。如果你需要在运行时决定要发送那些请求头到你的请求上的话，@HeaderMap是一种可行方案。 与@Header注解类似，你要在接口的一个参数上声明@HeaderMap。参数的类型必须得是Java Map 接口的实现： public interface TaskService { @GET(&quot;/tasks&quot;) Call&lt;List&lt;Task&gt;&gt; getTasks( @HeaderMap Map&lt;String, String&gt; headers ); } 使用我们上面定义的这个接口很简单。你可以直接创建一个Map实例，并且把你需要的指添加进去即可。Retrofit会把@HeaderMap注解的Map中每一个非null元素添加到请求头中。 TaskService taskService = ServiceGenerator.createService(TaskService.class); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;Page&quot;, String.valueOf(page)); if (BuildConfig.DEBUG) { map.put(&quot;Accept&quot;, &quot;application/vnd.yourapi.v1.full+json&quot;); map.put(&quot;User-Agent&quot;, &quot;Future Studio Debug&quot;); } else { map.put(&quot;Accept&quot;, &quot;application/json&quot;); map.put(&quot;Accept-Charset&quot;, &quot;utf-8&quot;); map.put(&quot;User-Agent&quot;, &quot;Future Studio Release&quot;); } Call&lt;List&lt;Task&gt;&gt; call = taskService.getTasks(map); // Use it like any other Retrofit call 二、 展望本文中，你已经学会了如何使用@HeaderMap 在运行时添加动态数量的请求头。这对之前的静态请求头功能是一个极为出色的扩展。爱死它了。 Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 @orzanglei。 三、 在Github中实战本节内容由于代码与之前变化并不大，而且我没有在Github中找到合适的API,所以暂时不提供实战代码。如果各位读者找到了，可以通知我，我将会补上实战案例。 Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 @orzanglei。","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头","slug":"2017-01-13_[跟orzangleli一起学Retrofit2]  第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头","date":"2017-01-13T04:30:00.000Z","updated":"2017-01-14T14:59:41.760Z","comments":true,"path":"2017/01/13/2017-01-13_[跟orzangleli一起学Retrofit2]  第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头/","link":"","permalink":"http://www.orzangleli.com/2017/01/13/2017-01-13_[跟orzangleli一起学Retrofit2]  第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头/","excerpt":"","content":"7. [跟orzangleli一起学Retrofit2] 第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头目录 一、 添加请求头 1.1 如何覆盖请求头字段 1.2 如何不覆盖请求头字段 二、 小福利请带走 三、 在Github中实战 前面的教程中你已经学了Retrofit中怎么添加请求头。本文就是专门揪出用Retrofit 2和OkHttp interceptor（拦截器） 添加请求头的细节的。Interceptor拦截器在静态地修改请求上，是一种非常好的的方法。什么意思，直白地说，就是拦截器可以修改请求，但是它的修改相当于是一次性的，不能动态修改。 一、 添加请求头常用的添加请求头的例子就是用Authorization字段来认证。如果你需要在每一次请求都是用这个认证的请求头字段，你可以在interceptor（拦截器）中添加这些信息。这样你就不用给每个客户端的请求都添加@Header注解了。 OkHttp 的拦截器提供两种方式添加请求头中的字段及其对应的值。你可以直接覆盖已存在的字段，也可以不检查是否这个字段已经存在都直接添加。接下来，我们就来看看这两种情况。 1.1 如何覆盖请求头字段在OkHttp 拦截器的帮助下，你可以拦截HTTP的请求，对这个请求进行一些定制化处理并操作实际请求。请求的builder 对象有一个.header(key, val)方法，它可以把字段添加到请求中区，如果这个字段key已经存在，那就直接覆盖之前的值。 OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); httpClient.addInterceptor(new Interceptor() { @Override public Response intercept(Interceptor.Chain chain) throws IOException { Request original = chain.request(); // Request customization: add request headers Request.Builder requestBuilder = original.newBuilder() .header(&quot;Authorization&quot;, &quot;auth-value&quot;); // &lt;-- this is the important line Request request = requestBuilder.build(); return chain.proceed(request); } }); OkHttpClient client = httpClient.build(); Retrofit ，尤其是OkHttp允许你添加对同一个key字段添加多个值。.header()方法会替换掉所有已存在的相同key的字段。像上面的代码片段中，每个Authorization中请求字段都会被更新（如果之前已经定义多次的话），他们之前的字段的值就会变成auth-value。 1.2 如何不覆盖请求头字段的确存在用同一个字段的key,但是value不相同的情况。比如，我们来看看这个字段Cache-Control,这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。Http 1.1协议规定，同一个key的多重value的字段是允许的，它们和逗号分隔的列表是一样的。 什么意思？ Cache-Control: no-cache Cache-Control: no-store 上面这段和下面这段作用一样： Cache-Control: no-cache, no-store 使用Retrofit 2和OkHttp 的拦截器，你可以添加对同一个key添加多重value。用到的方法就是.addHeader。 下面的这个例子就是添加多个同一个key添加多重value的字段： OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); httpClient.addInterceptor(new Interceptor() { @Override public Response intercept(Interceptor.Chain chain) throws IOException { Request original = chain.request(); // Request customization: add request headers Request.Builder requestBuilder = original.newBuilder() .addHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;) .addHeader(&quot;Cache-Control&quot;, &quot;no-store&quot;); Request request = requestBuilder.build(); return chain.proceed(request); } }); OkHttpClient client = httpClient.build(); 二、 小福利请带走注意这里的“见微知著”的差别： .header(key, val): 会覆盖之前已经存在的key字段的值 .addHeader(key, val): 不会覆盖，它会继续添加 三、 在Github中实战本节内容由于要求能够在请求头中添加同一个key添加多重value的字段，但是我没有在Github中找到合适的API,如果各位读者找到了，可以通知我，我将会补上实战案例。 Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 @orzanglei。","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"第六篇 Retrofit中添加自定义请求头","slug":"2017-01-13_[跟orzangleli一起学Retrofit2]  第六篇 Retrofit中添加自定义请求头","date":"2017-01-13T04:00:00.000Z","updated":"2017-01-14T14:59:44.400Z","comments":true,"path":"2017/01/13/2017-01-13_[跟orzangleli一起学Retrofit2]  第六篇 Retrofit中添加自定义请求头/","link":"","permalink":"http://www.orzangleli.com/2017/01/13/2017-01-13_[跟orzangleli一起学Retrofit2]  第六篇 Retrofit中添加自定义请求头/","excerpt":"","content":"6. [跟orzangleli一起学Retrofit2] 第六篇 Retrofit中添加自定义请求头目录 一、 定义自定义请求头 1.1 静态请求头 1.2 动态请求头 Retrofit 2中覆盖已存在的请求头 二、 在Github中实战 3.1 创建评论 本文将为你展示如何在接口内部通过@Header注解添加自定义请求头，以及通过拦截请求添加自定义请求头。 一、 定义自定义请求头Retrofit提供两种方式定义HTTP请求头：静态和动态方式。静态请求头在发送不同请求时不能改变。请求头的键值对在接口方法上是固定不变的。 相反地，动态的请求头可以对每一个请求单独设置。 1.1 静态请求头添加静态请求头第一步要做的事是定义请求头，用注解的形式把请求头中的内容添加到你的API方法上。每次调用这个方法的请求都会自动的添加定义好的请求头。注解可以用键值的对构成的字符串的形式或者字符串数组的形式定义。现在来看看两个具体的请求头定义步骤： public interface UserService { @Headers(&quot;Cache-Control: max-age=640000&quot;) @GET(&quot;/tasks&quot;) Call&lt;List&lt;Task&gt;&gt; getTasks(); } 这个例子将键值对定义成静态请求头。当然，你也可以把很多组键值对包裹在花括号{}中作为请求头。就像下面这样： public interface UserService { @Headers({ &quot;Accept: application/vnd.yourapi.v1.full+json&quot;, &quot;User-Agent: Your-App-Name&quot; }) @GET(&quot;/tasks/{task_id}&quot;) Call&lt;Task&gt; getTask(@Path(&quot;task_id&quot;) long taskId); } 除此之外，你还可以通过Retrofit中RequestInterceptor 的intercept方法（需要自行实现Interceptor接口）定义静态请求头。 在Retrofit 2中，你需要拦截OkHttp提供的网络层请求。 OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); httpClient.addInterceptor(new Interceptor() { @Override public Response intercept(Interceptor.Chain chain) throws IOException { Request original = chain.request(); Request request = original.newBuilder() .header(&quot;User-Agent&quot;, &quot;Your-App-Name&quot;) .header(&quot;Accept&quot;, &quot;application/vnd.yourapi.v1.full+json&quot;) .method(original.method(), original.body()) .build(); return chain.proceed(request); } } OkHttpClient client = httpClient.build(); Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .client(client) .build(); 如你所见，上面的代码分别设置了User-Agent和Accept的内容。这些值会传递到Retrofit中所有使用这个Interceptor 发出的请求。 1.2 动态请求头想要定制化程度高点就需要使用动态请求头了。动态请求头像参数一样传递到方法中。给定的参数值将会在请求被执行钱被Retrofit映射到请求头中。看个小栗子吧： public interface UserService { @GET(&quot;/tasks&quot;) Call&lt;List&lt;Task&gt;&gt; getTasks(@Header(&quot;Content-Range&quot;) String contentRange); } 看到没，动态请求头中，你可以为不同的请求传递不同的参数。上面这段代码就是传递动态的Content-Range 到请求头中。 Retrofit 2中覆盖已存在的请求头与Retrofit v1版本不同，Retrofit 2中可以覆盖已存在的请求头字段（言下之意就是Retrofit不支持覆盖）。你可以在传递到OkHttp的client对象中的Interceptor的接口实现中完成对这些字段的覆盖。Request.Builder提供两种添加请求头的方法： .header(key, value)： 如果请求头中已经存在这个字段的话就覆盖 .addHeader(key, value): 即使请求头中已经存在这个字段，也是照样添加，这样请求头中某个字段可能有多个值 二、 在Github中实战在5. [跟orzangleli一起学Retrofit2] 第五篇 在Retrofit的请求主体中发送对象的Github实战中，我们在请求主体中发送评论，之前采用的认证方式是添加查询参数token,其实除了这种认证方式，我们还可以在请求头中添加token信息,下面我们就使用这种方法来发表评论。 3.1 创建评论为了与第五篇文章的实验不冲突，我新建了一个Gist片段。 这里简单说明下，在请求中添加token的格式是： Authorization: token OAUTH-TOKEN 这样，我们简单修改下GithubClient接口： public interface GithubClient { @POST(&quot;/gists/{gist_id}/comments&quot;) Call&lt;ResponseBody&gt; commentGist( @Path(&quot;gist_id&quot;) String gist_id, @Body GistComment comment, @Header(&quot;Authorization&quot;) String token ); class GistComment{ String body; public GistComment(String body) { this.body = body; } } } 然后把MainActivity.java中的Gist_id修改成6582fb0808c585fddb5808b547bfbebf,并且修改下commentGist中的参数： public class MainActivity extends AppCompatActivity { private final static String TAG = &quot;ILearnRetrofit&quot;; private final String Gist_id = &quot;6582fb0808c585fddb5808b547bfbebf&quot;; private final String Github_Token = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Utils.init(this); GithubClient client = ServiceGenerator.createService(GithubClient.class); GithubClient.GistComment comment = new GithubClient.GistComment(&quot;这是Retrofit 2在请求头中使用token认证发出来的评论，发送人是orzangleli&quot;); // 可以把我的id orzangleli 修改成你自己的 Call&lt;ResponseBody&gt; call = client.commentGist(Gist_id, comment, &quot; token &quot;+Github_Token); call.enqueue(new Callback&lt;ResponseBody&gt;() { @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) { if (response.isSuccessful()) i(TAG, &quot;评论成功：&quot; + response.raw()); else i(TAG, &quot;评论失败：&quot; + response.errorBody()); } @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) { i(TAG, &quot;评论失败：&quot; + t.getMessage()); } }); } } 代码中的Github_Token 需要换成你自己的，可以看这篇教程[Retrofit 2 番外篇]将Github作为Retrofit的测试对象,因为它只显示一次，所以记住将这个token保存在本地，以后的教程会经常用到这个token。 最后，你可以到https://gist.github.com/hust201010701/6582fb0808c585fddb5808b547bfbebf中看看，你的评论是否正常的发出了。 我的已经成功了： 本教程所有源码参见此网页：[留白] Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 @orzanglei。","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"第五篇 在Retrofit的请求主体中发送对象","slug":"2017-01-12_[跟orzangleli一起学Retrofit2]  第五篇 在Retrofit的请求主体中发送对象","date":"2017-01-12T04:30:00.000Z","updated":"2017-01-14T14:59:31.088Z","comments":true,"path":"2017/01/12/2017-01-12_[跟orzangleli一起学Retrofit2]  第五篇 在Retrofit的请求主体中发送对象/","link":"","permalink":"http://www.orzangleli.com/2017/01/12/2017-01-12_[跟orzangleli一起学Retrofit2]  第五篇 在Retrofit的请求主体中发送对象/","excerpt":"","content":"5. [跟orzangleli一起学Retrofit2] 第五篇 在Retrofit的请求主体中发送对象目录 一、 在请求主体中发送对象 二、 举个栗子 三、 在Github中实战 3.1 创建评论 一、 在请求主体中发送对象Retrofit能够在请求主体中发送对象，通过使用@Body注解将这些对象指定为HTTP请求主体的内容。相对于之前的版本来说，Retrofit 2中 @Body功能并没有发生变化。 public interface TaskService { @POST(&quot;/tasks&quot;) Call&lt;Task&gt; createTask(@Body Task task); } 事先定义好的Retrofit的转换器（如Gson）将会把传入的对象task映射成JSON格式，最终以请求主体的名义发送到你的服务器上。 二、 举个栗子看个具体的例子吧。 public class Task { private long id; private String text; public Task(long id, String text) { this.id = id; this.text = text; } } 初始化一个Task对象，然后对它的id和text赋值。这样，当你把这个Task对象传给service类的时候，对象的变量名和值会被转化为JSON格式。 Task task = new Task(1, &quot;my task title&quot;); Call&lt;Task&gt; call = taskService.createTask(task); call.enqueue(new Callback&lt;Task&gt;() {}); 调用service中createTask方法，将会把task中的属性转化为JSON格式。task转化后的JSON格式内容像下面这样： { &quot;id&quot;: 1, &quot;text&quot;: &quot;my task title&quot; } 三、 在Github中实战本次我们选用Github中的gist作为操作对象，关于gist是什么，可以参考http://group.jobbole.com/9655/,Github的gist官网是https://gist.github.com/。 当然，gist并不是私有的，别人也是可以访问的，所以你们没有必要再自己创建一个gist片段，可以直接使用我的https://gist.github.com/hust201010701/04793d3d5b53e43d2f6a71b7c3103ea4。其中04793d3d5b53e43d2f6a71b7c3103ea4为gist的id. 因为本节我们我要实战的是在Retrofit的请求主体中发送对象，所以HTTP的请求方式很明显应该为POST,从Github中关于Gist的APIhttps://developer.github.com/v3/gists/comments/中，选取 Create a comment 创建一个评论作为我们的目标。 3.1 创建评论API是这样： POST /gists/:gist_id/comments参数表： 名称 类型 描述 body string 必需，评论内容 这里这说明下，涉及到Github的API，所有请求的基本地址都是： https://api.github.com。地址中的:gist_id就是我们想要访问的gist的id，对本例就是04793d3d5b53e43d2f6a71b7c3103ea4。 下面我们来试试牛刀吧~ 首先是Github请求客户端接口，GistComment为封装好的评论类，发出评论的方法commentGist使用POST方式，url中{gist_id}是动态的可以修改的Gist片段的id,@Query(&quot;access_token&quot;)则表示发表评论时所需要的token参数： public interface GithubClient { @POST(&quot;/gists/{gist_id}/comments&quot;) Call&lt;ResponseBody&gt; commentGist( @Path(&quot;gist_id&quot;) String gist_id, @Body GistComment comment, @Query(&quot;access_token&quot;) String token ); class GistComment{ String body; public GistComment(String body) { this.body = body; } } } 在MainActivity中调用的代码如下所示： public class MainActivity extends AppCompatActivity { private final static String TAG = &quot;ILearnRetrofit&quot;; private final String Gist_id = &quot;04793d3d5b53e43d2f6a71b7c3103ea4&quot;; private final String Github_Token = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Utils.init(this); GithubClient client = ServiceGenerator.createService(GithubClient.class); GithubClient.GistComment comment = new GithubClient.GistComment(&quot;这是Retrofit 2程序发出来的，发送人是orzangleli&quot;); // 可以把我的id orzangleli 修改成你自己的 Call&lt;ResponseBody&gt; call = client.commentGist(Gist_id, comment, Github_Token); call.enqueue(new Callback&lt;ResponseBody&gt;() { @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) { if (response.isSuccessful()) i(TAG, &quot;评论成功：&quot; + response.raw()); else i(TAG, &quot;评论失败：&quot; + response.errorBody()); } @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) { i(TAG, &quot;评论失败：&quot; + t.getMessage()); } }); } } 代码中的Github_Token 需要换成你自己的，可以看这篇教程[Retrofit 2 番外篇]将Github作为Retrofit的测试对象,因为它只显示一次，所以记住将这个token保存在本地，以后的教程会经常用到这个token。 最后，你可以到https://gist.github.com/hust201010701/04793d3d5b53e43d2f6a71b7c3103ea4中看看，你的评论是否正常的发出了。 我的已经成功了： 本教程所有源码参见此网页：[留白] Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 @orzanglei。","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"第四篇__同步和异步请求","slug":"2017-01-12_[跟orzangleli一起学Retrofit2]  第四篇__同步和异步请求","date":"2017-01-12T04:00:00.000Z","updated":"2017-01-14T14:59:44.346Z","comments":true,"path":"2017/01/12/2017-01-12_[跟orzangleli一起学Retrofit2]  第四篇__同步和异步请求/","link":"","permalink":"http://www.orzangleli.com/2017/01/12/2017-01-12_[跟orzangleli一起学Retrofit2]  第四篇__同步和异步请求/","excerpt":"","content":"4. Retrofit 2的同步和异步请求 同步请求 同步请求获取数据 异步请求 异步请求获取数据 获取原始HTTP响应数据 之前的文章，我们带你学习了在web服务或者API请求中Retrofit要设置的东西。本文将给你展示如何通过同步或异步的方式完成真实的请求。 Retrofit支持同步和异步的方式执行请求。从使用者的观点来看，这两种方式的不同之处在于： 同步——使用者通过单个线程调用服务；该线程发送请求，在服务运行时阻塞，并且等待响应。 异步——使用者通过两个线程调用服务；一个线程发送请求，而另一个单独的线程接收响应。 同步请求同步请求和异步请求在Retrofit 2中，在声明客户端（Client）的时候并没有区别，这与Retrofit 1.9不同，Retrofit 1.9是通过修改返回类型和方法参数来声明同步请求。 下面这个例子，当执行getTasks 时期望获取一组Task类型的链表。 public interface TaskService { @GET(&quot;/tasks&quot;) Call&lt;List&lt;Task&gt;&gt; getTasks(); } 在Retrofit 2中，每个请求都被一个Call对象包裹。实际上，同步或者异步请求是用后面创建的call对象使用特定的方法用不同方式执行的。但是，在定义接口上，Retrofit 2的同步请求和异步请求没有区别。 同步请求是执行在主线程上的。这就意味着UI线程会在请求执行的时候阻塞，在此期间，用户的交互操作无法响应。 警告： 同步请求可能会导致Android 4.0+的系统的APP 的崩溃。将会产生NetworkOnMainThreadException错误。 同步方法能够直接返回数据，因为网络请求操作阻塞了所有其他的操作。对于非UI线程，你需要在自己建的单独线程中执行请求。这就意味着，你可以在等待网络响应的过程中继续与APP进行交互。 同步请求获取数据现在来看看同步请求的实战操作。我们就假设你已经对前面几篇文章介绍的ServiceGenerator很熟悉了，下面的代码片段就阐述了同步请求的做法。 TaskService taskService = ServiceGenerator.createService(TaskService.class); Call&lt;List&lt;Task&gt;&gt; call = taskService.getTasks(); List&lt;Task&gt;&gt; tasks = call.execute().body(); Retrofit 2中通过call对象调用.execute()方法，将在执行同步请求。可以通过在响应对象上执行.body()方法获取反序列化的响应内容。 异步请求除了同步请求，Retrofit对异步请求的支持也属于开箱即用（直白点就是用起来很简单）。Retrofit 2在定义接口上，同步和异步是没有区别的，这一点之前说过了。 public interface TaskService { @GET(&quot;/tasks&quot;) Call&lt;List&lt;Task&gt;&gt; getTasks(); } 异步请求中Retrofit 是在单独的线程中执行和处理网络请求的。一般来说使用Callback类，用它来映射你定义好的返回类型。我们的例子就是返回一组Task类型的链表，这一点在Callback内部就会自动映射好的。 异步请求获取数据使用异步请求，你需要实现Callback的两个回调方法：onResponse和onFailure。当从服务类中调用异步请求getTask()方法时，你需要实现一个新的Callback接口，并且定义你需要在请求完成时要做的处理。下面的代码片段就简要说明了一个典型的实现方法。 TaskService taskService = ServiceGenerator.createService(TaskService.class); Call&lt;List&lt;Task&gt;&gt; call = taskService.getTasks(); call.enqueue(new Callback&lt;List&lt;Task&gt;&gt;() { @Override public void onResponse(Call&lt;List&lt;Task&gt;&gt; call, Response&lt;List&lt;Task&gt;&gt; response) { if (response.isSuccessful()) { // 执行成功 } else { // 响应错误，没有权限访问？ } } @Override public void onFailure(Call&lt;List&lt;Task&gt;&gt; call, Throwable t) { // 出错了（如网络没有连接） Log.d(&quot;Error&quot;, t.getMessage()); } } 获取原始HTTP响应数据在Retrofit 2中，获取原始响应数据的方式可以在异步的请求中获取。异步请求的回调方法onResponse()中可以获取Response类型的原始响应对象。具体看代码： call.enqueue(new Callback&lt;List&lt;Task&gt;&gt;() { @Override public void onResponse(Call&lt;List&lt;Task&gt;&gt; call, Response&lt;List&lt;Task&gt;&gt; response) { // 获取原始响应对象 Response raw = response.raw(); } @Override public void onFailure(Call&lt;List&lt;Task&gt;&gt; call, Throwable t) {} } Happy coding! 如果你在阅读本教程中有任何困难或者需要帮助，随时可以在微博上联系我，我的微博是@orzangleli。","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"第二篇__API描述的基础知识","slug":"2017-01-11_[跟orzangleli一起学Retrofit2]  第二篇__API描述的基础知识","date":"2017-01-11T04:30:00.000Z","updated":"2017-01-14T14:59:17.895Z","comments":true,"path":"2017/01/11/2017-01-11_[跟orzangleli一起学Retrofit2]  第二篇__API描述的基础知识/","link":"","permalink":"http://www.orzangleli.com/2017/01/11/2017-01-11_[跟orzangleli一起学Retrofit2]  第二篇__API描述的基础知识/","excerpt":"","content":"2. Retrofit 2 —API描述基础知识目录 如何描述API HTTP 请求方式 HTTP资源位置 方法名和返回类型 路径参数 查询参数 下节预告 在上一节Retrofit入门教程中，你已经完成对Github网站的第一次请求了。希望你对Retrofit更多功能的试验仍保持热情。本节教程中你将学会Retrofit中描述API的更多细节。 如何描述API正如你第一节学到的，我们描述Retrofit所有的请求都是通过接口完成的。在第一个案例中，我们就展示一点点的功能，如下： public interface GitHubClient { @GET(&quot;/users/{user}/repos&quot;) Call&lt;List&lt;GitHubRepo&gt;&gt; reposForUser( @Path(&quot;user&quot;) String user ); } 现在我们来具体看看这些配置项： HTTP 请求方式看来你已经知道，我们在java接口的方法上使用注解来描述API.首先你要定义的是HTTP请求方式，如GET ,POST,PUT,DELETE等。Retrofit为每一种标准的请求方式提供了一个注解。你可以想下面这样简单的方式使用Retrofit注解描述HTTP请求方式： @GET, @POST, @PUT, @DELETE, @PATCH, @HEAD. 你必须明确的支出这个API请求使用什么方式进行请求。如果你从来没有听过HTTP请求方式，，你可以看看这个网址 HTTP维基百科 ，要是打不开就看看国内的吧:http://www.runoob.com/http/http-methods.html。 @GET, @PUT 和 @DELETE的使用简单例子： public interface FutureStudioClient { @GET(&quot;/user/info&quot;) Call&lt;UserInfo&gt; getUserInfo(); @PUT(&quot;/user/info&quot;) Call&lt;UserInfo&gt; updateUserInfo( @Body UserInfo userInfo ); @DELETE(&quot;/user&quot;) Call&lt;Void&gt; deleteUser(); } HTTP资源位置你要把API中的相对地址作为String类型的参数传递给注解，例如@GET(&quot;/user/info&quot;)。大部分情况，你只需要传递相对地址，而不是完整的地址（如http://futurestud.io/api/user/info）。这样做有一个优点，Retrofit只需要请求基本地址 （http://futurestud.io）一次就可以。如果你改变API的基本地址，你也只需要修改一次即可。除此之外，它还让实现一些高级的功能，如动态基本地址，变得更加容易。如果你想继续学些URL处理和怎么将基本地址和相对地址连接到一起的话，欢迎阅读我们的教程 URL handling, resolution and parsing. 我们再看个简单的例子： public interface FutureStudioClient { @GET(&quot;/user/info&quot;) Call&lt;UserInfo&gt; getUserInfo(); @PUT(&quot;/user/info&quot;) Call&lt;UserInfo&gt; updateUserInfo( @Body UserInfo userInfo ); @DELETE(&quot;/user&quot;) Call&lt;Void&gt; deleteUser(); // example for passing a full URL @GET(&quot;https://futurestud.io/tutorials/rss/&quot;) Call&lt;FutureStudioRssFeed&gt; getRssFeed(); } 方法名和返回类型现在你应该知道HTTP请求方式注解是干什么用的了。可是，我们还没有提及Java方法声明：Call&lt;UserInfo&gt; getUserInfo(); . 这里面涉及三个部分： 方法名 方法返回类型 方法参数 先从最简单的开始：方法名。你可以随意定义方法名，Retrofit并不在意，而且它对功能也不会产生影响。不过，你还是应该取一个能够帮助其他开发者理解你这个API是干嘛的名字。 方法的返回类型则颇为严格。你需要定义你想要从服务器获取什么样的数据。例如，当你请求用户信息的时候，你可能会把返回类型写成Call&lt;UserInfo&gt;。 UserInfo 这个类包含一些 带有用户数据的 变量。Retrofit会自动把服务器返回数据映射到UserInfo类的对象中，不需要手动解析。如果你想要原始响应数据，你可以在返回类型中使用ResponseBody 替代 UserInfo 。如果你不关心服务器的响应，你也可以直接使用Void。以上所有情形，都需要包裹在Retrofit的Call&lt;&gt;类中。 最后，也是主要决定API网址末端部分，你可以传递参数到方法中。这些参数有很多种，这里我们就列出一些出来： @Body:把java对象当做请求主体发送出去 @Url：使用动态地址 @Field:以form-urlencoded格式发送数据 再看看使用案例： public interface FutureStudioClient { @GET(&quot;/user/info&quot;) Call&lt;UserInfo&gt; getUserInfo(); @PUT(&quot;/user/info&quot;) Call&lt;Void&gt; updateUserInfo( @Body UserInfo userInfo ); @GET Call&lt;ResponseBody&gt; getUserProfilePhoto( @Url String profilePhotoUrl ); } 因为路径和查询参数很普遍，所以我们会在接下来的两段中讲述它们。 路径参数REST APIs 是建议在动态URL的基础上的（关于REST可进入http://kb.cnblogs.com/page/132129/了解）。你可以通过替换部分URL地址访问资源，如，想要获得hust201010701的CouponView仓库的所有贡献者，可以访问https://api.github.com/repos/hust201010701/CouponView/contributors,其中hust201010701/CouponView就是明确你要访问谁的哪个仓库。Retrofit提供了一种简单的方式替换这些路径参数。你应该在入门指南的教程中看到过了吧。 public interface GitHubClient { @GET(&quot;/users/{user}/repos&quot;) Call&lt;List&lt;GitHubRepo&gt;&gt; reposForUser( @Path(&quot;user&quot;) String user ); } 这里{user}告诉Retrofit，这个值是动态的，当请求发出时会被设置进去。如果你要把一个路径参数放到URL中，你需要给方法的参数添加@Path()标记，@Path标记的值就会替换掉URL的占位符（本例中就是@Path(“user”)）。如果有必要，你可以使用多个占位符。只需要保证你匹配参数的总量。你还可以使用[optional path parameters]（https://futurestud.io/tutorials/retrofit-optional-path-parameters）。 查询参数动态URL另一大类就是查询参数。如果你之前使用过过滤器，你应该看过这个网站：https://www.baidu.com/s?wd=123 . ?wd=123就是一个查询参数，它表明你要搜索的内容,又例如https://futurestud.io/tutorials?filter=video中的?filter=video描述了请求的资源。。和路径参数不同，你不要把它们添加到注解的URL中。你可以很简单的使用@Qurey来添加一个方法的参数和名字。Retrofit会自动把它加到请求中去。如果你传递了null作为查询参数，Retrofit就会忽略这个参数。你可以添加 multiple query parameters。 public interface FutureStudioClient { @GET(&quot;/tutorials&quot;) Call&lt;List&lt;Tutorial&gt;&gt; getTutorials( @Query(&quot;page&quot;) Integer page ); @GET(&quot;/tutorials&quot;) Call&lt;List&lt;Tutorial&gt;&gt; getTutorials( @Query(&quot;page&quot;) Integer page, @Query(&quot;order&quot;) String order, @Query(&quot;author&quot;) String author, @Query(&quot;published_at&quot;) Date date ); } 上面这个例子，使用第二个方法，后面三个参数的值都传递null，这样，你就可以移除第一个getTutorials()方法了。 下节预告这只是一个描述API末端的介绍而已。目前你应该学会了怎么添加新的请求地址到你的接口上去了吧。你可以调整资源的位置，HTTP请求方式，返回类型，路径参数和查询参数。 Retrofit提供了很多选项去进一步修改请求。例如，我们还没有说到的headers(请求头)。接下来还有很多需要学，所以继续学习教程吧！ 欢迎大家关注我的Github 和微博 @orzangleli 。","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"第一篇_Retrofit入门指南及创建一个Android客户端","slug":"2017-01-11_[跟orzangleli一起学Retrofit2]  第一篇_Retrofit入门指南及创建一个Android客户端","date":"2017-01-11T04:00:00.000Z","updated":"2017-01-14T14:59:44.278Z","comments":true,"path":"2017/01/11/2017-01-11_[跟orzangleli一起学Retrofit2]  第一篇_Retrofit入门指南及创建一个Android客户端/","link":"","permalink":"http://www.orzangleli.com/2017/01/11/2017-01-11_[跟orzangleli一起学Retrofit2]  第一篇_Retrofit入门指南及创建一个Android客户端/","excerpt":"","content":"1. [跟orzangleli一起学Retrofit2] 第一篇 Retrofit入门指南及创建一个Android客户端 本系列文章是作者orzangleli基于FutureStudio中的教程经过亲自试验和修改，删除文章中关于1.9版本Retrofit的介绍，让初学者更加方便和清晰地学习Retrofit2.0，并对原文章中部分代码及API作了修改和补充，以达到正常试验效果。本系列文章所有权归orzangleli.com所有，任何人有权转载，但需要标明出处。 本文是Retrofit教程系列的第一篇。本系列通过使用一些案例深入了解Retrofit，并从功能和可扩展性的方面来测试Retrofit. [跟orzangleli一起学Retrofit2]系列总览 将Github作为Retrofit的测试对象 入门指南及创建一个Android客户端 API 基础 创建一个持久化的Android客户端 同步和异步请求 在Request Body中发送对象 添加自定义请求头 Retrofit 2——在OkHttp Interceptor中管理请求头 本篇文章我们将一起学习Retrofit的基础知识，以及对API或者HTTP请求创建一个Android 客户端。 但是，这篇文章并没有涉及很多入门信息和也没有解释Retrofit究竟是什么。对于这些内容，请访问projects homepage Retrofit是什么Retrofit官方主页这样描述它： A type-safe REST client for Android and Java.(Android和Java的类型安全的REST客户端) 本系列中你将学会使用注解描述HTTP请求，URL参数的替换和查询参数。另外，Retrofit还提供对multipart请求主体和文件的上传功能。 如何申明（API）请求请访问阅读Retrofit homepage中API申明部分，好好理解如何构造请求。你将会找到所有重要的信息，而且他们都有着很详细的代码描述。 Android项目的准备工作现在我们言归正传，如果你已经创建了你的Android项目，直接从下一段开始吧。如果没有，请先在你最新最喜欢的IDE中创建一个项目。我们喜欢使用Gradle作为构建系统，但是你也可以使用Maven. 申明依赖项：Gradle或者Maven现在我们把Retrofit添加到你项目的依赖项中。选择你使用的构建系统，在pom.xml或build.gradle中定义Retrofit及其依赖项。当运行命令构建你的代码时，构建系统则会为你的项目自动下载Retrofit库。我们建议将OkHttp配合Retrofit使用，OkHttp还对Okio有依赖性，所以Okio也需要声明依赖性。 Retrofit 1.9本系列译文仅讲述Retrofit2.0,若需要了解之前的版本，请查看英文原版文章。 Retrofit 2pom.xml &lt;dependency&gt; &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt; &lt;artifactId&gt;retrofit&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt; &lt;artifactId&gt;converter-gson&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; build.gradle dependencies { // Retrofit &amp; OkHttp compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos; compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos; } Retrofit 2默认使用OkHttp作为网络层，而且OkHttp也内置到Retrofit2中了，所以你是用OkHttp时不需要在项目中再次声明依赖项了，除非你对OkHttp的版本有特殊要求。（译者注：Retrofit，OkHttp,Okio都是Square公司出品的） 现在，你的项目已经准备好整合Retrofit了，我们一起来创建一个持久的Android API/HTTP 客户端吧~ 持久的Android 客户端在对已经存在的Retrofit客户端的研究中，发现了example repository of Bart Kiers.实际上，这是个使用Retrofit进行OAuth认证的案例。但是，它提供一个可持久化Android客户端的所有必需的基本知识。这就是为什么我们以后会把它作为坚实基础，并且在以后需要使用认证的文章中拿它来扩展。 下面的类定义了我们的android 客户端的基本信息：ServiceGenerator ServiceGeneratorServiceGenerator就是我们的API/HTTP客户端的核心，目前来说，它只是定义了一个为给定类和接口创建REST适配器的方法。代码如下： public class ServiceGenerator { public static final String API_BASE_URL = &quot;http://your.api-base.url&quot;; private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder(); private static Retrofit.Builder builder = new Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()); public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass) { Retrofit retrofit = builder.client(httpClient.build()).build(); return retrofit.create(serviceClass); } } 这个 ServiceGenerator 类使用Retrofit的RestAdapter来创建一个新的带有基本API地址（base URL）的REST客户端.例如，Github的API基本地址是：https://api.github.com/。serviceClass指的是对API请求有注解的类或者接口。以下部分展示Retrofit的具体使用以及如何定义一个典型的客户端。 JSON 映射Retrofit 1.9 默认使用的是Google的Gson库。你所需要做的事就是定义你的响应对象的类，响应数据会自动被映射的。 使用Retrofit2时，你需要明确地为Retrofit指定一个解析器。例如前面，我们已经添加了下面这行代码到build.gradle文件，导入Gson 解析器到Retrofit2中。 compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos; 现在你需要添加你的解析器到Retrofit对象中。在Retrofit的builder中调用.addConverterFactory(GsonConverterFactory.create())整合Gson作为默认Json解析器。 使用Retrofit好，我们器来看一个例子，定义一个REST客户端，从Github上请求数据。首先，我们得创建一个接口，定义一些需要的方法。 Github客户端下面的代码定义了GithubClient接口，里面有一个方法请求获取某一个repository（仓库）的所有contributors（贡献者）。它还举例说明了Retrofit的参数替换功能的使用，当请求方法contributors时，会把GET注解参数中{owner} 和 {repo} 替换成给定的变量。 public interface GitHubClient { @GET(&quot;/repos/{owner}/{repo}/contributors&quot;) Call&lt;List&lt;Contributor&gt;&gt; contributors( @Path(&quot;owner&quot;) String owner, @Path(&quot;repo&quot;) String repo ); } 这里有一个Contributor类，这个类包含一些需要的，对应响应数据中的属性。 static class Contributor { String login; int contributions; } 完整代码如下： public interface GitHubClient { @GET(&quot;/repos/{owner}/{repo}/contributors&quot;) Call&lt;List&lt;Contributor&gt;&gt; contributors( @Path(&quot;owner&quot;) String owner, @Path(&quot;repo&quot;) String repo ); static class Contributor { String login; int contributions; } } 关于前面提到的JSON映射：GitHubClient中定义了一个叫contributors的方法，返回值类型是Call&lt;List&lt;Contributor&gt;&gt;。Retrofit确保服务响应映射正确。 译者注：Contributor中定义的字段并不能随意命名，需要根据服务器返回的json格式的数据做出对应的调整。因为基本地址是：https://api.github.com/，我们手动补全获取所有贡献者的API地址，以我的CouponView为例，完整的请求地址是 https://api.github.com/repos/hust201010701/CouponView/contributors.我们通过观察返回数据（如下图所示），选取其中的login和contributions作为我们想提取的数据，当然你可以自己再添加其他的关键字。 API请求案例下面这一段举例说明了使用ServiceGenerator初始化你的客户端，具体指的就是Github客户端，用创建的这个客户端获取仓库的贡献者。这个片段修改自Retrofit github-client example。 你需要手动在ServiceGenerator中定义基本地址为https://api.github.com/，你还可以在ServiceGenerator中再创建一个包含两个参数的createService()，这两个参数分别是客户端类和基本地址。 首先你需要在AndroidManifest.xml中声明权限（有些权限是以后会用到的）： &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt; 如果你是android 6.0以上系统，还需要在java代码中申请权限，相关代码请自行搜索：Android6.0 申请读写权限 在MainActivity中增加以下代码： new Thread(new Runnable(){ @Override public void run() { GithubClient client = ServiceGenerator.createService(GithubClient.class); Call&lt;List&lt;GithubClient.Contributor&gt;&gt; call= client.contributors(&quot;square&quot;,&quot;retrofit&quot;); contributors = new ArrayList&lt;GithubClient.Contributor&gt;(); try { contributors = call.execute().body(); } catch (IOException e) { e.printStackTrace(); } for(GithubClient.Contributor contributor : contributors) { i(contributor.login+&quot;(&quot;+contributor.contributions+&quot;)&quot;); } } }).start(); 下节预告下一篇文章我们将学习如何使用Retrofit实现基本的认证。我们将给出程序案例，实现带有用户名、邮箱、密码等的web服务或API的认证。进一步地，后面的文章会介绍带token的API认证（包括OAuth）。 希望你能喜欢这个系列的文章。 本文是由orzangleli翻译，原文地址：Getting Started and Creating an Android Client","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"第零篇_将Github作为Retrofit的测试对象","slug":"2017-01-10_[跟orzangleli一起学Retrofit2]  第零篇_将Github作为Retrofit的测试对象","date":"2017-01-09T16:00:00.000Z","updated":"2017-01-14T14:56:59.135Z","comments":true,"path":"2017/01/10/2017-01-10_[跟orzangleli一起学Retrofit2]  第零篇_将Github作为Retrofit的测试对象/","link":"","permalink":"http://www.orzangleli.com/2017/01/10/2017-01-10_[跟orzangleli一起学Retrofit2]  第零篇_将Github作为Retrofit的测试对象/","excerpt":"","content":"[Retrofit 2 番外篇]将Github作为Retrofit的测试对象目录 一、 申请认证token 二、 准备原始数据 2.1 创建你的第一个仓库 2.2 关注一些人 2.3 创建Issues 2.4 Star 自己的仓库 三、 Github API大全 四、 善后工作 本文将阐述，将Github作为Retrofit 2学习时的测试对象要做的准备工作。因为在[跟orzangleli一起学Retrofit2]这个教程中，译者将全部使用Github中的API进行测试实验。 一、 申请认证token因为Github中的部分API是需要认证的，Github中认证有多种方式，但是token认证较为方便，所以选择token认证。我们到这个网页获取token,我建议你新建一个全新的token,命名为RetrofitTest,然后勾上所有的权限，最后点击生成,然后你可以看到一串字符串，这个字符串就是token,将它保存在一个你可以随时找到的位置，因为这个token只会显示一次，以后在找就找不到了。 二、 准备原始数据2.1 创建你的第一个仓库如果你之前创建过仓库可以不用再看这一段。 如图所示，新建一个仓库，命名为RetrofitTest。 2.2 关注一些人因为后面的教程中，会有关于Following API的测试，我们建议你关注一些人。当然我希望你能够关注我的Github:@hust201010701,这里我还推荐一些大牛的Github: @hust201010701 : 本教程译者（非大牛，正在朝大牛方向努力） JakeWharton: Square Inc.的大牛 hongyangAndroid: 鸿洋 kymjs: 张涛-开源实验室 2.3 创建Issues找到自己刚刚创建的RetrofitTest仓库，然后如图所示，创建一个Issue,Issue的标题可以和图中一样，方便标识，Issue的内容可以自由发挥，随意填写。 2.4 Star 自己的仓库在进入RetrofitTest仓库详情页时，右上方的Star按钮，可以自己点一下，这样就相当于自己粉了自己的项目。这样我们以后通过API获取关注者时就不会返回空数据了。 三、 Github API大全Github的所有API可以从https://api.github.com/获取到。 另外，Github开发者页也对Github的API有详细的描述，有兴趣的可以自己深入研究。 四、 善后工作本教程如果学习完了，你又不想让Github中的仓库有任何风险，你可以自行进入https://github.com/settings/tokens删除之前创建的RetrofitTest token。","categories":[{"name":"Retrofit教程","slug":"Retrofit教程","permalink":"http://www.orzangleli.com/categories/Retrofit教程/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.orzangleli.com/tags/Retrofit/"}]},{"title":"Python节日倒计时软件","slug":"2017-01-07_Python节日倒计时软件","date":"2017-01-06T16:00:00.000Z","updated":"2017-01-10T14:12:03.524Z","comments":true,"path":"2017/01/07/2017-01-07_Python节日倒计时软件/","link":"","permalink":"http://www.orzangleli.com/2017/01/07/2017-01-07_Python节日倒计时软件/","excerpt":"","content":"Python 节日倒计时软件制作一. 项目描述本次项目以Python3 作为编程语言，制作一款能够倒计时节日的图形化软件。 1.1 项目动机本次项目的开发动机是： 我想做一个类似于微博上 @古城钟楼 的报时程序，只是我报的时间是节日的倒计时，还想加上 “历史上的今天” 的功能。我关注的一个博主 @新浪无锡 这位小编也会做一个倒计时的话题的微博，我问他是怎么做的，他跟我说他是数出来的，然后我就想帮帮他并且自己也练习练习，于是就想着开发一款这样的软件。同时，也欢迎大家关注我的微博 @orzangleli 1.2 知识点 PyQt5库 requests库 datetime库 BeautifulSoup库 1.3 效果截图默认选中最近一个月的所有传统节日和24节气。 二、附加依赖安装2.1 PyQt安装Qt 是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱。也可用于开发非GUI程序，比如控制台工具和服务器。 参考：wiki–Qt 2.1.1 Windows平台首先下载PyQt5,注意不要下载最新版v5.7.1，最新版目前只有源码，没有可执行(exe)安装包，推荐安装和我相同的版本。进入https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/ 下载 PyQt GPL v5.4.1 for Pythonv3.4(x64) 。注意到底是下载x86还是x64请根据自己系统的位数决定，这里需要注意的是：Python版本的位数需要跟系统保持一致，也就是如果你是64位系统，请一定要安装64位的Python 关于Python版本： 我之前使用的是Python3.5，然后知道引用pyqt库时会一直出错，最后发现Python3.5和PyQt5好像是不兼容的，因为从上面的链接https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/，打开网址就可以看到，人家只适配了Python 3.4版本的，所以乖乖的降级使用吧~ 2.1.2 Linux平台如果 Linux 中默认的 python 3 为 3.5 版本，可以通过以下指令切换到 3.4 。 $ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.4 70 --slave /usr/bin/python3m python3m /usr/bin/python3.4m 安装 PyQt5 。 $ sudo apt-get install python3-pyqt5 安装完成之后，立马进入 Python 命令行交互界面测试是否正确安装。 &gt;&gt;&gt; import PyQt5 如果执行以上的命令没有任何提示，说明成功安装。 2.2 requests库安装在cmd命令行中输入 pip install requests 2.3 datetime库datetime库不用安装，是Python自带的 2.4 BeautifulSoup库pip install bs4 三、编程实现3.1 datetime使用因为要计算倒计时，所以需要知道今天的日期，而且要计算两个日期之前有多少天。 获取当前时间 from datetime import date now = date.today() print(now.strftime(&quot;%Y-%m-%d&quot;)) 获取日期差 from datetime import date now = date.today() chunjie = date(2017,1,28) #春节的日期 chazhi = chunjie - now #相差时间 print(chazhi.days) #只需要知道相差时间的天数 现在只要的datetime的这两个用法就够了，其他的如果有兴趣可以去 这里 查看。 3.2 requests库因为我们要计算节日倒计时必须要知道今年哪些天是节日，而且节日数目比较多，程序员总不能一个个地手动添加到程序中吧，所以我们选择一个可以看到全年节日的网站http://tools.2345.com/jieri.htm ，别看2345流氓软件一大堆，2345实用查询还是有点用的。 首先准备一个节日的Entity 类 from datetime import date class DayEntity(object): def __init__(self,dateStr,festival,type): self.dateStr = &quot;2017/&quot;+dateStr self.year = int(self.dateStr.split(&quot;/&quot;)[0]) self.month = int(self.dateStr.split(&quot;/&quot;)[1]) self.day = int(self.dateStr.split(&quot;/&quot;)[2]) self.festival = festival self.type = type def getDate(self): d = date(self.year,self.month,self.day) return d def getDateString(self): return str(self.year)+&quot;年&quot;+str(self.month)+&quot;月&quot;+str(self.day)+&quot;日&quot; def getFestival(self): return self.festival def getType(self): return self.type 添加所有的节日，包括最后添加高考和考研日期 result = requests.get(&quot;http://tools.2345.com/jieri.htm&quot;) html_data = result.content.decode(&quot;gb2312&quot;) soup = BeautifulSoup(html_data,&quot;html5lib&quot;) year = soup.find(&quot;div&quot;,class_ = &quot;jieri&quot;) clearfix = year.find_all(&quot;dl&quot;,class_=&quot;clearfix&quot;) allFestival = list() for month in clearfix: days = month.find(&quot;dd&quot;).find(&quot;ul&quot;).find_all(&quot;li&quot;) for day in days: a_tag = day.find(&quot;a&quot;) type = &quot;中国传统节日&quot; if &quot;cRed&quot; in str(a_tag[&quot;class&quot;]): type = &quot;中国传统节日&quot; elif &quot;cGreen&quot; in str(a_tag[&quot;class&quot;]): type = &quot;公众 / 国际节日&quot; elif &quot;cBlue&quot; in str(a_tag[&quot;class&quot;]): type = &quot;24节气&quot; else: type = &quot;中国传统节日&quot; dayEntity = DayEntity(day.text.split(&quot;[&quot;)[1][:-1],day.text.split(&quot;[&quot;)[0],type) allFestival.append(dayEntity) allFestival.append(DayEntity(&quot;6/7&quot;,&quot;2017高考&quot;,&quot;中国传统节日&quot;)) allFestival.append(DayEntity(&quot;12/24&quot;, &quot;2017考研&quot;, &quot;中国传统节日&quot;)) 3.3 Qt界面最终要做出来的程序是需要有界面的，而不是终端中显示结果，所以需要使用Qt进行界面设计。 3.3.1 Pycharm中PyQt5的配置主要是添加三个External Tool,具体添加教程可以参考 http://blog.csdn.net/a359680405/article/details/45074761 3.3.2 使用QtDesigner 设计界面在项目名上右键选择external tool打开qtdesiginer . 这是图形化设计界面的工具，可以直接在窗口中拖动控件，并会保存为.ui格式。如图所示，设计界面。 对象结构如下所示： 保存文件，生成的文件形如 window.ui . 3.3.3 使用QtDesigner 设计界面在生成的 window.ui 上右键，选择external tool中的PyUIC,然后会自动生成window.py文件，打开后可以看到，里面是UI的程序。 3.3.4 打包资源需要注意的是，如果程序中使用到了图片资源，虽然可以直接引用图片的资源文件，如下面的代码： self.buttonList[i].setStyleSheet(&quot;background-image:url(checked.png)&quot;) checked.png 是放在项目根目录下的一个图片资源，直接运行是没有问题的，但是如果打包程序，在生成的dist文件夹中只有exe文件，并没有checked.png资源，运行就会没有效果甚至出错，当然你可以把图片复制到dist文件中，但是如果图片很多呢？而且也不便于传播，一个完整exe程序，双击打开就能用是最好的。 所以就需要使用qt的资源包，在qtdesigner中右下角的资源浏览器中，点击“铅笔”图标，添加资源文件。然后点击新建资源文件（弹出的对话框中有6个图标，第一个是新建资源文件），然后点击添加新前缀，取个名字如button,然后选中刚刚新建的button这个前缀，添加文件（倒数第二个图标），这样把需要用到的图标添加进去，可以自己根据需要调整分类。添加好之后的资源文件形如下图： 3.3.5 显示窗口在主入口文件中 定义一个窗口类。 class MainWindow(QMainWindow): def __init__(self,allFestival,parent = None): QMainWindow.__init__(self,parent) self.ui = Ui_mainWindow() self.ui.setupUi(self) self.ui.setFestivalList(allFestival) for festival in allFestival: text = festival.getFestival()+&quot;\\n&quot;+festival.getDateString() left_date = festival.getDate() - now if left_date.days &gt; 0 and left_date.days &lt; 30 and festival.getType() != &quot;公众 / 国际节日&quot;: self.ui.addWidgetIntoGridLayout(text,True) else: self.ui.addWidgetIntoGridLayout(text, False) app = QApplication(sys.argv) mainWindow = MainWindow(allFestival) mainWindow.show() app.exec_() 其中addWidgetIntoGridLayout是我自己在Window.py中添加的一个函数，主要目的是动态添加一个按钮到GridLayout中 def addWidgetIntoGridLayout(self,text,state): button = QtWidgets.QPushButton(text) if self.currentColumn &lt; self.maxColumn - 1: self.currentColumn = self.currentColumn + 1 else: self.currentRow = self.currentRow + 1 self.currentColumn = 0 if state: button.setStyleSheet(&quot;background-image:url(:checkbox/checked.png)&quot;) else: button.setStyleSheet(&quot;background-image:none&quot;) button.setObjectName(str(self.currentRow*self.maxColumn + self.currentColumn)) button.clicked.connect(lambda: self.changeState(int(button.objectName()))) self.buttonList.append(button) self.gridLayout.addWidget(button, self.currentRow, self.currentColumn) self.stateList.append(state) 3.3.6 统计倒计时结果程序中使用了一个list来保存GridLayout中所有的按钮的状态，点击一次按钮时为选中状态，再点击一次就会变成非选中状态。还是用了一个festivalList保存所有的节日信息。点击计算倒计时按钮的时候，就会遍历这个list,如果button为选中状态，那么根据按钮的下标在festivalList查询中查询节日信息，从而计算倒计时时间，具体代码： def calculate(self): now = date.today() flag = True resultStr = &quot;今天是&quot;+str(now.year)+&quot;年&quot;+str(now.month)+&quot;月&quot;+str(now.day)+&quot;日，星期&quot;+self.getChineseStr(now.weekday())+&quot;。今天&quot; for i in range(len(self.stateList)): if self.stateList[i]: festival = self.festivalList[i] resultStr += &quot;距%s还有%d天,&quot;%(festival.getFestival(),(festival.getDate() - now).days) if now == self.festivalList[i].getDate() and flag: resultStr = &quot;今天是&quot; + str(now.year) + &quot;年&quot; + str(now.month) + &quot;月&quot; + str( now.day) + &quot;日，星期&quot; + self.getChineseStr(now.weekday()) + &quot;。今天是&quot;+self.festivalList[i].getFestival()+&quot;。今天&quot; flag = False resultStr = resultStr[:-1]+&quot;。&quot; self.textEdit.clear() self.textEdit.append(resultStr) 四. 程序发布4.1 安装PyInstaller使用 pip install pyinstaller安装 PyInstaller. 4.2 打包程序首先注意打包过程可能出现各种错误，先做好心理准备。 按照网络上的一般教程，使用pyqt库时候，一般是在主入口文件中添加，无论这个文件是否使用到，都需要导入以下库： from PyQt5.QtCore import * from PyQt5.QtWidgets import * from PyQt5.QtGui import * 但是这样，在我的机器上是无法成功打包程序的，经常之前大量的尝试和搜索，找到了解决方案，需要在上面的库之前再加上一行： from PyQt5 import * 告诉打包程序需要使用PyQt5. 打包命令使用 pyinstaller --hidden-import queue -F -w GetFestivalDate.py 其中--hidden-import queue 很重要，如果不加上，可以生成exe但是运行时会闪退。 -F 代表生成一个整体exe文件. -w 代表生成的是图形化程序，对应-c 代表控制台程序。 然后在生成的dist文件夹下就能找到生成的exe文件了，赶紧双击打开试试吧。生成的exe是可以直接拷贝到其他电脑运行的，只是需要注意的是，如果运行的系统的位数需要和你打包程序时的系统一致。 五.后记以上就是整个程序的开发过程，特记录下来，有两个目的，一个是希望后来的初学者不要步入这些坑了，另一个是帮助自己记录这些细节，方便以后查阅。 代码我上传到Github上了，欢迎大家Star her和 Follow me.","categories":[{"name":"Python","slug":"Python","permalink":"http://www.orzangleli.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.orzangleli.com/tags/Python/"},{"name":"软件","slug":"软件","permalink":"http://www.orzangleli.com/tags/软件/"}]},{"title":"2016年度总结","slug":"2016-12-29_2016年度总结","date":"2016-12-28T16:00:00.000Z","updated":"2017-01-10T14:13:17.551Z","comments":true,"path":"2016/12/29/2016-12-29_2016年度总结/","link":"","permalink":"http://www.orzangleli.com/2016/12/29/2016-12-29_2016年度总结/","excerpt":"","content":"今年做了四件事： 找工作 Android Unity Python 1. 找工作今年9月份开始回的武汉找工作，到11月份回无锡，正好两个月时间。因为9月份就找到了比较合适的，所以找工作主要集中在9月份，10月份在武汉基本没怎么去面试，就在剩下的时间里开始了自学Python。 一共找到以下几家公司的Offer,在我所在的学院里，既不算多的，也不算好的。 斗鱼TV 一家总部在武汉的视频直播公司，以前一家独大 中兴 面试的岗位是移动开发工程师，主要觉得没有发展前景 58同城 在北京，远，岗位挺好的，转转里的Android开发 华信证券 在上海，工资一般，但是android团队竟然只有4个人，感觉没有任何希望 善行医疗 在深圳，做医疗VR的，但是工资低 以上几家公司，我选择了58同城，因为相对来说，它是技术上能够拿得有进步的，而且前景也比较好，虽然公司前景跟个人没啥根本利益关系，但是在一家有互联网氛围的公司学习工作也是一种好的体验。 2. Android今年基本上结束了前几年开发android的方式，前几年是利用老的技术不断去开发各种APP,然后上传到应用市场，拿去售卖，再获得广告收入。改变的原因有两个：一方面，我认为加广告对用户体验有很大影响，不愿意使用广告；另一方面，这些广告的收入也是很微薄。所以我就没有必要去为了挣钱去做那些没有特殊意义，为了迎合别人的APP了，我要做我自己想做的APP，学自己想学的技术。 今年Android方面的热门技术都有一些大致的了解： 图片加载库： UIL,Picasso,Glide,Fresco. 网络通信库： Volley,OkHttp,NoHttp MultiDex与热修复: 阿里的AndFix，QQ空间的HotFix,微信的Tinker（还没了解） 1. 开源控件自己也还写了几个开源控件，都上传都Github上了，Github上的图： 1.RoateIndicatorViewDemo 高仿转转APP中的轮播图片的指示器 2.Danmu 弹幕控件，可以切换弹幕水平/竖直运动方向,可以控制弹幕正向/逆向运动 3. CouponView 卡券视图: CouponView 是一个继承自LinearLayout的布局View,边缘可以实现自动裁剪效果，所以用来做优惠券等视图效果很好。 2. Android项目1. Hust-Wuxi 考勤查询系统 因为官方的APP中，没有给考勤查询的功能，要查看考勤只能登陆网页，这很不方便，所以我通过分析网络请求找到了查询的API，然后自己写了一个客户端，用颜色标识考勤结果。 2. 校招宝 一款获取海投网上宣讲会数据的APP,自己利用Bmob增加了评论和收藏的功能。海投网API老是变，我这会写总结的时候，APP又挂了。 3. LOL视频宝 这款软件使用了Python爬虫获取多玩饭盒APP中LOL视频资源，然后存到LeanCloud云端数据库，android端再通过SDK获取云端数据库资源。还未发布，目前正在内测和修改中。 主页 关注页 详情页 下载页 首页菜单 3. Unity3D今年的主要任务也是Unity3D,本身是一款游戏引擎，我们拿来做工业VR应用也是可以的。因为一直没有接到正式的项目，所以在探索与尝试加上导师的指示中做了以下几点工作： 1. TQ的发动机装配生产线的监控系统 因为没有传感器数据，自己根据动画生成了数据库，然后又根据这些数据来模拟车间机械结构动作，只是模型好像有点问题，播放起来有点卡。 2. 某起重机的模拟 这个做了两个项目，一个是在Oculus Rift Dk2下做的，因为oculus这款不带交互设备，只能通过目光中心选取物体，所以动画都是半自动的，点一个按钮，动画就会播放，不可以控制运动过程。 后面Htc Vive眼镜到货了，就开始使用这款眼镜，自带定位器和控制器，所以利用了这个做了一个可以控制运动过程的系统，而且还单独配了一套使用LeapMotion的系统，可以用手直接操作VR场景中的物体。 3. 车床切削过程的VR模拟系统 选取了一款简单的车床，模拟车削加工过程。 4. 发动机侧护板装配VR系统 在VR系统中操作吊机完成侧护板的装配，还可以监控车间的状态参数。 4. Python有人说，人生苦短，我用Python. 真的，自从11月份开始学习Python来，我越来越认同这个观点。Python的强大第三方库，让我渐渐见识到一个新的世界。 1. 七牛文件上传器 利用七牛云，可以把电脑上的文件上传到云空间中，对于图片还可以自动生成Markdown格式外链，方便写博客的时候插入链接，我这篇文章用的就是自己的软件上传的图片。 2. 博客迁移爬虫 之前的博客在主机公园上，真的差，打开首页都要10几秒，后来用了Hexo+Github Pages.要是一份份的复制粘贴之前的博客文章也是效率低，于是写了一个爬虫将博客文章，按照日期保存到本地。 3. LOL视频宝的视频数据爬虫 之前本来想在年前做一款新闻阅读APP的，至于为什么要改成做LOL视频咨询客户端，原因如下： 因为我认为一款新闻客户端是否优秀不在于它交互方式或者UI多么炫酷，而在于新闻的内在质量和推荐算法，就算我能够爬到很多新闻源，也不能将它们堆砌的提交给用户，这是对用户不负责任，所以筛选算法和推荐算法很重要，出于能力问题，这一块我决定放弃。 为什么我要做LOL视频合集，因为现在在PC上找不到完整的LOL分类，大都是零散的，混乱的，不便于用户使用；而目前APP上，我也只看到多玩饭盒做的还可以，有很详细的分类，但是仍然不够好，曾经因为一段时间主播跳槽，虎牙将主播封杀，该主播视频就没有，另一方面，它们这些APP永远在做加法，功能越来越臃肿，我作为LOL玩家，我只想关于LOL的新闻咨询或者视频，不想玩你的社区，不想看你的美女视频，我只想静静的看视频。 所以宗旨是：给用户一个干净的，完整的LOL视频观看体验。 利用Packet Capture和浏览器的F12功能，推理+解析了很久，终于剥离出查询的API.然后赶紧写了一个python把服务器中的视频资源存到数据库中。视频资源挺丰富，数据量有20k. 后记2016年，我主要的我就是四件事情，很惭愧，就做了一点微小的工作，谢谢大家。2017年，继续加油。","categories":[{"name":"未分类","slug":"未分类","permalink":"http://www.orzangleli.com/categories/未分类/"}],"tags":[{"name":"未分类","slug":"未分类","permalink":"http://www.orzangleli.com/tags/未分类/"}]},{"title":"侧护板装配VR系统技术细节","slug":"2016-12-14_侧护板装配VR系统技术细节","date":"2016-12-13T16:00:00.000Z","updated":"2017-01-10T14:13:30.681Z","comments":true,"path":"2016/12/14/2016-12-14_侧护板装配VR系统技术细节/","link":"","permalink":"http://www.orzangleli.com/2016/12/14/2016-12-14_侧护板装配VR系统技术细节/","excerpt":"","content":"目录 模型格式转化和处理 装配流程设计 动画设计 第三方库（VRTK，DOTween）的使用 交互方式设计 一.模型格式转化和处理在任意的VR系统都有大量的模型需求，我总结了以下两种模型获取方式： 1. 使用三维绘图软件绘制模型并转换格式以我常用的Catia为例，先绘制出模型，然后将模型转为CGR格式，注意一定要这个格式，经过我的测试，如果不是这个格式再接下来转换格式时会失败。 2. 使用3Ds Max绘制模型这需要会使用3Ds Max的人员来做，由于我们这边缺乏这样的人，所以一般使用3Ds Max的模型都是从网络上下载下来的。 二. 装配流程设计根据三维仿真视频，可以看出装配流程如下所示： 为了增强交互性，动画中人模型所做的事，将在VR系统中以第一人称的视角完成所有装配。 三. 动画设计可以从动画中看出有几处机构的运动形式： 吊机的控制 侧护板的移动 夹具的夹紧和松开动作 这几种是比较典型的几种运动形式，针对不同的运动形式，需要进行不用的动画设计。 1. 吊机的控制吊机的示意图如下： 吊机的控制，这个是最基本的，就是通Transform组件，对物体进行移动。只不过这些需要注意的是，不同方向的移动是针对不同物体的，例如，上下方向移动是挂钩的移动，而左右移动是电机的移动，前后的移动是横梁的移动。 在程序，我定义了一个枚举类型，表示吊机目前的状态： public enum State {UP,DOWN,FRONT,BACK,LEFT,RIGHT,IDLE}; 其中IDLE表示吊机静止状态。 需要注意的细节 这里有一个技术细节：连接电机和挂钩的『绳子』，它的长度是变化的，需要和挂钩保持同步。在VR系统中它并不是真正的绳子，而是一个圆柱体，绳子长度变化的时候，实际上是圆柱体沿竖直方向的scale值变化。另外，因为绳子总是从电机出发出，所以需要将圆柱体的锚点设置在电机处，否则绳子在变长到一定程度时，会看到绳子已经穿过了电机。 2. 侧护板的移动相对来说，侧护板的移动不是一种『自主运动』，它是被吊机吊起来的，所以这种运动是不同于上述方法的处理。对于侧护板需要事先添加碰撞器，并添加脚本，碰撞器添加在挂带的中心位置，这样当挂钩碰到中心位置时，就能检测到。在检测到碰撞后，判断如果碰撞器如果是来自侧护板，就代表现在用户想使用挂钩将侧护板吊起来。在OnTriggerEnter中，将侧护板的parent设置为挂钩，这样侧护板就能够跟着挂钩移动了。 collider.transform.parent = this.transform; collider.transform.position = bornPlace.position; 3. 夹具的夹紧和松开动作夹具的动作包括张开和闭合，动画如图所示：夹具的动作很复杂，基本上无法通过脚本控制实现，所以，最好使用Unity中的Animation完成动画，而且夹具的动作张开和闭合是对称的，所以只需要完成闭合的动作就可以了，张开的动作可以将动画的播放速度调整为-1即可倒着播放。另外，在夹具闭合的时候，要把护板添加到夹具的两侧中，以达到夹具加紧侧护板的视觉效果。下面就是夹具闭合的代码： public void bihe() { AnimatorStateInfo info = animator.GetCurrentAnimatorStateInfo(0); if ((info.IsName(&quot;jiaju_zhangkai&quot;) &amp;&amp; info.normalizedTime &gt;= 1) || info.IsName(&quot;idle&quot;)) { //将左右护板添加到夹具中 Transform yeyazhijia = this.transform.parent; Transform left_huban = yeyazhijia.FindChild(&quot;huban_guadai_left(Clone)&quot;); Transform right_huban = yeyazhijia.FindChild(&quot;huban_guadai_right(Clone)&quot;); Transform zuodangban = this.transform.FindChild(&quot;jiajuzhengti_copy/jiaju/zuodangban&quot;); Transform youdangban = this.transform.FindChild(&quot;jiajuzhengti_copy/jiaju/youdangban&quot;); if (Vector3.Distance(left_huban.position, zuodangban.position) &gt; Vector3.Distance(left_huban.position, youdangban.position)) { normal = false; if (left_huban != null) left_huban.parent = youdangban; if (right_huban != null) right_huban.parent = zuodangban; } else { normal = true; if (left_huban != null) left_huban.parent = zuodangban; if (right_huban != null) right_huban.parent = youdangban; } animator.Play(&quot;jiaju_bihe&quot;); biheButton.interactable = false; zhangkaiButton.interactable = true; //同时使碰撞器失效，防止在未松开之前拉上去 this.GetComponent&lt;Collider&gt;().enabled = false; stepHint.text = &quot;夹紧操作完成，请点击菜单中的『夹具张开』按钮&quot;; } } 四. 第三方库（VRTK，DOTween）的使用本VR系统中主要使用了两个第三方库： VRTK 这个工具包提供了很多Unity3d里的常用VR功能，如下（但并不局限于此）： 带有通用别名的控制器按钮事件 控制器世界指针（如激光指针） 玩家传送 用控制器抓取对象 用控制器和对象交互 DOTween DOTween是Unity中具有强大功能的动画插件 1. VRTK的使用1）. VRTK的安装VRTK从Assets Store中下载，下载完成后导入即可。 2）. VRTK 射线的使用在SteamVR包中[CameraRig]的Controller(right)上添加脚本VRTK_UI_Pointer,这是射线基本脚本，可以设置射线何时显示，比如按住按钮或者切换按钮或者一直显示等。 还需要添加VRTK_Simple_Pointer脚本，这是直线射线发射脚本，除此之外还可以使用 VRTK_Bezier_Pointer它是贝泽尔曲线脚本。要指定按钮按住之后发射射线，还需要添加VRTK_Controller Events脚本，可以设置按下哪个按钮后发出射线。 3）. VRTK 中UI的使用VRTK中UI使用非常简单，只需要在普通的UGUI的Canvas上添加VRTK_UI Canvas脚本即可。 2. DOTween的使用DOTween十分强大，但是我在本系统中也只是使用到了其中的一部分功能。 1). 物体的移动比如场景中，装配完成后，让生产线移动，实际上就是使用DOTween中的DOMove方法 go.transform.DOLocalMoveZ(go.transform.localPosition.z - 1200f, 60).SetEase(Ease.Linear); DOLocalMoveZ指的是在局部坐标系的Z轴方向上移动到go.transform.localPosition.z - 1200f这个位置，实际上就是向Z轴反方向移动1200，所用的时间是60秒，动画插值器使用的是线性插值。 2). 物体的缩放在菜单显示和关闭的时候，增加一个缩放的动画可以增强用户体验 toolbox.transform.DOScale(0.005f, 0.5f); 这句代码的意思就是将菜单的大小放大到0.005,使用的时间是0.5秒。 3). 滚动数码管显示器 要实现以上效果，需要在Canvas下添加一个遮罩层(Image组件)，给遮罩层添加Mask脚本，并且给Image指定一个图片，这个图片就是指定的Mask的遮罩形状，这样在遮罩层以外的UI都不会显示了。 要实现文字连续滚动，事先添加两个Text，如图所示，由于有Mask层存在，第二个是看不到的。 然后给这两个Text上添加脚本，让他们移动。 this.transform.DOLocalMoveX(this.transform.localPosition.x -1000f,5).SetEase(Ease.Linear).SetLoops(-1,LoopType.Restart); 数码管的长度正好为1000，让两个文字一起在5秒中内向左移动1000，移动完成后重新启动动画(复位)，这样就实现了文字无限循环的滚动了。 五. 交互方式设计系统做出来是给人使用的，交互设计也是十分重要，虽然目前我对本系统的交互设计上也有点意见，但是目前尚未找到更好的方案，下面将详细说明。 1. 左手手柄 左手手柄的触摸板，轻触时显示控制吊机移动的菜单，滑动可以选择菜单，按下时将执行动作。 左手手柄的Grip键(侧面的两个按钮)是旋转挂钩的方向的。 Application键用来显示和隐藏手柄上的提示文字 2. 右手手柄 触摸板按下时发出射线 若发出的射线指向地面，松开触摸板即可瞬移到该位置 若发出的射线指向UI界面，配合Trigger(扳机键)可以实现点击按钮的操作。 Grip键(侧面的两个按钮)是用于显示和关闭菜单的 3.目前方案存在的问题之前说过这个方案是有不足的，主要在于吊机的控制。吊机需要6个按钮来控制，分别是上下东西南北，如果要将这6个按钮显示在一起，就是上面的方案，可以看到无论怎么分布，使用无法保证东西南北的四个方向与真实的场景中的方向一致，所以在操作吊机时，不熟悉的使用者需要一直看着手柄进行操作。 4.潜在的解决方法1). 分解菜单在展会的时候，有人就提出了这个问题，后来我问他有什么好的建议，他说可以把东西南北做到左手手柄上，将上下两个按钮做到右手手柄上，这样右手手柄上发射射线的按钮就需要修改下了，不过这也是一种方案。 2). 将6等分菜单变为8等分菜单很简单的原理，示意图如下所示： 至于哪种方案好，我暂时也没有办法判断，所以只好先全部记录下来了。","categories":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/categories/unity3D/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"}]},{"title":"pyqt打包失败.md","slug":"2016-12-13_pyqt打包失败","date":"2016-12-12T16:00:00.000Z","updated":"2016-12-29T13:51:57.927Z","comments":true,"path":"2016/12/13/2016-12-13_pyqt打包失败/","link":"","permalink":"http://www.orzangleli.com/2016/12/13/2016-12-13_pyqt打包失败/","excerpt":"","content":"pyqt 打包失败 出现pyi_rth_qt4plugins 找不到的问题 pyqt5的位数和系统位数要一致。 pyqt版本为：PyQt GPL v5.4.1 for Pythonv3.4(x64) 环境截图： 使用下面的语句进行打包：pyinstaller –hidden-import queue -F -w MainWindow.py 后来由出现QtCore可以找到，但是QtWidgets找不到，但是不知道怎么回事，重新打包了n次后就自动好了，不知道是不是之前设置的环境变量要过一会才会生效，设置的环境变量就是QtCore,QtGui,QtWidgets三个dll文件。 在管理员模式下运行命令行，进行PyInstaller安装 加上这句话： from PyQt5 import *这句话才是精髓，不加就不能运行，加了就可以。。。额！ C:\\Users\\Administrator\\AppData\\Roaming\\pyinstaller\\bincache00_py34_64bit\\qt5gui.dll 可能是去这个目录找那个dll，然后没找到。","categories":[{"name":"python","slug":"python","permalink":"http://www.orzangleli.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.orzangleli.com/tags/python/"}]},{"title":"使用Python将Jpeg Png Gif 图片转换为 webp格式","slug":"2016-11-10_Python将Jpeg Png Gif转换为Webp格式","date":"2016-11-09T16:00:00.000Z","updated":"2016-11-10T14:05:29.034Z","comments":true,"path":"2016/11/10/2016-11-10_Python将Jpeg Png Gif转换为Webp格式/","link":"","permalink":"http://www.orzangleli.com/2016/11/10/2016-11-10_Python将Jpeg Png Gif转换为Webp格式/","excerpt":"","content":"使用Python将Jpeg Png Gif 图片转换为 webp格式一.动机因为webp的优良特性： 占空间小，节省带宽 总体加载速度快 这里有详细的介绍： 摘自 维基百科-WebP词条 WebP（发音weppy）[6][7]，是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式[8]，派生自视频编码格式VP8[9]，被认为是WebM多媒体格式的姊妹项目，是由Google在购买On2 Technologies后发展出来[10]，以BSD授权条款发布。[11]WebP最初在2010年发布，目标是减少文件大小，但达到和JPEG格式相同的图片质量，希望能够减少图片档在网络上的发送时间。 [12]2011年11月8日，Google开始让WebP支持无损压缩和透明色（alpha通道）的功能，而在2012年8月16日的参考实做libwebp 0.2.0中正式支持[13][14]。根据Google较早的测试，WebP的无损压缩比网络上找到的PNG档少了45％的文件大小，即使这些PNG档在使用pngcrush和PNGOUT处理过，WebP还是可以减少28％的文件大小[15]。WebP支持的像素最大数量是16383x16383。有损压缩的WebP仅支持8-bit的YUV 4:2:0格式。而无损压缩（可逆压缩）的WebP支持VP8L编码与8-bit之ARGB色彩空间。又无论是有损或无损压缩皆支持Alpha透明通道、ICC色彩配置、XMP诠释数据。WebP有静态与动态两种模式。动态WebP（Animated WebP）支持有损与无损压缩、ICC色彩配置、XMP诠释数据、Alpha透明通道。而无损压缩的动态WebP亦支持8-bit之ARGB色彩空间。 二. 方案实验1. 使用PIL 转换格式首先指出，PIL转换在大部分情况下都能起到很好的效果，比如讲jpeg转为webp，节省空间约90%。首先安装PIL模块 pip install pillow 然后在程序中 localfile 为图片路径 im = Image.open(localfile) f,ext = os.path.splitext(localfile.split(&quot;/&quot;)[-1]) webp_path = &quot;%s.webp&quot;%f im.convert(&apos;RGB&apos;).save(webp_path, &quot;webp&quot;) 这里需要注意需要将图片先转化为RGB模式，否则报错 cannot write mode P as WEBP 现在，是时候说下PIL「失效」的情况了。 将动图转为gif时，转化过程没有报错，但是打开后，只保存了第一帧的图片，变成了静态图。 将 gif 转为 webp格式时，同样也只保存了第一帧。 第一种情况我没有测试，但是在stackoverflow上可以看到有人提问过： Saving an animated GIF in Pillow 。回答者是建议使用gifmaker 模块进行处理gif. 第二张情况，我遇到了，所以可以证实。 通过搜索，在官网上看到gif2webp,证明官网给出了gif转webp的解决方案，那我们就下载适合自己版本的库.解压后，将bin 目录下的 gif2webp.exe 复制到 工作目录下。接下来，我们使用它来转化格式。 2. 使用gif2webp.exe转化格式根据官网给的文档gif2webp，我们可以很方便的使用下面的语句来实现： f,ext = os.path.splitext(localfile.split(&quot;/&quot;)[-1]) webp_path = &quot;%s.webp&quot;%f os.system(&quot;gif2webp.exe &quot;+ localfile + &quot; -quiet &quot; + &quot; -o &quot; + f + &quot;.webp&quot;) 这里可能会提示： GIF decode warning: invalid background color index. Assuming white background. 转换过程持续好几秒，请耐心等待，转化完成后，工作目录下多一个webp文件. 三.效果比较左边是gif格式的 右边是webp格式 你的肉眼能看出区别么？","categories":[{"name":"python","slug":"python","permalink":"http://www.orzangleli.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.orzangleli.com/tags/python/"}]},{"title":"自己动手造轮子系列———实现『转转APP』Indicator 效果","slug":"2016-11-19_转转Indicator","date":"2016-11-09T16:00:00.000Z","updated":"2016-11-10T14:06:01.443Z","comments":true,"path":"2016/11/10/2016-11-19_转转Indicator/","link":"","permalink":"http://www.orzangleli.com/2016/11/10/2016-11-19_转转Indicator/","excerpt":"","content":"自己动手造轮子系列———实现『转转APP』Indicator 效果一.『转转APP』效果预览注意看Indicator指示器 二.动作分析 左边部分 左边部分是一个白色的圆圈，圆圈中用红色字体显示当前页数，在ViewPager滑动时，白色圆圈绕Y轴旋转，在旋转180度时，即显示背面的时候，圆圈中字变成下一页的页码。 右边部分 右边部分比较简单，一个带缺口的椭圆，上面显示着总页数。 三.各个击破难点1. 用canvas绘制绕Y轴旋转Canvas 绘制图片时，如果是在绕Z轴旋转是比较简单，使用Matrix矩阵： Matrix matrix = new Matrix(); matrix.setRotate(angle); Bimtap newBitmap = Bitmap.createBitmap(oldBitmap,0,0,oldBitmap.getWidth(), oldBitmap.getHeight(),matrix,true); 但是这只能在绘制图片时进行旋转，如果要对一个整体旋转则无法做到，比如，上面转转的指示器坐标的圆圈，圆圈是一个圆，上面还有数字，要实现圆和数字一起旋转，所以无法通过上述方法完成。 而且这个问题我在谷歌上搜索，也不太好表述，刚开始搜索「android canvas 3D旋转」，结果也不太相符，后来搜索「android canvas绕y轴 旋转」，才找到符合的。 使用 Android.graphics.Camera 的 rotateY 接口实现绕 Y 轴旋转时矩阵的运算。 首先声明camera camera = new Camera(); 在Ondraw方法中，首先对canvas状态进行保存，使用的是canvas.save(),然后将camera状态保存，将camera旋转一个角度rotateAngle，在获取camera的矩阵赋值到matrix中，最后将camera状态恢复至旋转之前的状态。然后将matrix追加到当前canvas的矩阵中，使用的是concat方法，这时候整个画布相当于旋转了rotateAngle角度，画完圆之后再恢复至原来的状态。 canvas.save(); Matrix matrix = new Matrix(); camera.save(); camera.rotateY(rotateAngle); camera.getMatrix(matrix); camera.restore(); mPaint.setColor(textBackgroundColor); int centerX = diameter / 2; int centerY = diameter / 2; matrix.preTranslate(-centerX, -centerY); matrix.postTranslate(centerX, centerY); canvas.concat(matrix); canvas.drawCircle(diameter / 2, diameter / 2, diameter / 2, mPaint); canvas.restore(); 2. canvas drawText文字垂直居中这个问题，如果没有遇到还真不知道会出现这种问题，一般想象的，我设置画笔的gravity属性为Paint.Align.CENTER，在将文字的中点设置下不就ok了么，如下面的代码： textPaint.setTextAlign(Paint.Align.CENTER); canvas.drawText(&quot;of &quot; + maxPage, rect.centerX(), rect.centerY(), textPaint); 出现的效果，如图所示，发现文字是偏上： 这是怎么回事呢？其实我们设置的文字爱中心点处绘制，实际上，文字是以基准线为锚点进行绘制的，英文叫做baseline. 在维基百科中可以看到基线的解释： 所以我们如果想让文字居中，则需要将绘制点的Y坐标向下移动。 基线到字体顶端的距离为top,基线到字体底端距离为bottom,则有以下等式： (top + baseline)+ (bottom + baseline) / 2 = centenY() 那么经过计算就可以算出baseline的值，通过Paint.FontMetrics获取top和bottom值，代码如下： //画文字 Rect rect = new Rect(diameter, 0, (int) (diameter * 3.4f), diameter);//右边的背景图片的Rect Paint textPaint = new Paint(); textPaint.setColor(Color.WHITE); textPaint.setTextSize((int) (diameter * 0.6f)); textPaint.setStyle(Paint.Style.FILL); //该方法即为设置基线上那个点究竟是left,center,还是right 这里我设置为center textPaint.setTextAlign(Paint.Align.CENTER); Paint.FontMetrics fontMetrics = textPaint.getFontMetrics(); float top = fontMetrics.top;//为基线到字体上边框的距离,即上图中的top float bottom = fontMetrics.bottom;//为基线到字体下边框的距离,即上图中的bottom int baseLineY = (int) (rect.centerY() - top / 2 - bottom / 2);//基线中间点的y轴计算公式 canvas.drawText(&quot;of &quot; + maxPage, rect.centerX(), baseLineY, textPaint); 3. 自动轮播自动轮播，通过Handler+Timer即可。 //定时自动播放 timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { Message message = new Message(); message.what = 1; if (mViewPager.getCurrentItem() == Integer.MAX_VALUE - 1) { currentIndex = -1; } currentIndex = mViewPager.getCurrentItem(); message.arg1 = currentIndex + 1; mHandler.sendMessage(message); } },1000,2000); 然后自定义Handler. //定时轮播图片，需要在主线程里面修改 UI private Handler mHandler = new Handler() { public void handleMessage(Message msg) { switch (msg.what) { case 1: mViewPager.setCurrentItem(msg.arg1,true); } } }; 四.代码实现代码在Github上，请不要吝啬Star噢。 RotateIndicatorView 联系方式和建议微博：orzangleli","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"自己动手造轮子系列","slug":"自己动手造轮子系列","permalink":"http://www.orzangleli.com/tags/自己动手造轮子系列/"}]},{"title":"Plugin is too old, please update to a more recent version解决方法","slug":"2016-11-04_Plugin is too old, please update to a more recent version解决方法","date":"2016-11-03T16:00:00.000Z","updated":"2017-01-10T14:13:45.083Z","comments":true,"path":"2016/11/04/2016-11-04_Plugin is too old, please update to a more recent version解决方法/","link":"","permalink":"http://www.orzangleli.com/2016/11/04/2016-11-04_Plugin is too old, please update to a more recent version解决方法/","excerpt":"","content":"#Plugin is too old, please update to a more recent version问题解决方法 Android Studio 报错： Plugin is too old, please update to a more recent version, or set ANDROID_DAILY_OVERRIDE environment variable to… 网上众说纷纭，但是实际上没有几个能用。首先当然你可以把gradle版本调低，运行没问题，但是就不能体验到Instant Run等新功能，为了体验新功能，按照以下步骤进行。 1. 查看最新的gradle插件修改Project的build.gradle中版本查看最新版本gradle插件 打开build.gradle(Project:xxx),修改下面代码为 修改前 classpath &apos;com.android.tools.build:gradle:1.3&apos; 修改后 classpath &apos;com.android.tools.build:gradle:+&apos; 2. 查看最新版本的gradle进入gralde下载网站： Gradle Distributions 如图所示： 可以看到最新版是gradle-3.2-rc-2-all.zip 3.修改gradle-wrapper.properties将gradle-wrapper.properties 中distributionUrl指向的内容修改为： distributionUrl=https\\://services.gradle.org/distributions/xxx xxx 为你在官网看到的最新版的文件名字 如： distributionUrl=https\\://services.gradle.org/distributions/gradle-3.2-rc-2-all.zip 现在就可以使用新版功能了，而且之后也看不到烦人的更新提示了。","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"Python 实用技巧————博客文档备份及格式转化","slug":"Python实战_博客备份及格式转换","date":"2016-11-02T16:00:00.000Z","updated":"2017-01-10T14:15:05.074Z","comments":true,"path":"2016/11/03/Python实战_博客备份及格式转换/","link":"","permalink":"http://www.orzangleli.com/2016/11/03/Python实战_博客备份及格式转换/","excerpt":"","content":"1. 为什么要备份博客文章？备份博客文章原因有很多，其中很重要的一点就是担心服务器数据丢失。我购买的是主机公园的香港主机，当时图便宜，也图方便（不需要备案），因此购买此主机，购买之后发现使用很是不方便： 一方面速度很慢，打开主页都需要几秒钟，而且有时候我的浏览器已经有缓存了，打开还是很慢； 二是服务器时不时的挂掉，服务商还做过几次空间迁移。 正因为这些原因，让用户体验很差，网友们通过搜索引擎搜索到之后，打开网站等待时间过长，一般来说就会直接关闭网页了。另一方面，空间中的文章也处于一种不安全的状态，随时可能找不到备份文件。 2. 为什么要放弃wordpress？之前建博客的重点是有一个可以保存自己文章的位置，可以随时记录，随时查阅，但是作为一个极简主义者，实在受不了wp的臃肿设计，而且使用几个插件之后网页巨卡无比，让人无法接受。 在知乎和google上搜索“个人编程博客框架”时，很多推荐了Hexo，这是一个基于Node.js的博客框架，非常好用，对于日常博客类网站十分适合。 3.Hexo的安装和配置教程参见这位大神的教程： niices 4.博客备份原理及步骤下面进入正题。 4.1 博客备份原理首先需要知道wp站点有大量的css和js，是动态网站，无法使用urllib直接获取网站源码。这里使用selenium 中的webdriver 配合phantomjs.exe ，这是一个真实的浏览器访问网站，所以不需要添加任何UA标识等。在wp的首页，使用浏览器访问主页，按F12或者右键审查元素，查看文章标题的class.(不同的主题可能略微有些不同) 可以知道文章的标题由 &lt;h2 class=&quot;entry-title&quot;&gt; 包含，再使用selenium获取网页源码之后，使用BeautifulSoup可以定位到这个标签： titles =soup.findAll(class_=&quot;entry-title&quot;) 因为主页中有很多文章，所以有很多类似的标题，我们需要将所有的都获取到。 for title in titles: address = title.find(&quot;a&quot;)[&quot;href&quot;] self.articles.add(address) self.articles 是一个set集合。用于保存所有文章的url,通过上面的代码可以将每篇文章中的代码保存到self.articles中 这是获取主页的第一页的所有文章，还有第2页等。所以定义一个函数，根据页码获取文章地址： def getArticlesByPageIndex(self,pageIndex): self.browser.get(&quot;http://www.orzangleli.com/page/%d/&quot;%pageIndex) time.sleep(6) soup = BeautifulSoup(self.browser.page_source,&quot;html5lib&quot;) titles =soup.findAll(class_=&quot;entry-title&quot;) for title in titles: address = title.find(&quot;a&quot;)[&quot;href&quot;] self.articles.add(address) print(address) 通过一个for循环完成所有页面的文章url添加，之所以是i+1,是因为range(3)表示{0，1，2}： def getAllArticles(self): for i in range(self.pages): self.getArticlesByPageIndex(i+1) 这样，所有文章的url都存在self.articles中了，在浏览器中访问一个文章，观察文章的中信息，同样通过bs4可以获取文章的标题，发表时间，分类目录，hexo中的md文档还需要指明tag，这里我用分类代替，而分类使用之前分类的第一个分类代替，这些信息还要以特定格式保存在md中，下面代码负责返回一个md文档中head： def mdheader(self,title,date,tags,category): head = &quot;&quot;&quot;--- title: %s date: %s tags: %scategories: %s ---&quot;&quot;&quot;%(title,date,tags,category) return head 获取到文章的正文内容后，使用html2text将html语言转为markdown语言。html2text的文档在：html2text，将head和html2text转化的内容连接，组成完整的md文档。 入口函数为： def saveBlog(self): self.getAllArticles() for url in self.articles: self.save2md(url) 在最外层使用下面代码初始化类： browser = webdriver.PhantomJS(executable_path =”phantomjs.exe”) blog = Blog(browser,5) blog.saveBlog() 完整代码： import requests from selenium import webdriver import time import html2text from bs4 import BeautifulSoup class Blog(): def __init__(self,browser,pages): self.browser = browser self.pages = pages self.articles = set() def getArticlesByPageIndex(self,pageIndex): self.browser.get(&quot;http://www.orzangleli.com/page/%d/&quot;%pageIndex) time.sleep(6) soup = BeautifulSoup(self.browser.page_source,&quot;html5lib&quot;) #print(self.browser.page_source) titles =soup.findAll(class_=&quot;entry-title&quot;) for title in titles: address = title.find(&quot;a&quot;)[&quot;href&quot;] self.articles.add(address) print(address) def getAllArticles(self): for i in range(self.pages): self.getArticlesByPageIndex(i+1) def save2md(self,page_address): self.browser.get(page_address) time.sleep(6) #需要事先在wp后台关闭禁用掉代码高亮显示插件 soup = BeautifulSoup(self.browser.page_source,&quot;html5lib&quot;) title = soup.find(class_=&quot;entry-title&quot;).text date = soup.find(class_=&quot;updated&quot;)[&quot;datetime&quot;].split(&quot;T&quot;)[0] content = soup.find(class_=&quot;entry-content&quot;) #获取标签 categorys = soup.findAll(&quot;a&quot;,{&quot;rel&quot;:&quot;category tag&quot;}) tags = &quot;&quot; for category in categorys: if category.text.startswith(&quot;未分类&quot;): break tags = &quot;%s- %s\\n&quot;%(tags,category.text) head = self.mdheader(title,date,tags,categorys[0].text) #print(content) mdcontent = html2text.html2text(str(content)) #给md文档加上头 mdcontent = &quot;%s\\n%s&quot;%(head,mdcontent) #删除作者署名信息 mdcontent = mdcontent.split(&quot;![](http://2.gravatar.com/avatar/e9a1c2c77d47ac4dcfeb1fa2fc1c936a?s=42&amp;d=mm&amp;r=g)&quot;)[0] with open(&quot;%s_%s.md&quot;%(date,title),&quot;w+&quot;,encoding=&quot;utf-8&quot;) as file: file.write(mdcontent) file.close() def saveBlog(self): self.getAllArticles() for url in self.articles: self.save2md(url) def mdheader(self,title,date,tags,category): head = &quot;&quot;&quot;--- title: %s date: %s tags: %scategories: %s ---&quot;&quot;&quot;%(title,date,tags,category) return head browser = webdriver.PhantomJS(executable_path =&quot;phantomjs.exe&quot;) blog = Blog(browser,5) blog.saveBlog() 附上，我将博客上所有文章保存下来的截图，幸福感满满~，待会可以使用hexo提交到hust201010701.github.io上： 源码地址：WpBlogToMarkdownFile.git 5. 为什么Python这么强大？从上面的完整代码就可以看出，python代码使用了77行，实现了整个需求，真的是：人生苦短，我用python. Pyhton的强大的内置库和第三方库，让轮子不再重复制造，完成一个网页源码的数据获取只需要两三行代码，请问除了python还有谁？ 学习代码这么长时间，之间一直使用C++,java,android,C#，没有哪种语言能够真真切切地解决生活中的麻烦事，直到遇到了python，庆幸~","categories":[{"name":"Python","slug":"Python","permalink":"http://www.orzangleli.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.orzangleli.com/tags/Python/"}]},{"title":"Windows 平台下的整站抓取工具  WinHTTrack Website Copier 使用","slug":"Windows 平台下的整站抓取工具  WinHTTrack Website Copier 使用","date":"2016-10-29T16:00:00.000Z","updated":"2016-11-03T11:19:55.162Z","comments":true,"path":"2016/10/30/Windows 平台下的整站抓取工具  WinHTTrack Website Copier 使用/","link":"","permalink":"http://www.orzangleli.com/2016/10/30/Windows 平台下的整站抓取工具  WinHTTrack Website Copier 使用/","excerpt":"","content":"昨天晚上本来想看android文档，使用之前好久没用的Lantern，发现已经不能打开墙外网站了，于是就想着android官方文档很重要，而且可能随时会看，就想着自己做一个镜像网站。 本来想的是使用Python爬虫，将developer.android.com上的所有guide网站目录下的网站爬取下来，然后在解析html内容，将所有的链接地址指向本地的相对地址，然后再下载html中的图片，flash,js,css等文件。 但是当我爬取下来一个首页的html之后，发现图片可能还比较好分辨，css感觉规则很不明显，会有这种css格式出现： &lt;link rel=”stylesheet”href=”//fonts.googleapis.com/css?family=Roboto+Condensed”&gt; 一时间，感觉做一个python版的整站爬取工作，需要处理的细节还是很多，而我明天可能要回无锡，所以时间并不多，就在搜索引擎上找到一款软件：WinHTTracker. 下载地址：http://www.httrack.com/page/2/ 网站做的挺简陋的。。。 下载下来安装即可，进入软件可以设置语言，我选择的简体中文。 首先需要设置工程名字，比如我的：AndroidOfficalDocument,下面的那个叫做工程目录可以不填，总文件保存位置选择一个空间较大的目录(因为不知道待爬取的网站的源码有多少空间，所以大点总比小的好)。 然后就是等待镜像过程了~","categories":[{"name":"未分类","slug":"未分类","permalink":"http://www.orzangleli.com/categories/未分类/"}],"tags":[]},{"title":"Python3 实现淘女郎照片爬虫 （完整版教程）","slug":"Python3 实现淘女郎照片爬虫 （完整版教程）","date":"2016-10-27T16:00:00.000Z","updated":"2016-11-03T11:19:54.879Z","comments":true,"path":"2016/10/28/Python3 实现淘女郎照片爬虫 （完整版教程）/","link":"","permalink":"http://www.orzangleli.com/2016/10/28/Python3 实现淘女郎照片爬虫 （完整版教程）/","excerpt":"","content":"Python3 实现淘女郎照片爬虫 （完整版教程） 一. 项目介绍本项目通过Python 3实现一个爬取淘女郎网页上的美女的头像和详细介绍帖子中的所有图片并下载到本地来。 Todo:1. 将图片自动上传到七牛等云存储空间中2. 将图片的信息添加到在线数据库中 二. 知识点 使用Python 3编程 使用BeautifulSoup解析html网页 使用Selenium抓取动态网页 下载文件的几种方式 正则表达式的使用 三. 项目效果这是我们要爬取的目标页面： 淘女郎：https://mm.taobao.com/search_tstar_model.htm 目标页面 爬取后的本地目录每个目录中的图片 四. 项目实战4.1 安装需要使用的库以下是本项目需要使用到的库文件： from bs4 import BeautifulSoup import urllib from selenium import webdriver import time import os import re import requests 需要安装的几个库是bs4，selenium,requests.安装方式是使用pip，分别运行下面的命令： pip install BeautifulSoup4 pip install selenium pip install requests pip install html5lib Selenium是一个强大的网络数据采集工具，最初是为网站自动化测试而开发的。近几年，他还被广泛用于获取精确的网站快照，因为他们可以直接运行在浏览器上。Selenium可以让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作上是否发生。 Selenium 自己不带浏览器，它需要与第三方浏览器结合在一起使用。我们使用的是PhantomJS浏览器，这是一个无头的浏览器，PhantomJS会把网站加载到内存并执行页面上的 JavaScript，但是不会向用户展示网页的图形化界面，可以用来处理 cookie、JavaScript 及header 信息，以及任何你需要浏览器协助完成的事情。 可以去链接下载，也可以自行搜索下载： 链接：http://pan.baidu.com/s/1eSLrpzs 密码：vsq9 4.2 项目目标 抓取淘女郎页面中美女的封面，昵称和城市 抓取个人主页中图片 将每个美女的图片以文件夹的形式存储在文件夹中 4.3 可行性分析淘女郎首页上的源码信息是公开的，本次实验仅仅是用来技术实践，并不带盈利性目的，也不将图片用于其他商业环境，并不会产生商业上的产权纠纷，所以这个项目是可行的。 4.4 流程说明通过 Selenium Webdriver 获得目标页面源码，之后通过 BeautifulSoup解析概源码，通过正则表达式提取出模特名字、所在城市、身高、体重，个人主页、封面图片地址等信息，根据模特名字和城市建立文件夹。 再次通过 Selenium Webdriver 获得模特个人主页的页面源码，之后通过 BeautifulSoup解析源码，通过正则获得页面艺术照的URL地址信息。 最后通过 urllib 内置库，打开图片地址，通过二进制读写的方式获得模特艺术照，并将艺术照存在相应文件夹里面。 4.5 网页源码分析 图中的1,2,3,4分别代表该MM的个人介绍主页地址，封面图片地址，名字和城市，身高体重。第四个我们不使用，只需要获取前三个信息即可。进入个人主页，我们继续类似前面的审查元素，可以看到 &lt;img style=&quot;width: 630.0px;float: none;margin: 10.0px;height: 945.0px;&quot; width=&quot;630&quot; height=&quot;945&quot; src=&quot;//img.alicdn.com/imgextra/i2/927018118/TB1vpJVNVXXXXXzaXXXXXXXXXXX_!!0-tstar.jpg&quot;&gt; 里面的图片的标签都是img，而且图片的网址前面是一样的，因此可以使用正则表达式来匹配图片地址： ^\\/\\/img\\.alicdn\\.com\\/imgextra\\/.*\\.jpg$ 这样可以过滤掉其他图片。 4.6 程序实战首先导入要使用的库 from bs4 import BeautifulSoup import urllib from selenium import webdriver import time import os import re import requests 建一个类，叫做Taonvlang,里面有几个函数： get_detail_imgs(self,detail_url,dir_name): 根据detail_url获取个人主页图片，并存到目录dir_name中 get_all_data(self): 获取主页的所有的美女封面和个人主页 init(self,driver,homePage,outputDir): 初始化函数，初始化类中变量 具体查看代码 from bs4 import BeautifulSoup import urllib from selenium import webdriver import time import os import re import requests class Taolvlang(object): def __init__(self,driver,homePage,outputDir): self.driver = driver self.homePage = homePage self.outputDir = outputDir def get_detail_imgs(self,detail_url,dir_name): num = 0 #计数器，用于统计页面上的图片，作为图片名字 self.driver.get(detail_url) #访问个人主页 js=&quot;var q=document.documentElement.scrollTop=10000&quot; self.driver.execute_script(js) #执行JS脚本，这个脚本主要是滚动页面到最下面， #因为有些网页是动态加载的，用户滑动到哪里加载到哪里 bs = BeautifulSoup(driver.page_source,&quot;html5lib&quot;) #使用BeautifulSoup解析网页源码，使用的是html5lib,如果不安装这个库，会报错 allImage = bs.findAll(&quot;img&quot;,{&quot;src&quot;:re.compile(&quot;^\\/\\/img\\.alicdn\\.com\\/imgextra\\/.*.jpg$&quot;)}) #使用正则表达式匹配所有图片 for image in allImage: img_url = image[&quot;src&quot;] #获取图片的src if not img_url.startswith(&quot;http:&quot;): img_url = &quot;http:&quot;+img_url #给图片地址加上http： num = num +1 #计数器+1 r = requests.get(img_url) #使用requests获取图片 if not os.path.exists(&quot;%s/%d.jpg&quot;%(dir_name,num)): #判断是否已经存在这个文件了 with open(&quot;%s/%d.jpg&quot;%(dir_name,num),&quot;wb&quot;) as pic: pic.write(r.content) #不存在的话就保存到文件中 def get_all_data(self): self.driver.get(homePage) #访问主页 js=&quot;var q=document.documentElement.scrollTop=10000&quot; self.driver.execute_script(js) time.sleep(3) #等待网页加载完成 self.driver.get_screenshot_as_file(&quot;1.jpg&quot;) #保存网页截图 bs = BeautifulSoup(self.driver.page_source,&quot;html5lib&quot;) #使用BeautifulSoup解析网页源码，使用的是html5lib,如果不安装这个库，会报错 allItem = bs.findAll(class_=&quot;item&quot;) #找到所有的项，是class 为item的 for item in allItem: detail_url = item.find(class_=&quot;item-link&quot;)[&quot;href&quot;] #获取个人主页连接 header_img_url = item.find(&quot;img&quot;)[&quot;src&quot;] #获取封面图片链接 dir_name = outputDir+&quot;%s_%s&quot;%(item.find(class_=&quot;name&quot;).get_text(),item.find(class_=&quot;city&quot;).get_text()) #获取名字和城市名组成文件夹名字 if not os.path.exists(dir_name): #如果文件夹不存在新建 os.makedirs(dir_name) if not detail_url.startswith(&quot;http:&quot;): detail_url = &quot;http:&quot;+detail_url if not header_img_url.startswith(&quot;http:&quot;): header_img_url = &quot;http:&quot;+header_img_url print(&quot;detail_url=%s&quot;%detail_url) print(&quot;header_img_url=%s&quot;%header_img_url) #将头像存入目录 if not os.path.exists(outputDir+&quot;%s/0.jpg&quot;%dir_name): urllib.request.urlretrieve(header_img_url,outputDir+&quot;%s/0.jpg&quot;%dir_name) #获取详细帖子中的照片 self.get_detail_imgs(detail_url,dir_name) #本地浏览器路径 browserPath = &quot;phantomjs.exe&quot; #主页路径 homePage = &apos;https://mm.taobao.com/search_tstar_model.htm?&apos; #输出目录 outputDir = &quot;/photos/&quot; driver = webdriver.PhantomJS(executable_path = browserPath) #实例化类，执行获取数据 taoObj = Taolvlang(driver,homePage,outputDir) taoObj.get_all_data() 五.项目地址https://github.com/hust201010701/TaonvlangCrawler 欢迎大家Star.","categories":[{"name":"未分类","slug":"未分类","permalink":"http://www.orzangleli.com/categories/未分类/"}],"tags":[]},{"title":"Python 3.5的环境下使用opencv 3.1版本","slug":"Python 3.5的环境下使用opencv 3.1版本","date":"2016-10-20T16:00:00.000Z","updated":"2016-11-03T11:19:54.781Z","comments":true,"path":"2016/10/21/Python 3.5的环境下使用opencv 3.1版本/","link":"","permalink":"http://www.orzangleli.com/2016/10/21/Python 3.5的环境下使用opencv 3.1版本/","excerpt":"","content":"本来照着这个教程学习OpenCV，说3.5版本不能使用opencv,需要转换版本，可以是用的是linux命令，我也看不懂。上网搜了下，可以在3.5中使用opencv的，安装方法就是下载opencvforpython.然后新建一个py脚本进行测试，脚本内容为： import cv2 import numpy as np image = cv2.imread(&quot;1.jpg&quot;) cv2.imshow(&quot;Image&quot;,image) cv2.waitKey(0) 需要提前安装numpy，使用 pip install numpy . 当然会提示这样的错误： Traceback (most recent call last): File &quot;test.py&quot;, line 1, in &lt;module&gt; import cv2 ImportError: DLL load failed: 找不到指定的模块。 这时候，安装一个vs的C++库就行了，下载地址： https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=48145 安装完成后，就发现可以正常显示图片了~~~","categories":[{"name":"Python","slug":"Python","permalink":"http://www.orzangleli.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.orzangleli.com/tags/Python/"}]},{"title":"LeapMotion 在Unity中的手势识别","slug":"LeapMotion 在Unity中的手势识别","date":"2016-10-11T16:00:00.000Z","updated":"2016-11-03T11:19:54.356Z","comments":true,"path":"2016/10/12/LeapMotion 在Unity中的手势识别/","link":"","permalink":"http://www.orzangleli.com/2016/10/12/LeapMotion 在Unity中的手势识别/","excerpt":"","content":"今天终于把LeapMotion的手势（特指静态手势）识别搞懂了，现在以下记录。 首先识别的脚本是绑定在物理手臂上。对手势的识别是通过对手势的分析做出来的。如果你的手势是比较复杂的手势，例如下图： 这个手势几个特点： 大拇指和食指需要伸出； 大拇指指向正上方； 食指指向左边。 而且这三个条件之间的关系是And，所以需要添加一个逻辑控制模块DetectorLogicGate，这个模块可以将多个条件进行与或运算，而且可以对输出进行取非运算。 下面详细介绍: 1.代表如果混合逻辑满足条件时的动作。 2.代表如果混合逻辑不满足条件时的动作。 3.代表检测器，可以理解为条件，这里就代表上面描述的三个条件。注意到修改size时，Element的元素是不需要自己填写的，应该是系统自动添的，需要注意的是，如果是复杂逻辑的自条件的顺序要紧连。 4.选择运算符，是与还是或。 5.对结果取非运算。 子条件可以有以下几种组合而成:ExtendedFingerDetector : 伸出手指检测，可以指定伸出哪些手指 FingerDirectionDetector ： 手指方向检测，一次只能指定一个方向，如果想指定多个手指的方向，需要添加多个脚本 PalmDirectionDetector ： 手掌方向监测，是从掌心发出的法线方向 还有两个脚本，PinchDetector和ProximityDetector ，因为暂时还不清楚它们的用途，所以暂不介绍。 可以从图片中看到，大拇指和食指我指定为Extended,代表需要这两根手指伸出，而OnActivate和OnDeactivate()保持为空，这是因为我现在使用的这个ExtendedFingerDetector是作为复杂运算的子运算，所以里面不需要写输出。另一方面，如果只想单独地判断是否有手指伸出的话，可以直接在里面定义输出。","categories":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/categories/unity3D/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"}]},{"title":"Android中上拉、下拉刷新的解决方案总结","slug":"Android中上拉、下拉刷新的解决方案总结","date":"2016-10-08T16:00:00.000Z","updated":"2016-11-03T11:19:53.924Z","comments":true,"path":"2016/10/09/Android中上拉、下拉刷新的解决方案总结/","link":"","permalink":"http://www.orzangleli.com/2016/10/09/Android中上拉、下拉刷新的解决方案总结/","excerpt":"","content":"Android中上拉、下拉刷新的解决方案总结 序：android中上拉、下拉刷新在日常的交互中最为常见，而android系统并没有提供完善的解决方案，本文通过总结几种常见的刷新解决方案的优缺点，供各位读者方便选取适合自己的方案。本文的内容控件以RecyclerView为例。 常见的方案主要有以下几种： 1. SwipeRefreshLayout 解决方案 根据需求不同可以分为两类 只需要显示刷新的进度动画 需要在底部显示加载更多 2. 第三方自定义控件 解决方案 SwipyRefreshLayout PullToRefresh BGARefreshLayout-Android 咱们按照顺序依次剖析 1. SwipeRefreshLayout 解决方案SwipeRefreshLayout是android官方出的下拉组件，但是只拥有监听下拉刷新的功能，并没有开放上拉刷新的功能，所以这部分我们需要自定义。 以下主要说上拉功能，分为根据需求分为两种： 只需要显示刷新的进度动画 需要在底部显示加载更多 1. 只需要显示刷新的进度动画监听上拉动作的原理是对RecyclerView设置滑动监听器OnScrollListener，如果当前滑动状态为RecyclerView.SCROLL_STATE_IDLE而且当前最后一个可见项的位置正好是列表中最后一项，代码如下： recyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; lastVisibleItem + 1 == adapter.getItemCount()) { swipeRefreshLayout.setRefreshing(true); //在这里添加请求数据代码，请求完成后 swipeRefreshLayout.setRefreshing(false); } } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); lastVisibleItem = linearLayoutManager.findLastVisibleItemPosition(); } }); 显示效果为，上拉时也显示刷新提示，和下拉的那个没有区别，只是提示刷新，所以用户体验略差点，但是使用方法简单。 2. 需要在底部显示加载更多如果需要给RecyclerView添加刷新提示，比如HeaderView和FooterView 。 先上代码， public class RecyclerViewAdapter extends RecyclerView.Adapter { private ArrayList&lt;String&gt; mList; int load_more_status ; public static final int PULLUP_LOAD_MORE = 0; public static final int LOADING_MORE = 1; public static final int NO_MORE = 2; RecyclerViewAdapter(Context context) { mList = MainActivity.list; } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == 0) { View view = LayoutInflater.from(parent.getContext()).inflate( R.layout.layout_item, null); return new ItemViewHolder(view); } // type == TYPE_FOOTER 返回footerView else if (viewType == 1) { View view = LayoutInflater.from(parent.getContext()).inflate( R.layout.layout_footerview, null); return new FooterViewHolder(view); } return null; } public void changeFooterViewState(int status) { load_more_status = status; notifyDataSetChanged(); } public void addMoreItem(List&lt;String&gt; newDatas) { mList.addAll(newDatas); notifyDataSetChanged(); } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { if(holder instanceof ItemViewHolder) ((ItemViewHolder) holder).textView.setText(position+&quot;位置&quot;); else { FooterViewHolder footViewHolder = (FooterViewHolder)holder; switch (load_more_status){ case PULLUP_LOAD_MORE: footViewHolder.foot_view_item_tv.setText(&quot;上拉加载更多...&quot;); break; case LOADING_MORE: footViewHolder.foot_view_item_tv.setText(&quot;正在加载更多数据...&quot;); break; case NO_MORE: footViewHolder.foot_view_item_tv.setText(&quot;没有更多数据&quot;); break; } } } @Override public int getItemCount() { return mList.size()+1; } public class ItemViewHolder extends RecyclerView.ViewHolder { public ItemViewHolder(View itemView) { super(itemView); textView = (TextView)itemView.findViewById(R.id.textView); } public TextView textView; } class FooterViewHolder extends RecyclerView.ViewHolder { public FooterViewHolder(View view) { super(view); foot_view_item_tv = (TextView) view.findViewById(R.id.textView); } TextView foot_view_item_tv; } @Override public int getItemViewType(int position) { if (position + 1 == getItemCount() ) return 1; else return 0; } } 注意看下就发现有几个地方与普通的不一样： getItemCount 的返回值是 mList.size()+1; 因为当滑动到最后一项时，最后一项需要添加一个提示：“继续滑动加载更多” 添加两个ViewHolder，分别为普通的item和footer的ViewHolder,在onCreateViewHolder中为不同的item绑定不同的布局。 在getItemViewType中建两个ViewType，分别代表普通item和FooterView。 在onBindViewHolder中对FooterView项进行处理，判断当前状态，显示不同的文字。 实际上的原理是这样的，其实列表中会一直比数据的List多一项，这一项在列表最后，每次滑动到最后时，就可以看到这个项，而加载不仅是当前最后一项可见而且需要停止滑动，所以滑动到最后一项并松手可以就刷新了，刷新时通过以下代码调用： recyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; lastVisibleItem + 1 == adapter.getItemCount()) { adapter.changeFooterViewState(RecyclerViewAdapter.LOADING_MORE); // 此处在现实项目中，请换成网络请求数据代码，sendRequest ..... new Handler().postDelayed(new Runnable() { @Override public void run() { List&lt;String&gt; newDatas = new ArrayList&lt;String&gt;(); for (int i = 0; i&lt; 5; i++) { int index = i +1; newDatas.add(&quot;more item&quot; + index); } adapter.addMoreItem(newDatas); adapter.changeFooterViewState(RecyclerViewAdapter.PULLUP_LOAD_MORE); } }, 2500); } } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); lastVisibleItem = linearLayoutManager.findLastVisibleItemPosition(); } }); 效果如图，类似地可以做HeaderView。代码上略微复杂，但是交互效果好，而且目前市面上的大部分啊拍拍也是如此做的。 未完待续。。。","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"android  关于图片加载速度优化方案","slug":"android  关于图片加载速度优化方案","date":"2016-09-19T16:00:00.000Z","updated":"2016-11-03T11:19:53.863Z","comments":true,"path":"2016/09/20/android  关于图片加载速度优化方案/","link":"","permalink":"http://www.orzangleli.com/2016/09/20/android  关于图片加载速度优化方案/","excerpt":"","content":"今天下载了58同城旗下的转转app,发现那里的图片加载速度真的是太快了，快的我基本没有感觉到这是网络上下载的，第一次见到这么快的加载速度，让我惊讶，问了下转转的负责人，他跟我说了几个关键词，这里我记录下，以后方便自己实现体验： 1.webp 合适的尺寸 2.腾讯云cdn 3.fresco框架 4.还有后端的服务 后端我接触不了，我就下次根据前三点做个测试，记录出详细的测试数据。","categories":[{"name":"未分类","slug":"未分类","permalink":"http://www.orzangleli.com/categories/未分类/"}],"tags":[]},{"title":"对java集合类的理解","slug":"对java集合类的理解","date":"2016-09-13T16:00:00.000Z","updated":"2016-11-03T11:19:53.663Z","comments":true,"path":"2016/09/14/对java集合类的理解/","link":"","permalink":"http://www.orzangleli.com/2016/09/14/对java集合类的理解/","excerpt":"","content":"对java集合类的理解 1. ArrayList扩容策略这段时间，找工作，一方面是辛苦，另一方面也是收获，知道自己的哪些不足或者哪些技术没有完全弄清楚，是一个不错的检测自己的方式。 -面试官问道：说下ArrayList和LinkedList的区别？ 首先这道题的答案我当时是知道的，我开始说ArrayList是动态数组，LinkedList是链表，然后面试官打断我： ArrayList是怎么实现动态数组的？ &gt; 当时就有点懵，实在想不起来了，我就按照我的想法说： 里面用一个数组存数据，当新加的数据超出数组长度的时候，就新建一个数组长度多1的数组，然后把之前的数组复制过去，在添加新的数组。 &gt; 面试官又说 那我有需要添加一个数据呢？继续增加1个长度在复制？ &gt; 面试过后，我就查阅ArrayList的源代码（jdk 1.8.0_101）： @Override public boolean add(E object) { Object[] a = array; int s = size; if (s == a.length) { Object[] newArray = new Object[s + (s &lt; (MIN_CAPACITY_INCREMENT / 2) ? MIN_CAPACITY_INCREMENT : s &gt;&gt; 1)]; System.arraycopy(a, 0, newArray, 0, s); array = a = newArray; } a[s] = object; size = s + 1; modCount++; return true; } 具体解释下这段代码，在添加新元素时，首先判断当前容量是否超过MIN_CAPACITY_INCREMENT / 2 =6，如果不超过6就直接把长度变为s+12,否则当容量大于6时，扩容为之前容量的1.5倍。再使用System.arraycopy复制数组，添加新元素。 而在jdk1.7版本，扩容策略上略有不同： private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 扩容策略为新的数组长度是之前的1.5倍，然后再进行判断，如果当前新长度小于当前最小容量，数组长度就等于最小容量，如果新的长度长度大于最大长度，就返回hugeCapacity(minCapacity)。 2. ArrayList和Vector区别ArrayList和Vector都是动态数组，不过二者的主要区别是Vector内部大部分方法使用syncchronized关键字同步，所以是线程安全的，而ArrayList则不是线程安全的。 所以在单线程或者多线程但是不会同时访问同一个对象时可以使用ArrayList,速度快；多线程操作同一个对象的情况下使用Vector因为安全。 另外，ArrayList和Vector在扩容策略上也有一点区别： ArrayList的策略上一段文字已经说明，基本可以概述为容量满时扩容为原来的1.5倍； 而Vector则是在容量满时扩容为原来的2倍。 &gt; 注：CopyOnWriteArrayList是线程安全的ArrayList,一般来说可以替代Vector使用 3.ArrayList和LinkedList的区别ArrayList是线性表结构，而LinkedList是链表结构。ArrayList内部由数组实现，数组可以由下标快速寻址，所以ArrayList的get和set速度很快。LinkedList内部使用Node类包含上一个节点，下一个节点的指针和当前节点的值，所以对于LinkedList使用add和remove速度很快，而get和set则需要一个遍历来寻址节点。 LinkedList还可以实现队列，双向队列，栈等数据结构。","categories":[{"name":"面试","slug":"面试","permalink":"http://www.orzangleli.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.orzangleli.com/tags/面试/"}]},{"title":"Android 自定义弹幕 View","slug":"Android 自定义弹幕 View","date":"2016-09-04T16:00:00.000Z","updated":"2016-11-03T11:19:53.042Z","comments":true,"path":"2016/09/05/Android 自定义弹幕 View/","link":"","permalink":"http://www.orzangleli.com/2016/09/05/Android 自定义弹幕 View/","excerpt":"","content":"Android 自定义弹幕 View 高度自定义##1.自定义弹幕的Model层 本着MVC的框架，弹幕分为弹幕的Model层和View层，Activity中负责Controller层连接二者。 自定义一个DanmuText类 private String content ; private int textSize ; private int textColor; private int x; private int y; private double xRate; private double yRate; private Paint paint; private boolean isShow ; private int speed ; private int width; private int height; private int orientation; //方向，0代表水平，1代表竖直 private int antiDirection; //是否反方向运动，0代表否，1代表是 分别定义以上弹幕属性，然后添加get，set方法。 并添加默认构造方法： DanmuText() { paint = new Paint(); paint.setColor(Color.BLUE); paint.setTextSize(80); width = 0; speed = 1; xRate = yRate = Math.random(); orientation = 0; antiDirection = 0; new Thread(new DanmuRollRunnable()).start(); } 在构造方法中启动一个线程，以对弹幕进行滚动处理。 public class DanmuRollRunnable implements Runnable { @Override public void run() { while (true) { if(orientation == 0) x += speed; else y += speed; try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } } } DanmuRollRunnable 中是一个死循环，每隔10ms判断一次，orientation 代表弹幕的滚动方向是水平的还是竖直的，0代表水平，1代表竖直。 ##2.自定义弹幕View层 自定义一个DanmuView类，DanmuView是继承自View，其中主要的变量是 private String mOrientation = &quot;horizontal&quot;; private boolean mAntidirection = false; private int width; private int height; ArrayList&lt;DanmuText&gt; list; mOrientation 和 mAntidirection 用来保存从XML文件中获取的弹幕的排列方向和运动方向。width和height用于保存DanmuView的宽和高。list用于动态存储弹幕DanmuText类。 重点： 在onDraw中对list中所有弹幕进行判断处理。 @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); for (int i = 0; i &lt; list.size(); i++) { if(list.get(i).getAntiDirection() == 0) { //竖直方向运动 if (list.get(i).getOrientation() == 1) { if (list.get(i).getY() &lt; height + list.get(i).getHeight()) { canvas.drawText(list.get(i).getContent(), (int) (list.get(i).getxRate() * width), height - list.get(i).getY(), list.get(i).getPaint()); postInvalidate(); } else { list.get(i).setShow(false); removeDanmu(i); postInvalidate(); } } else { if (list.get(i).getX() &lt; width + list.get(i).getWidth()) { canvas.drawText(list.get(i).getContent(), width - list.get(i).getX(), (int) (list.get(i).getyRate() * height), list.get(i).getPaint()); postInvalidate(); } else { list.get(i).setShow(false); removeDanmu(i); postInvalidate(); } } } else { //竖直方向运动 if (list.get(i).getOrientation() == 1) { if (list.get(i).getY() &lt; height) { canvas.drawText(list.get(i).getContent(), (int) (list.get(i).getxRate() * width), list.get(i).getY() - list.get(i).getHeight(), list.get(i).getPaint()); postInvalidate(); } else { list.get(i).setShow(false); removeDanmu(i); postInvalidate(); } } else { if (list.get(i).getX() &lt; width) { canvas.drawText(list.get(i).getContent(), list.get(i).getX() - list.get(i).getWidth(), (int) (list.get(i).getyRate() * height), list.get(i).getPaint()); postInvalidate(); } else { list.get(i).setShow(false); removeDanmu(i); postInvalidate(); } } } } } 同时增加添加弹幕和移除弹幕的方法： public void addDanmu(DanmuText text) { if (mOrientation.equals(&quot;vertical&quot;)) text.setOrientation(1); else text.setOrientation(0); if (mAntidirection) text.setAntiDirection(1); else text.setAntiDirection(0); list.add(text); } public void removeDanmu(int i) { list.remove(i); } 3.在Activity中对弹幕进行调用 package com.orzangleli.danmu; import android.graphics.Color; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.widget.Button; import android.widget.EditText; import java.util.Random; public class MainActivity extends AppCompatActivity { String danmu[] = new String[]{&quot;这是一个Danmu Demo&quot;,&quot;它可以自定义Danmu的速度&quot;,&quot;方向&quot;,&quot;还有颜色&quot;,&quot;文本大小&quot;,&quot;还有滑动方向&quot;}; DanmuView danmuView; EditText message; Button send; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); toolbar.setOnMenuItemClickListener(onMenuItemClick); danmuView = (DanmuView) this.findViewById(R.id.danmuView); message = (EditText) this.findViewById(R.id.message); send = (Button) this.findViewById(R.id.send); send.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if(!message.getText().toString().trim().equals(&quot;&quot;)) { DanmuText danmuText = new DanmuText(); danmuText.setContent(message.getText().toString().trim()); Random random =new Random(); danmuText.setTextColor(Color.rgb(random.nextInt(255), random.nextInt(255), random.nextInt(255))); danmuView.addDanmu(danmuText); message.setText(&quot;&quot;); } } }); for(int i=0;i&lt;danmu.length;i++) { DanmuText danmuText = new DanmuText(); danmuText.setContent(danmu[i]); Random random =new Random(); danmuText.setTextColor(Color.rgb(random.nextInt(255), random.nextInt(255), random.nextInt(255))); danmuView.addDanmu(danmuText); } } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main_menu, menu); return true; } private Toolbar.OnMenuItemClickListener onMenuItemClick = new Toolbar.OnMenuItemClickListener() { @Override public boolean onMenuItemClick(MenuItem menuItem) { switch (menuItem.getItemId()) { case R.id.action_vertical: danmuView.setOrientation(&quot;vertical&quot;); break; case R.id.action_horizontal: danmuView.setOrientation(&quot;horizontal&quot;); break; case R.id.action_normaldirection: danmuView.setmAntidirection(false); break; case R.id.action_antinormaldirention: danmuView.setmAntidirection(true); break; } return true; } }; } 添加一个效果图： 项目托管地址： GitHub 仓库挂件 WordPress 插件 hust201010701 /Danmu 自定义弹幕视图，可以实现水平/竖直方向，正向/反向弹幕，可以自定义颜色、文字大小等 http://www.orzangleli.com 21 Download ZIP","categories":[{"name":"未分类","slug":"未分类","permalink":"http://www.orzangleli.com/categories/未分类/"}],"tags":[]},{"title":"Android Service 持久运行不被杀死方法总结","slug":"Android Service 持久运行不被杀死方法总结","date":"2016-08-21T16:00:00.000Z","updated":"2016-11-03T11:19:54.102Z","comments":true,"path":"2016/08/22/Android Service 持久运行不被杀死方法总结/","link":"","permalink":"http://www.orzangleli.com/2016/08/22/Android Service 持久运行不被杀死方法总结/","excerpt":"","content":"序：好久没有写文字了，并不代表我不在学习，只是学习的过程有些漫长，加上总结需要时间。 Android Service 持久运行不被杀死方法总结&gt;简介：Android应用开发中，我们经常会遇到各种各样的场景需要保持Service不被杀死的需求。最常见的即时通讯类软件，由于实时性需求，需要保持消息服务类的运行状态。这里我总结了当下几种常见的解决方法及其利弊。首先申明：迄今为止我没有发现能够通过常规方法达到流氓需求(通过长按home键清除都清除不掉)的方法，目前所有方法都是指通过Android的内存回收机制和普通的第三方内存清除等手段后仍然保持运行的方法。 方法1：申明Service为前台服务和提高Service的优先级这里说到了两个小分类，申明Service为前台服务和提高Service的优先级，实际上申明Service为前台服务也是提高服务的优先级，因为Android系统中默认的内存回收顺序(越往下越先回收)是： ( 引用自：http://blog.csdn.net/mad1989/article/details/22492519) &gt; 前台进程( FOREGROUND_APP) 可视进程(VISIBLE_APP ) 次要服务进程(SECONDARY_SERVER ) 后台进程 (HIDDEN_APP) 内容供应节点(CONTENT_PROVIDER) 空进程(EMPTY_APP) &gt; 具体方法是在Service的onStartCommand方法中初始化Notification对象并将其绑定在服务上成为前台(Foreground)服务。具体代码： @Override public int onStartCommand(Intent intent, int flags, int startId) { //使用Notification.Builder构造Notification Notification.Builder builder = new Notification.Builder(this.getApplicationContext()); builder.setContentInfo(&quot;补充内容&quot;); builder.setContentText(&quot;主内容区&quot;); builder.setContentTitle(&quot;通知标题&quot;); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setTicker(&quot;新消息&quot;); builder.setAutoCancel(true); builder.setWhen(System.currentTimeMillis()); Intent intent2 = new Intent(this.getApplicationContext(), MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this.getApplicationContext(), 0, intent2, PendingIntent.FLAG_CANCEL_CURRENT); builder.setContentIntent(pendingIntent); Notification notification = builder.build(); //设置为前台服务，必须绑定一个notification对象，实际上也就是说如果你想做持久化的Service就得让用户知道，PID是自定义的整数表明notification的ID startForeground(PID, notification); return START_STICKY; } 代码中提到：设置为前台服务，必须绑定一个notification对象，实际上也就是说如果你想做持久化的Service就得让用户知道，PID是自定义的整数表明notification的ID，实际上有一种方法可以达到前台服务不显示通知栏的效果。 前台服务不显示通知栏这里用到的黑科技来自博客：http://blog.csdn.net/wxx614817/article/details/50669420。文中所提的方法即为：再新开一个辅助Service，onStartCommand里面同样设置为前台服务，而且startForeground(PID,notification)的PID和第一个Service相同，然后在辅助Service中关闭前台服务，这样第一个Service还在运行，但是第二个服务会让通知栏关闭，这样就实现了所需功能。具体实现方式为： 修改第一个Service里的onStartCommand方法，在后面启动辅助Service. @Override public int onStartCommand(Intent intent, int flags, int startId) { //使用Notification.Builder构造Notification Notification.Builder builder = new Notification.Builder(this.getApplicationContext()); builder.setContentInfo(“补充内容”); builder.setContentText(“主内容区”); builder.setContentTitle(“通知标题”); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setTicker(“新消息”); builder.setAutoCancel(true); builder.setWhen(System.currentTimeMillis()); Intent intent2 = new Intent(this.getApplicationContext(), MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this.getApplicationContext(), 0, intent2, PendingIntent.FLAG_CANCEL_CURRENT); builder.setContentIntent(pendingIntent); Notification notification = builder.build(); //设置为前台服务，必须绑定一个notification对象，实际上也就是说如果你想做持久化的Service就得让用户知道，PID是自定义的整数表明notification的ID startForeground(PID, notification); //启动辅助Service Intent intent3 = new Intent(MyService.this,AssistService.class); MyService.this.startService(intent3); return START_STICKY;} 在辅助Service中开启一个同样ID的notification，并取消。 @Override public int onStartCommand(Intent intent, int flags, int startId) { Notification.Builder builder = new Notification.Builder(this.getApplicationContext()); builder.setContentInfo(&quot;补充内容&quot;); builder.setContentText(&quot;主内容区&quot;); builder.setContentTitle(&quot;通知标题&quot;); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setTicker(&quot;新消息&quot;); builder.setAutoCancel(true); builder.setWhen(System.currentTimeMillis()); Intent intent2 = new Intent(this.getApplicationContext(), MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this.getApplicationContext(), 0, intent2, PendingIntent.FLAG_CANCEL_CURRENT); builder.setContentIntent(pendingIntent); Notification notification = builder.build(); NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); //先显示 startForeground(PID, notification); //再销毁 stopForeground(true); return START_STICKY; } 修改Service优先级比较简单：在AndroidManifest.xml文件中添加intent-fliter,priority值在-1000到1000范围内，数值越高优先级越高。 &lt;service android:name=&quot;.MyService&quot;&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;com.orzangleli.qqservicekeepdemo&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; 测试效果：这种方法经过测试，在手机较高内存使用率时，大概能够运行5分钟左右（测试手机型号：nubia z7 mini ,内存2G）。这实际上也就表明了其缺点，申明为前台服务只能提高优先级，并不能保证在低内存时不被回收。 方法2：通过BroadcastReceiver 重启服务首先解释下BroadcastReceiver的两种注册方式，动态注册和静态注册，两者大多数情况下可以通用，但存在以下l两点区别： 动态注册在程序关闭时，无法接收到广播，因为注册广播是在程序运行时执行的。 静态注册虽然可以在程序未打开时接收到广播，但是有三种广播无法静态注册： android.intent.action.SCREEN_ON android.intent.action.SCREEN_OFF android.intent.action.BATTERY_CHANGED android.intent.action.CONFIGURATION_CHANGED android.intent.action.TIME_TICK 在测试时，我使用android.intent.action.TIME_TICK动态注册广播接受者，在onReceive方法中添加判断目标服务是否在运行的判断，如果不在运行就重新启动。代码如下： public class MyBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { if(intent.getAction().equals(Intent.ACTION_TIME_TICK)) { Log.i(&quot;lxc&quot;,&quot;接收到广播了&quot;); if(!isServiceRunning(context,&quot;com.orzangleli.qqservicekeepdemo.MyService&quot;)) { Intent service = new Intent(context,MyService.class); service .setAction(&quot;com.orzangleli.qqservicekeepdemo&quot;); context.startService(service); } } } public static boolean isServiceRunning(Context context,String serviceClassName){ final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); final List&lt;ActivityManager.RunningServiceInfo&gt; services = activityManager.getRunningServices(Integer.MAX_VALUE); for (ActivityManager.RunningServiceInfo runningServiceInfo : services) { if (runningServiceInfo.service.getClassName().equals(serviceClassName)){ return true; } } return false; } } 测试结果：在程序不退出但是服务停止的情况下，的确可以重启服务，但是重启不是即时的，而是每隔1分钟(在每分钟的第0秒触发)，没有尝试其他的静态注册方式，因为我没有找到一个静态注册的广播，它的广播频率比这个android.intent.action.TIME_TICK还要高的，如果各位读者有知道的，麻烦告知下。而在程序完全退出时，动态注册的BroadcastReceiver不再接受广播，所以也就不会重启Service. 方法3.双进程守护双进程守护是指开启两个进程，这两个进程相互独立但是又相互守护，如果其中一个进程被杀死，另一个进程则重启该进程，因为一般情况下不会发生两个进程同时死亡的场景，所以在Service常驻功能上能够满足。 这里插上一句话：在手机的应用程序中可以看到我们手机里大部分常驻内存的Service都是两个或以上的，比如下图中的微信电话本，Hola桌面和QQ(后面解释了QQ不是用的这种方法). 具体操作步骤为： 1. 申明Service的进程，主服务和辅助服务不要同一个进程 &lt;service android:name=&quot;.MyService&quot; android:process=&quot;:myservice&quot; &gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;com.orzangleli.qqservicekeepdemo&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;service android:name=&quot;.AssistService&quot; android:process=&quot;:assistservice&quot; &gt; &lt;/service&gt; 2. 在两个服务中分别启动一个线程检查另一个服务的状态 class MyRunnable implements Runnable { @Override public void run() { while(enable) { Log.i(TAG, &quot; 时间： &quot; + Calendar.getInstance().get(Calendar.SECOND)); keepAssistService(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } private void keepAssistService(){ boolean isRun = isServiceRunning(this, Process_Name); if (isRun == false) { Log.i(TAG,&quot;重新启动 AssistService&quot;); Intent intent = new Intent(this,AssistService.class); intent .setAction(&quot;com.orzangleli.qqservicekeepdemo&quot;); this.startService(intent); } } public static boolean isServiceRunning(Context context,String serviceClassName){ final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); final List&lt;ActivityManager.RunningServiceInfo&gt; services = activityManager.getRunningServices(Integer.MAX_VALUE); for (ActivityManager.RunningServiceInfo runningServiceInfo : services) { if (runningServiceInfo.service.getClassName().equals(serviceClassName)){ return true; } } return false; } 测试结果：经过一个多小时的使用，后台服务仍然在运行状态。比较完美实现了，唯一的确定就是里面有两个线程循环执行，会导致耗电更快。 方法4.QQ的一像素保持前台服务方法先推荐阅读文章： 手机QQ后台为何清不掉？MIUI工程师：全靠1像素的页面保命 文中提到，QQ通过一个像素，在程序退出时，显示这个像素，使得系统认为该服务为前台服务，所以允许常驻内存，这种方法我不很懂。 我在测试的时候，在Service显示一个悬浮窗，用这个悬浮窗代替QQ的一个像素，但是在运行5分钟左右后，悬浮窗消失同时后台服务也停止运行，不是说有可见的UI的后台服务就是为前台服务了么，怎么也会被杀死。而且如果是用这种方法实现的常驻内存，为什么QQ也会使用到双进程呢？(更新：经过测试，QQ的双进程并没有守护关系，关闭掉Downloader的那个进程并不会重新启动)。 现在的问题就是：为什么我在Service中启动的悬浮窗会被杀死呢？本文会持续更新。 方法5：使用一些常见的白名单推送包据说使用常见的白名单推送包在保持进行活跃上也有一定效果，例如Jpush，或者内置的系统账户同步系统等，定时推送消息然后启动服务。此方法暂未测试，不知道效果如何，暂时留白。","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"【源码解析】UIL的图片缓存策略","slug":"【源码解析】UIL的图片缓存策略","date":"2016-08-15T16:00:00.000Z","updated":"2016-11-03T11:19:52.954Z","comments":true,"path":"2016/08/16/【源码解析】UIL的图片缓存策略/","link":"","permalink":"http://www.orzangleli.com/2016/08/16/【源码解析】UIL的图片缓存策略/","excerpt":"","content":"UIL中缓存分为内存缓存（MemoryCache）和磁盘缓存(DiscCache). 内存缓存1.强引用缓存 LRUMemoryCache: 这个类缓存的都是bitmap对象的强引用.强引用只要引用存在，就不会被回收，而且bitmap的数据量很大，很容易导致程序超过最大内存限制，容易发生OOM.LRUMemoryCache就是最近最少使用内存缓存先删除的原理，这样保证程序不会发生OOM. 2.弱引用缓存 WeakMemoryCache: 这个类缓存的都是bitmap的弱引用，对内存的总大小没有限制，但是不稳定，容易被gc回收掉。 3.强引用和弱引用相结合 UsingFreqLimitedMemoryCache: 先删除最少使用的bitmap LRULimitedMemoryCache: 先删除最近最少使用的bitmap FIFOLimitedMemoryCache: 先删除最先加入缓存的bitmap LargestLimitedMemortCache: 先删除最大内存的bitmap LimitedAgeMemoryCache: 先删除比设定值早加入缓存中的bitmap 磁盘缓存 FileCountLimitedDiscCache: 当缓存图片个数超过设定值时，先删除最先加入到磁盘中的文件 TotalSizeLimitedDiscCache: 当缓存图片的总文件大小超过设定值时，先删除最先加入到磁盘中的文件 LimitedAgeDiscCache: 设置图片存活的最长时间，超过这个时间的，就删除该文件 UnlimitedDiscCache: 不限制地在磁盘上缓存","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"面试","slug":"面试","permalink":"http://www.orzangleli.com/tags/面试/"}]},{"title":"HTC VIVE VR关卡场景切换原理","slug":"HTC VIVE VR关卡场景切换原理","date":"2016-08-08T16:00:00.000Z","updated":"2016-11-03T11:19:52.938Z","comments":true,"path":"2016/08/09/HTC VIVE VR关卡场景切换原理/","link":"","permalink":"http://www.orzangleli.com/2016/08/09/HTC VIVE VR关卡场景切换原理/","excerpt":"","content":"在VR中，有时候不止一个场景，我们需要把他单独的场景连接起来，这里我们模仿普遍的网游中“传送门”的原理。 如图所示，在某一处，有一个传送门标志： 然后主角移动到传送门附近时，跳转到下一关。 这里是根据两者之间的距离来判断的，我们要VIVE包中camer(head)来表示主角位置。场景的加载可以通过Application.LoadLevel来切换，在这里之前，我们需要在File-Build中添加需要加载的所有场景，我这里只有两个，系统会自动分配id给它们，如我的两个场景是0和1。 我们新建一个脚本，然后把脚本托给传送门的GameObject.脚本代码为： using UnityEngine; using System.Collections; public class ChangeSence : MonoBehaviour { public GameObject cameraRig; // Use this for initialization void Start () { } // Update is called once per frame void Update () { if (Vector3.Distance (cameraRig.transform.position, this.transform.position) &lt; 2f) { if (MyApplication.level == 0) { Application.LoadLevel (1); MyApplication.level = 1; } else if (MyApplication.level == 1) { Application.LoadLevel (0); MyApplication.level = 0; } } } } 恩，主要就是这样。下一讲，我们来看看VIVE控制器下的武器切换原理。 组件我打包了，可以下载：需要unity 5.3+版本。 链接：http://pan.baidu.com/s/1gfAvRX5 密码：zrk8","categories":[{"name":"HTC VIVE","slug":"HTC-VIVE","permalink":"http://www.orzangleli.com/categories/HTC-VIVE/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"},{"name":"HTC VIVE","slug":"HTC-VIVE","permalink":"http://www.orzangleli.com/tags/HTC-VIVE/"}]},{"title":"Unity3D 虚拟现实FPS游戏","slug":"Unity3D 虚拟现实FPS游戏","date":"2016-08-06T16:00:00.000Z","updated":"2016-11-03T11:19:52.460Z","comments":true,"path":"2016/08/07/Unity3D 虚拟现实FPS游戏/","link":"","permalink":"http://www.orzangleli.com/2016/08/07/Unity3D 虚拟现实FPS游戏/","excerpt":"","content":"Share the video Facebook Twitter Google+ Email Embed Copy and paste this HTML code into your webpage to embed. flowplayer 00:00 __ 00:00 ## Copy and paste this HTML code into your webpage to embed. _space_play / pause _q_unload | stop _f_fullscreen _↑__↓_volume _m_mute _←__→_seek _ . _seek to previous 1__2… 6 seek to 10%, 20% … 60% © 2015 About Flowplayer GPL based license 以下为技术细节记录： 1.自动寻路组件 Navigation首先在Unity3D中打开Window菜单的Navigation,然后依次选择场景中的模型，然后标记为这三种状态： Walkable NotWalkable Jump 分别代表该处地形，可以行走，不可以行走和允许跳跃。 然后在需要自动寻迹的目标上添加 Nav MeshAgent，自动寻迹代理组件。可以设置代理组件的寻迹速度和加速度，然后给目标上添加一个脚本，把它的终点位置设置好。以本游戏为例，就是僵尸自动寻找主角，主角是僵尸的目标，僵尸身上会有NavMesh Agent组件。 本游戏中，将所有建筑设置状态后，烘焙后显示寻迹路线（绿色为可以行走的部门）： 特别需要注意的是，如果寻迹路线中断，僵尸是不能通过的，所以只能通过修改某些碰撞器重新烘焙，就可以生成一条连续的寻迹路线。 在脚本中，使用下面的语句设置寻迹目标： // Update is called once per frame void Update () { if (agent.enabled) { agent.destination = player.transform.position; if (Vector3.Distance (this.transform.position, player.transform.position) &lt; 2.2f) { SwitchAttack (true); agent.Stop (); } else { SwitchAttack (false); agent.Resume (); } } } 基本原理就是，当寻迹组件激活时，如果僵尸和主角距离超过2.2m则自动追踪主角，如果小于2.2m,就切换为攻击模式。 2.射击原理射击就是给子弹一个速度，然后让子弹从发射口发射出去，发射过程中，不断的在子弹的正前方发射射线，射线的长度为0.1m，这样就能检测出射击击中的位置。 具体代码为： using UnityEngine; using System.Collections; public class BulletLife : MonoBehaviour { private Vector3 direction; public GameObject holePrefab,bloodPrefab; private GameObject baozha; RaycastHit hit ; // Use this for initialization void Start () { //手枪的发射方向 direction = -this.transform.right; Destroy (gameObject,5); } // Update is called once per frame void Update () { Physics.Raycast (this.transform.position, direction, out hit, 0.1f); } void OnCollisionEnter(Collision c) { GameObject hole=Instantiate (holePrefab,hit.point,Quaternion.identity) as GameObject; hole.transform.parent = hit.collider.transform; hole.transform.up = hit.normal; baozha = hole.transform.FindChild (&quot;baozha&quot;).gameObject; if (c.collider.tag == &quot;Zombie&quot;) { hole.transform.FindChild (&quot;Canvas&quot;).gameObject.SetActive (false); } Destroy (baozha,1.0f); Destroy (hole,5f); Destroy (gameObject); } } 为什么不使用Collider来检测碰撞呢？ 因为Collider的检测碰撞实际上是通过在间隔时间内检测是否碰撞到，如果才能返回碰撞结果的，如果物体运动速度很快，被撞物体很薄，如子弹射击木板，因为碰撞持续时间很短，很有可能检测不出碰撞来，这样就会出现一种bug：视觉上子弹穿过了僵尸，但是僵尸并没有死亡。 下面附上这一周完成情况的几张截图和视频链接：","categories":[{"name":"未分类","slug":"未分类","permalink":"http://www.orzangleli.com/categories/未分类/"}],"tags":[]},{"title":"CouponView 开源库的发布","slug":"CouponView 开源库的发布","date":"2016-08-01T16:00:00.000Z","updated":"2016-11-03T11:19:52.080Z","comments":true,"path":"2016/08/02/CouponView 开源库的发布/","link":"","permalink":"http://www.orzangleli.com/2016/08/02/CouponView 开源库的发布/","excerpt":"","content":"自己做了一个卡券视图，可以自定义裁边效果. Android CouponView 卡券视图1.效果： CouponView 是一个继承自LinearLayout的布局View,边缘可以实现自动裁剪效果，所以用来做优惠券等视图效果很好。 下图所示的四种视图，分别代表，不裁剪，只裁横向，只裁竖向，横竖皆裁四种情况。 2.使用方法： 在build.gradle中添加一行： compile &apos;com.orzangleli.coupon:coupon:1.0.1&apos; 在布局文件中添加代码： &lt;com.orzangleli.coupon.view.CouponView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#FF9933&quot; coupon:gap=&quot;4dp&quot; coupon:radius=&quot;5dp&quot; coupon:radiusBackgroundColor=&quot;#ffffff&quot; coupon:showHorizontal=&quot;true&quot; coupon:showVertical=&quot;true&quot; android:layout_marginTop=&quot;10dp&quot; &gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:text=&quot;购物优惠券&quot; android:textSize=&quot;20sp&quot; android:textColor=&quot;#FFFFFF&quot; android:layout_marginTop=&quot;5dp&quot; android:layout_marginLeft=&quot;15dp&quot; android:gravity=&quot;center_vertical&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;满50元减10元&quot; android:textSize=&quot;14sp&quot; android:textColor=&quot;#FFFFFF&quot; android:layout_marginTop=&quot;3dp&quot; android:layout_marginLeft=&quot;25dp&quot; android:gravity=&quot;center_vertical&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;使用期限：一周内&quot; android:textSize=&quot;14sp&quot; android:textColor=&quot;#FFFFFF&quot; android:layout_marginTop=&quot;3dp&quot; android:layout_marginLeft=&quot;25dp&quot; android:layout_marginBottom=&quot;15dp&quot; android:gravity=&quot;center_vertical&quot; /&gt; &lt;/com.orzangleli.coupon.view.CouponView&gt; 注意在父节点上添加一行： xmlns:coupon=&quot;http://schemas.android.com/apk/res-auto&quot; 3.属性解释： gap:间隔线长度 radius:圆弧半径 radiusBackgroundColor:圆背景颜色 一般来说需要与主背景颜色相同 showHorizontal:显示横向裁剪 showVertical:显示竖向裁剪 GitHub 仓库挂件 WordPress 插件 hust201010701 /CouponView android 卡券布局 可以自定义横向/竖向的锯齿 https://github.com/hust201010701/CouponView 83 DownloadZIP","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"AppBarLayout 下Toolbar 在RecyclerView下实现滑动隐藏","slug":"AppBarLayout 下Toolbar 在RecyclerView下实现滑动隐藏","date":"2016-07-24T16:00:00.000Z","updated":"2016-11-03T11:19:52.066Z","comments":true,"path":"2016/07/25/AppBarLayout 下Toolbar 在RecyclerView下实现滑动隐藏/","link":"","permalink":"http://www.orzangleli.com/2016/07/25/AppBarLayout 下Toolbar 在RecyclerView下实现滑动隐藏/","excerpt":"","content":"今天介绍的是AppBarLayout 下Toolbar在RecyclerView下实现滑动隐藏,目前网络上也存在一部分Toolbar在RecyclerView下隐藏的博文，但是是没有突出在AppBarLayout的布局下。 首先是main_activity.xml的代码中AppBarLayout部分： &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appBarLayout&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;match_parent&quot; android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot; /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; 滑动隐藏需要重写RecyclerView滑动监听： public abstract class RecyclerViewScrollListener extends RecyclerView.OnScrollListener { private static final int SCROLL_DISTANCE = 50; private int totalScrollDistance; private boolean isShow = true; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { super.onScrollStateChanged(recyclerView, newState); } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); int firstVisableItem = ((StaggeredGridLayoutManager) recyclerView.getLayoutManager()).findFirstCompletelyVisibleItemPositions(null)[0]; //当第一个item存在界面上时就不触发隐藏、显示操作 if(firstVisableItem==0) { return; } if ((dy &gt; 0 &amp;&amp; isShow) || (dy &lt; 0 &amp;&amp; !isShow)) { totalScrollDistance += dy; } if (totalScrollDistance &gt; SCROLL_DISTANCE &amp;&amp; isShow) { hide(); isShow = false; totalScrollDistance = 0; } else if (totalScrollDistance &lt; -SCROLL_DISTANCE &amp;&amp; !isShow) { show(); isShow = true; totalScrollDistance = 0; } } public abstract void hide(); public abstract void show(); } 然后绑定监听器： recyclerView.setOnScrollListener(new RecyclerViewScrollListener() { @Override public void hide() { ViewPropertyAnimator animator = appBarLayout.animate().translationY(-toolbar.getHeight()).setInterpolator(new AccelerateInterpolator(2)); new Handler().postDelayed(new Runnable() { @Override public void run() { appBarLayout.setVisibility(View.GONE); } },animator.getDuration()); } @Override public void show() { appBarLayout.setVisibility(View.VISIBLE); appBarLayout.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)); } }); 重点在这里，使用动画将appBarLayout向上移动，然后在移动结束后，设置隐藏，而显示的时候，直接显示再向下滑动动画。 效果如图： http://i.imgur.com/zUY99su.gif 2016年7月25日更新： 这里提供另一种思路： 之前之所以要在标题栏滑动到上面之后，设置隐藏是因为标题栏只滑到状态栏那里，所以我们可以让他在多滑一点。 ViewPropertyAnimator animator = appBarLayout.animate().translationY(-toolbar.getHeight()-statusBarHeight).setInterpolator(new AccelerateInterpolator(2)); 状态栏的高度获取使用下面的代码： Rect rectangle= new Rect(); Window window= getWindow(); window.getDecorView().getWindowVisibleDisplayFrame(rectangle); int statusBarHeight= rectangle.top;","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"Android 动态设置状态栏颜色","slug":"Android 动态设置状态栏颜色","date":"2016-07-23T16:00:00.000Z","updated":"2016-11-03T11:19:51.758Z","comments":true,"path":"2016/07/24/Android 动态设置状态栏颜色/","link":"","permalink":"http://www.orzangleli.com/2016/07/24/Android 动态设置状态栏颜色/","excerpt":"","content":"Android 动态设置状态栏颜色直接代码： window = this.getWindow(); //取消设置透明状态栏,使 ContentView 内容不再覆盖状态栏 window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); //需要设置这个 flag 才能调用 setStatusBarColor 来设置状态栏颜色 window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); //设置状态栏颜色 window.setStatusBarColor(Color.parseColor(&quot;#3F51B5&quot;));","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"Snackbar 使用详解及源码解析","slug":"Snackbar 使用详解及源码解析","date":"2016-07-13T16:00:00.000Z","updated":"2016-11-03T11:19:51.752Z","comments":true,"path":"2016/07/14/Snackbar 使用详解及源码解析/","link":"","permalink":"http://www.orzangleli.com/2016/07/14/Snackbar 使用详解及源码解析/","excerpt":"","content":"Snackbar 使用详解及源码解析 本文全部内容为orzangleli原创，未经允许禁止转载。 简介：本文将详细介绍Snackbar的使用方法，源码解析以及如何不修改源码的情况下完成Snackbar的顶部显示。 1. 什么是Snackbar?官网上是这么解释Snackbar的功能和特点： Snackbars provide lightweight feedback about an operation. They show a briefmessage at the bottom of the screen on mobile and lower left on largerdevices. Snackbars appear above all other elements on screen and only one canbe displayed at a time. &gt; They automatically disappear after a timeout or after user interactionelsewhere on the screen, particularly after interactions that summon a newsurface or activity. Snackbars can be swiped off screen. &gt; Snackbars can contain an action which is set via setAction(CharSequence,android.view.View.OnClickListener). &gt; To be notified when a snackbar has been shown or dismissed, you can providea Snackbar.Callback via setCallback(Callback). Snackbar是一个轻量级的交互反馈控件，可以在手机的屏幕下方或者更大设备（例如平板）的左下方显示一个简短的信息，Snackbar会显示在所有元素之上，而且只持续一段时间。 它们会在超时或者用户与交互屏幕其他地方交互后自动消失，特别是在和一个新的surface和activity交互之后。Sanckbar可以被滑动移除屏幕。 为了知道何时snackbar已经被显示或者关闭，你可以通过setCallback(Callback)提供一个Snackbar.Callback（反馈）。 一般意义上，Snackbar的效果如图所示（图片摘自博客）。 2. 怎么使用Snackbar1). 常量int LENGTH_INDEFINITE 无限期的显示snackbar (这里只是说不会自动消失，用户仍可通过右滑移除) int LENGTH_LONG 长时间的显示snackbar (类似于Toast) int LENGTH_SHORT 短时间的显示snackbar (类似于Toast) 2). 内部类Snackbar.Callback是Snackbar的内部类，这个类有两个方法需要重写，onDismissed 和 onShown，下面的例子一看就明白： snackbar.setCallback(new Snackbar.Callback() { @Override public void onDismissed(Snackbar snackbar, int event) { super.onDismissed(snackbar, event); Toast.makeText(MainActivity.this,&quot;通过Callback监听到snackbar消失&quot;,Toast.LENGTH_SHORT).show(); } @Override public void onShown(Snackbar snackbar) { super.onShown(snackbar); Toast.makeText(MainActivity.this,&quot;通过Callback监听到snackbar显示&quot;,Toast.LENGTH_SHORT).show(); } }); 3). 公开方法 重点说下几个方法： 1.make(View view, CharSequence text, int duration) 和 make(View view, int resId, int duration) 实际上是两种初始化Snackbar的方法，只不过第二种使用的是text的id而已。 2.setAction(CharSequence text, View.OnClickListener listener)是给Snackbar增加一个动作按钮，按钮的响应用过OnClickListenr重写。最典型的用途是，在用户完成一个操作时，Snackbar提示用户操作成功，按钮显示撤销操作。 3.setActionTextColor(int color) 动作按钮的文本颜色可以设置，默认的颜色是主题的colorAccent颜色。 4）.使用Snackbar使用SnackBar非常简单，代码如下： Snackbar snackbar = Snackbar.make(view, &quot;张三：今天晚上干嘛？&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;关闭&quot;, new View.OnClickListener() { @Override public void onClick(View v) { } }); 4.阅读源码并自定义Snackbar1）. 右滑的说明 补充说明下：Snackbar 只能在CoordinatorLayout布局下才能执行右滑删除，在其他布局下右滑手势无效。这一点可以从下面代码中得到解释。 在使用make方法构造Snackbar时，会调用下面的方法： @NonNull public static Snackbar make(@NonNull View view, @NonNull CharSequence text,@Duration int duration) { Snackbar snackbar = new Snackbar(findSuitableParent(view)); snackbar.setText(text); snackbar.setDuration(duration); return snackbar; } 其中findSuitableParent(view)是一个寻找父布局的方法，它会在寻找到CoordinatorLayout或者id为android.R.id.content的FrameLayout时停止寻找，否则就返回默认的布局。 private static ViewGroup findSuitableParent(View view) { ViewGroup fallback = null; do { if (view instanceof CoordinatorLayout) { // We&apos;ve found a CoordinatorLayout, use it return (ViewGroup) view; } else if (view instanceof FrameLayout) { if (view.getId() == android.R.id.content) { // If we&apos;ve hit the decor content view, then we didn&apos;t find a CoL in the // hierarchy, so use it. return (ViewGroup) view; } else { // It&apos;s not the content view but we&apos;ll use it as our fallback fallback = (ViewGroup) view; } } if (view != null) { // Else, we will loop and crawl up the view hierarchy and try to find a parent final ViewParent parent = view.getParent(); view = parent instanceof View ? (View) parent : null; } } while (view != null); // If we reach here then we didn&apos;t find a CoL or a suitable content view so we&apos;ll fallback return fallback; } 而且监听右滑操作的Behavior是继承自SwipeDismissBehavior，而SwipeDismissBehavior继承自CoordinatorLayout.Behavior，所以只有在CoordinatorLayout布局下的Snackbar才能被监听到右滑事件。 2）.自定义Snackbar看源码后会发现Snackbar预留出的接口方法太少了，不足以满足日常需求，现在我就几个常见的需求做单独说明。 a. Snackbar顶部显示//顶部显示Snackbar button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Snackbar snackbar = Snackbar.make(v, &quot;张三：今天晚上干嘛？&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;关闭&quot;, new View.OnClickListener() { @Override public void onClick(View v) { } }); CoordinatorLayout.LayoutParams ly = new CoordinatorLayout.LayoutParams(FrameLayout.LayoutParams.FILL_PARENT,200); ly .gravity = Gravity.TOP; snackbar.getView().setLayoutParams(ly); snackbar.show(); } }); b.修改Snackbar背景颜色和文字颜色//修改Snackbar背景颜色和文字颜色 button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Snackbar snackbar = Snackbar.make(v, &quot;张三：今天晚上干嘛？&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;关闭&quot;, new View.OnClickListener() { @Override public void onClick(View v) { } }); //设置动作按钮文本颜色 snackbar.setActionTextColor(Color.BLACK); //设置背景颜色 snackbar.getView().setBackgroundColor(Color.WHITE); Snackbar.SnackbarLayout snackbarLayout = (Snackbar.SnackbarLayout)snackbar.getView(); //设置消息文本字体颜色 ((TextView)snackbarLayout.findViewById(R.id.snackbar_text)).setTextColor(Color.BLACK); //同理可以对动作按钮进行相关设置 //((Button)snackbarLayout.findViewById(R.id.snackbar_action)).setBackgroundResource(R.mipmap.ic_launcher); snackbar.show(); } }); c.增加内容到Snackbar//增加内容到Snackbar button3.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Snackbar snackbar = Snackbar.make(v, &quot;张三：今天晚上干嘛？&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;关闭&quot;, new View.OnClickListener() { @Override public void onClick(View v) { } }); View add_view = LayoutInflater.from(v.getContext()).inflate(R.layout.custom_layout , null); LinearLayout.LayoutParams p = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); p.gravity = Gravity.CENTER_VERTICAL; //数字表示新加的布局在SnackBar中的位置，从0开始,取决于你SnackBar里面有多少个子View Snackbar.SnackbarLayout snackbarLayout = (Snackbar.SnackbarLayout)snackbar.getView(); snackbarLayout.addView(add_view, 0, p); snackbar.show(); } }); 效果图如图所示。 写在最后本文使用的代码在github上可以获取到，地址： https://github.com/hust201010701/SnackbarCustomUsage/","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"Android 面试基础知识总结（原创）","slug":"Android 面试基础知识总结（原创）","date":"2016-07-11T16:00:00.000Z","updated":"2016-11-03T11:19:51.636Z","comments":true,"path":"2016/07/12/Android 面试基础知识总结（原创）/","link":"","permalink":"http://www.orzangleli.com/2016/07/12/Android 面试基础知识总结（原创）/","excerpt":"","content":"Android 基础知识总结 本文是orzangleli原创，转载请注明出处(http://www.orzangleli.com)。 1.Activity的理解在Android开发中Activity非常重要,在一个应用中,每一个显示的屏幕都是一个Activity.Activity是单独用于处理用户操作的，要使用Activity开发人员可以通过setContentView(View)把UI放到activity创建的窗口中。一般来说，必须要实现的接口是onCreate(Bundle),这是初始化Activity的地方，一般在这里调用setContentView和findViewById. 每个Activity在定义的时候，还需要在AndroidManifest.xml文件中声明，Activity的生命周期分为onCreate(),onStart(),onResume(),onPause(),onStop(),onDestory(),OnRestart(),7个过程，具体这几个过程之间的转换过程如图所示。 2.Activity、View和Window 的理解 Activity与View的区别 1).Activity是四大组件中唯一一个用来和用户进行交互的组件。可以说Activity就是android的视图层。(Android中四大组件：Activity,Service,BroadCast,ContentProvider). 2). 如果再细化，Activity相当于视图层中的控制层，是用来控制和管理View的，真正用来显示和处理事件的实际上是View。 3). 每个Activity内部都有一个Window对象，Window对象包含了一个DecorView(实际上就是FrameLayout)，我们通过setContentView给Activity设置显示的View实际上都是加到了DecorView中。 3.Activity的四大LaunchMode standard ———— 默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。 singleTop————可以有多个实例，但是不允许多个相同Activity叠加。即，如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法。 singleTask————只有一个实例。在同一个应用程序中启动它的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。 如果是在别的应用程序中启动它，则会新建一个task ，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。 singleInstance————只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。 4.View的绘制流程Android的View绘制是从根节点（Activity是DecorView）开始，他是一个自上而下的过程。View的绘制经历三个过程：Measure、Layout、Draw。基本流程如下图： Measure是确定视图的大小，Layout是确定视图的位置，Draw是绘制视图。 5.Touch事件机制1.Touch事件分发机制中有两个主角：ViewGroup和View,ViewGroup包含onInterceptTouchEvent,dispatchTouchEvent,onTouchEvent三个相关事件，而View只包含dispatchTouchEvent和onTouchEvent事件。 2.触摸事件由Action_Down,Action_Move,Action_Up三个事件组成，Down和Up只有1个，Move可以为多个，也可以为0个。 3.Activity内部包含一个ViewGroup，当Activity接收到触摸事件时，会分发Down事件给子ViewGroup和子View，如果子View处理了这个触摸事件，这个View的onTouchEvent会返回true.当ViewGroup的所有子View都不捕获Down事件时，ViewGroup会触发自身的onTouchEvent事件。 4.onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。 6.Android动画原理Android平台提供两类动画： Tween动画，通过场景里的对象不断做图像变化产生动画效果，主要是指平移，旋转，缩放。 Frame动画，通过顺序播放事先做好的图像，逐帧播放，类似与老式胶片电影的原理。 Android动画可以在java代码中直接使用动画，也可以在anim目录下新建xml文件，然后在java代码中使用。Android中的动画是建立在View级别上的，其中View类有一个接口startAnimatoin来开始动画。 7.Handler和Looper理解Handler 是消息处理者，负责Message的发送和处理，需要实现handleMessage(Message msg) 方法对特定的消息进行处理。 Looper 是消息泵，不断地从MessageQueue中抽取消息。 MessageQueue 消息队列，用来存取handler发送过来的消息，并且Looper会从中不断抽取Message，一个MessageQueue对应一个Looper. 三者之间的关系可以用下图表示： 8.Android跨进程通信在android SDK中提供了4种用于跨进程通讯的方式。这4种方式正好对应于android系统中4种应用程序组件：Activity、ContentProvider、Broadcast和Service。 其中Activity可以跨进程调用其他应用程序的Activity； Content Provider可以跨进程访问其他应用程序中的数据（以Cursor对象形式返回），当然，也可以对其他应用程序的数据进行增、删、改操作； Broadcast可以向android系统中所有应用程序发送广播，而需要跨进程通讯的应用程序可以监听这些广播； Service和Content Provider类似，也可以访问其他应用程序中的数据，但不同的是，Content Provider返回的是Cursor对象，而Service返回的是Java对象，这种可以跨进程通讯的服务叫AIDL服务（Android Interface Definition Language）。 9.Binder理解 binder用来做什么？用来实现不同进程之间的通信。 Binder是什么？binder属于一个驱动，工作在linux层面，运行在内核态，它的操作完成是基于一段内存。所以我们开发的程序中对binder的使用都是通过系统的调用来完成的。 binder是怎样实现进程通信的？我们来通过Binder的架构来了解它实现进程间通信（IPC）的过程。 客户端是通过Binder驱动来调用服务端的相关服务。首先，在服务端创建一个Binder对象，然后相应在Binder驱动中创建一个Binder对象，接着客户端通过获取Binder驱动中Binder对象的引用来调用服务端的服务。在Binder机制中正是借着Binder驱动将不同进程间的组件bind（粘连）在一起，实现通信。 ##","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"XBOX One 游戏手柄键位图 适用于Unity3D开发","slug":"XBOX One 游戏手柄键位图 适用于Unity3D开发","date":"2016-07-04T16:00:00.000Z","updated":"2016-11-03T11:19:50.930Z","comments":true,"path":"2016/07/05/XBOX One 游戏手柄键位图 适用于Unity3D开发/","link":"","permalink":"http://www.orzangleli.com/2016/07/05/XBOX One 游戏手柄键位图 适用于Unity3D开发/","excerpt":"","content":"XBOX One 游戏手柄键位图如下图所示。转载引用请注明出处。","categories":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/categories/unity3D/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"}]},{"title":"如何让NavigationView不遮挡ToolBar呢","slug":"如何让NavigationView不遮挡ToolBar呢","date":"2016-06-30T16:00:00.000Z","updated":"2016-11-03T11:19:51.049Z","comments":true,"path":"2016/07/01/如何让NavigationView不遮挡ToolBar呢/","link":"","permalink":"http://www.orzangleli.com/2016/07/01/如何让NavigationView不遮挡ToolBar呢/","excerpt":"","content":"如何让NavigationView不遮挡ToolBar呢？改变toolbar和DrawerLayout的嵌套关系，把他们放在Linearlayout中就行。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/toolbar_actionbar&quot;/&gt; &lt;android.support.v4.widget.DrawerLayout android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!-- Content --&gt; &lt;FrameLayout android:id=&quot;@+id/content_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; &lt;!-- Drawer --&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/navigation&quot; android:layout_width=&quot;240dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:menu=&quot;@menu/activity_main_drawer&quot;/&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; &lt;/LinearLayout&gt;","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"Android Studio Gradle 更新失败 Plugin is too old,please update to a more recent version,or set ANDROID_DAILY_OVERRIDE..","slug":"Android Studio Gradle 更新失败 Plugin is too old,please update to a more recent version,or set ANDROID_DAILY_OVERRIDE..","date":"2016-06-29T16:00:00.000Z","updated":"2016-11-03T11:19:50.741Z","comments":true,"path":"2016/06/30/Android Studio Gradle 更新失败 Plugin is too old,please update to a more recent version,or set ANDROID_DAILY_OVERRIDE../","link":"","permalink":"http://www.orzangleli.com/2016/06/30/Android Studio Gradle 更新失败 Plugin is too old,please update to a more recent version,or set ANDROID_DAILY_OVERRIDE../","excerpt":"","content":"打开AS，发现报错： Plugin is too old,please update to a more recent version,or setANDROID_DAILY_OVERRIDE.. 点下面的Fix plugin version and sync project 也不管用 经过大量测试，找到解决方法： 可以看到这里有很多版本的Gradle,当前使用的使用2.2.0-alpha1会报错，在修改Project下的build.gradle文件中的classpath为 classpath &apos;com.android.tools.build:gradle:2.0.0&apos; 然后Sync，再弹出的对话框中 选择第二项，Remind me later ，然后就成功了。 声明：这是本人通过大量测试得出的解决方案，请尊重劳动成果，转载请注明出处，谢谢!","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（一）","slug":"【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（一）","date":"2016-06-13T16:00:00.000Z","updated":"2016-11-03T11:19:50.688Z","comments":true,"path":"2016/06/14/【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（一）/","link":"","permalink":"http://www.orzangleli.com/2016/06/14/【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（一）/","excerpt":"","content":"本文转载自OneV’s Den 的博客，OneV’s Den 真是一位值得我们程序员学习的榜样，写的文章通俗易懂而且有深度，有兴趣的可以关注他的微博 。 以下部分是正文： 猫都能学会的Unity3D Shader入门指南（一） 动机自己使用Unity3D也有一段时间了，但是很多时候是流于表面，更多地是把这个引擎简单地用作脚本控制，而对更深入一些的层次几乎没有了解。虽然说Unity引擎设计的初衷就是创建简单的不需要开发者操心的谁都能用的3D引擎，但是只是肤浅的使用，可能是无法达到随心所欲的境地的，因此，这种状况必须改变！从哪里开始呢，貌似有句话叫做会写Shader的都是高手，于是，想大概看看从Shader开始能不能使自己到达的层次能再深入一些吧，再于是，有了这个系列（希望我能坚持写完它，虽然应该会拖个半年左右）。 Unity3D的所有渲染工作都离不开着色器（Shader），如果你和我一样最近开始对Shader编程比较感兴趣的话，可能你和我有着同样的困惑：如何开始？Unity3D提供了一些Shader的手册和文档（比如这里，这里和这里），但是一来内容比较分散，二来学习阶梯稍微陡峭了些。这对于像我这样之前完全没有接触过有关内容的新人来说是相当不友好的。国内外虽然也有一些Shader的介绍和心得，但是也同样存在内容分散的问题，很多教程前一章就只介绍了基本概念，接下来马上就搬出一个超复杂的例子，对于很多基本的用法并没有解释。也许对于Shader熟练使用的开发者来说是没有问题，但是我相信像我这样的入门者也并不在少数。在多方寻觅无果后，我觉得有必要写一份教程，来以一个入门者的角度介绍一些Shader开发的基本步骤。其实与其说是教程，倒不如说是一份自我总结，希望能够帮到有需要的人。 所以，本“教程”的对象是 总的来说是新接触Shader开发的人：也许你知道什么是Shader，也会使用别人的Shader，但是仅限于知道一些基本的内建Shader名字，从来没有打开它们查看其源码。 想要更多了解Shader和有需求要进行Shader开发的开发者，但是之前并没有Shader开发的经验。 当然，因为我本身在Shader开发方面也是一个不折不扣的大菜鸟，本文很多内容也只是在自己的理解加上一些可能不太靠谱的求证和总结。本文中的示例应该会有更好的方式来实现，因此您是高手并且恰巧路过的话，如果有好的方式来实现某些内容，恳请您不吝留下评论，我会对本文进行不断更新和维护。 一些基本概念Shader和Material如果是进行3D游戏开发的话，想必您对着两个词不会陌生。Shader（着色器）实际上就是一小段程序，它负责将输入的Mesh（网格）以指定的方式和输入的贴图或者颜色等组合作用，然后输出。绘图单元可以依据这个输出来将图像绘制到屏幕上。输入的贴图或者颜色等，加上对应的Shader，以及对Shader的特定的参数设置，将这些内容（Shader及输入参数）打包存储在一起，得到的就是一个Material（材质）。之后，我们便可以将材质赋予合适的renderer（渲染器）来进行渲染（输出）了。 所以说Shader并没有什么特别神奇的，它只是一段规定好输入（颜色，贴图等）和输出（渲染器能够读懂的点和颜色的对应关系）的程序。而Shader开发者要做的就是根据输入，进行计算变换，产生输出而已。 Shader大体上可以分为两类，简单来说 表面着色器（Surface Shader） – 为你做了大部分的工作，只需要简单的技巧即可实现很多不错的效果。类比卡片机，上手以后不太需要很多努力就能拍出不错的效果。 片段着色器（Fragment Shader） – 可以做的事情更多，但是也比较难写。使用片段着色器的主要目的是可以在比较低的层级上进行更复杂（或者针对目标设备更高效）的开发。 因为是入门文章，所以之后的介绍将主要集中在表面着色器上。 Shader程序的基本结构因为着色器代码可以说专用性非常强，因此人为地规定了它的基本结构。一个普通的着色器的结构应该是这样的： 首先是一些属性定义，用来指定这段代码将有哪些输入。接下来是一个或者多个的子着色器，在实际运行中，哪一个子着色器被使用是由运行的平台所决定的。子着色器是代码的主体，每一个子着色器中包含一个或者多个的Pass。在计算着色时，平台先选择最优先可以使用的着色器，然后依次运行其中的Pass，然后得到输出的结果。最后指定一个回滚，用来处理所有Subshader都不能运行的情况（比如目标设备实在太老，所有Subshader中都有其不支持的特性）。 需要提前说明的是，在实际进行表面着色器的开发时，我们将直接在Subshader这个层次上写代码，系统将把我们的代码编译成若干个合适的Pass。废话到此为止，下面让我们真正实际进入Shader的世界吧。 Hello Shader百行文档不如一个实例，下面给出一段简单的Shader代码，然后根据代码来验证下上面说到的结构和阐述一些基本的Shader语法。因为本文是针对Unity3D来写Shader的，所以也使用Unity3D来演示吧。首先，新建一个Shader，可以在Project面板中找到，Create，选择Shader，然后将其命名为Diffuse Texture： 随便用个文本编辑器打开刚才新建的Shader： Shader &quot;Custom/Diffuse Texture&quot; { Properties { _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {} } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } LOD 200 CGPROGRAM #pragma surface surf Lambert sampler2D _MainTex; struct Input { float2 uv_MainTex; }; void surf (Input IN, inout SurfaceOutput o) { half4 c = tex2D (_MainTex, IN.uv_MainTex); o.Albedo = c.rgb; o.Alpha = c.a; } ENDCG } FallBack &quot;Diffuse&quot; } 如果您之前没怎么看过Shader代码的话，估计细节上会看不太懂。但是有了上面基本结构的介绍，您应该可以识别出这个Shader的构成，比如一个Properties部分，一个SubShader，以及一个FallBack。另外，第一行只是这个Shader的声明并为其指定了一个名字，比如我们的实例Shader，你可以在材质面板选择Shader时在对应的位置找到这个Shader。 接下来我们讲逐句讲解这个Shader，以期明了每一个语句的意义。 属性在Properties{}中定义着色器属性，在这里定义的属性将被作为输入提供给所有的子着色器。每一条属性的定义的语法是这样的： _Name(&quot;Display Name&quot;, type) = defaultValue[{options}] _Name – 属性的名字，简单说就是变量名，在之后整个Shader代码中将使用这个名字来获取该属性的内容 Display Name – 这个字符串将显示在Unity的材质编辑器中作为Shader的使用者可读的内容 type – 这个属性的类型，可能的type所表示的内容有以下几种： Color – 一种颜色，由RGBA（红绿蓝和透明度）四个量来定义； 2D – 一张2的阶数大小（256，512之类）的贴图。这张贴图将在采样后被转为对应基于模型UV的每个像素的颜色，最终被显示出来； Rect – 一个非2阶数大小的贴图； Cube – 即Cube map texture（立方体纹理），简单说就是6张有联系的2D贴图的组合，主要用来做反射效果（比如天空盒和动态反射），也会被转换为对应点的采样； Range(min, max) – 一个介于最小值和最大值之间的浮点数，一般用来当作调整Shader某些特性的参数（比如透明度渲染的截止值可以是从0至1的值等）； Float – 任意一个浮点数； Vector – 一个四维数； defaultValue 定义了这个属性的默认值，通过输入一个符合格式的默认值来指定对应属性的初始值（某些效果可能需要某些特定的参数值来达到需要的效果，虽然这些值可以在之后在进行调整，但是如果默认就指定为想要的值的话就省去了一个个调整的时间，方便很多）。 Color – 以0～1定义的rgba颜色，比如(1,1,1,1)； 2D/Rect/Cube – 对于贴图来说，默认值可以为一个代表默认tint颜色的字符串，可以是空字符串或者”white”,”black”,”gray”,”bump”中的一个 Float，Range – 某个指定的浮点数 Vector – 一个4维数，写为 (x,y,z,w) 另外还有一个{option}，它只对2D，Rect或者Cube贴图有关，在写输入时我们最少要在贴图之后写一对什么都不含的空白的{}，当我们需要打开特定选项时可以把其写在这对花括号内。如果需要同时打开多个选项，可以使用空白分隔。可能的选择有ObjectLinear, EyeLinear, SphereMap, CubeReflect, CubeNormal中的一个，这些都是OpenGL中TexGen的模式，具体的留到后面有机会再说。 所以，一组属性的申明看起来也许会是这个样子的 //Define a color with a default value of semi-transparent blue _MainColor (&quot;Main Color&quot;, Color) = (0,0,1,0.5) //Define a texture with a default of white _Texture (&quot;Texture&quot;, 2D) = &quot;white&quot; {} 现在看懂上面那段Shader（以及其他所有Shader）的Properties部分应该不会有任何问题了。接下来就是SubShader部分了。 Tags表面着色器可以被若干的标签（tags）所修饰，而硬件将通过判定这些标签来决定什么时候调用该着色器。比如我们的例子中SubShader的第一句 Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } 告诉了系统应该在渲染非透明物体时调用我们。Unity定义了一些列这样的渲染过程，与RenderType是Opaque相对应的显而易见的是&quot;RenderType&quot; = &quot;Transparent&quot;，表示渲染含有透明效果的物体时调用。在这里Tags其实暗示了你的Shader输出的是什么，如果输出中都是非透明物体，那写在Opaque里；如果想渲染透明或者半透明的像素，那应该写在Transparent中。 另外比较有用的标签还有&quot;IgnoreProjector&quot;=&quot;True&quot;（不被Projectors影响），&quot;ForceNoShadowCasting&quot;=&quot;True&quot;（从不产生阴影）以及&quot;Queue&quot;=&quot;xxx&quot;（指定渲染顺序队列）。这里想要着重说一下的是Queue这个标签，如果你使用Unity做过一些透明和不透明物体的混合的话，很可能已经遇到过不透明物体无法呈现在透明物体之后的情况。这种情况很可能是由于Shader的渲染顺序不正确导致的。Queue指定了物体的渲染顺序，预定义的Queue有： Background – 最早被调用的渲染，用来渲染天空盒或者背景 Geometry – 这是默认值，用来渲染非透明物体（普通情况下，场景中的绝大多数物体应该是非透明的） AlphaTest – 用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑 Transparent – 以从后往前的顺序渲染透明物体 Overlay – 用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效） 这些预定义的值本质上是一组定义整数，Background = 1000， Geometry = 2000, AlphaTest = 2450，Transparent = 3000，最后Overlay =4000。在我们实际设置Queue值时，不仅能使用上面的几个预定义值，我们也可以指定自己的Queue值，写成类似这样：&quot;Queue&quot;=&quot;Transparent+100&quot;，表示一个在Transparent之后100的Queue上进行调用。通过调整Queue值，我们可以确保某些物体一定在另一些物体之前或者之后渲染，这个技巧有时候很有用处。 LODLOD很简单，它是Level ofDetail的缩写，在这里例子里我们指定了其为200（其实这是Unity的内建Diffuse着色器的设定值）。这个数值决定了我们能用什么样的Shader。在Unity的QualitySettings中我们可以设定允许的最大LOD，当设定的LOD小于SubShader所指定的LOD时，这个SubShader将不可用。Unity内建Shader定义了一组LOD的数值，我们在实现自己的Shader的时候可以将其作为参考来设定自己的LOD数值，这样在之后调整根据设备图形性能来调整画质时可以进行比较精确的控制。 VertexLit及其系列 = 100 Decal, Reflective VertexLit = 150 Diffuse = 200 Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit = 250 Bumped, Specular = 300 Bumped Specular = 400 Parallax = 500 Parallax Specular = 600 Shader本体前面杂项说完了，终于可以开始看看最主要的部分了，也就是将输入转变为输出的代码部分。为了方便看，请容许我把上面的SubShader的主题部分抄写一遍 CGPROGRAM #pragma surface surf Lambert sampler2D _MainTex; struct Input { float2 uv_MainTex; }; void surf (Input IN, inout SurfaceOutput o) { half4 c = tex2D (_MainTex, IN.uv_MainTex); o.Albedo = c.rgb; o.Alpha = c.a; } ENDCG 还是逐行来看，首先是CGPROGRAM。这是一个开始标记，表明从这里开始是一段CG程序（我们在写Unity的Shader时用的是Cg/HLSL语言）。最后一行的ENDCG与CGPROGRAM是对应的，表明CG程序到此结束。 接下来是是一个编译指令：#pragma surface surf Lambert，它声明了我们要写一个表面Shader，并指定了光照模型。它的写法是这样的 #pragma surface surfaceFunction lightModel [optionalparams] surface – 声明的是一个表面着色器 surfaceFunction – 着色器代码的方法的名字 lightModel – 使用的光照模型。 所以在我们的例子中，我们声明了一个表面着色器，实际的代码在surf函数中（在下面能找到该函数），使用Lambert（也就是普通的diffuse）作为光照模型。 接下来一句sampler2D _MainTex;，sampler2D是个啥？其实在CG中，sampler2D就是和texture所绑定的一个数据容器接口。等等..这个说法还是太复杂了，简单理解的话，所谓加载以后的texture（贴图）说白了不过是一块内存存储的，使用了RGB（也许还有A）通道，且每个通道8bits的数据。而具体地想知道像素与坐标的对应关系，以及获取这些数据，我们总不能一次一次去自己计算内存地址或者偏移，因此可以通过sampler2D来对贴图进行操作。更简单地理解，sampler2D就是GLSL中的2D贴图的类型，相应的，还有sampler1D，sampler3D，samplerCube等等格式。 解释通了sampler2D是什么之后，还需要解释下为什么在这里需要一句对_MainTex的声明，之前我们不是已经在Properties里声明过它是贴图了么。答案是我们用来实例的这个shader其实是由两个相对独立的块组成的，外层的属性声明，回滚等等是Unity可以直接使用和编译的ShaderLab；而现在我们是在CGPROGRAM...ENDCG这样一个代码块中，这是一段CG程序。对于这段CG程序，要想访问在Properties中所定义的变量的话，必须使用和之前变量相同的名字进行声明。于是其实sampler2D _MainTex;做的事情就是再次声明并链接了_MainTex，使得接下来的CG程序能够使用这个变量。 终于可以继续了。接下来是一个struct结构体。相信大家对于结构体已经很熟悉了，我们先跳过之，直接看下面的的surf函数。上面的#pragma段已经指出了我们的着色器代码的方法的名字叫做surf，那没跑儿了，就是这段代码是我们的着色器的工作核心。我们已经说过不止一次，着色器就是给定了输入，然后给出输出进行着色的代码。CG规定了声明为表面着色器的方法（就是我们这里的surf）的参数类型和名字，因此我们没有权利决定surf的输入输出参数的类型，只能按照规定写。这个规定就是第一个参数是一个Input结构，第二个参数是一个inout的SurfaceOutput结构。 它们分别是什么呢？Input其实是需要我们去定义的结构，这给我们提供了一个机会，可以把所需要参与计算的数据都放到这个Input结构中，传入surf函数使用；SurfaceOutput是已经定义好了里面类型输出结构，但是一开始的时候内容暂时是空白的，我们需要向里面填写输出，这样就可以完成着色了。先仔细看看INPUT吧，现在可以跳回来看上面定义的INPUT结构体了： struct Input { float2 uv_MainTex; }; 作为输入的结构体必须命名为Input，这个结构体中定义了一个float2的变量…你没看错我也没打错，就是float2，表示浮点数的float后面紧跟一个数字2，这又是什么意思呢？其实没什么魔法，float和vec都可以在之后加入一个2到4的数字，来表示被打包在一起的2到4个同类型数。比如下面的这些定义： //Define a 2d vector variable vec2 coordinate; //Define a color variable float4 color; //Multiply out a color float3 multipliedColor = color.rgb * coordinate.x; 在访问这些值时，我们即可以只使用名称来获得整组值，也可以使用下标的方式（比如.xyzw，.rgba或它们的部分比如.x等等）来获得某个值。在这个例子里，我们声明了一个叫做uv_MainTex的包含两个浮点数的变量。 如果你对3D开发稍有耳闻的话，一定不会对uv这两个字母感到陌生。UVmapping的作用是将一个2D贴图上的点按照一定规则映射到3D模型上，是3D渲染中最常见的一种顶点处理手段。在CG程序中，我们有这样的约定，在一个贴图变量（在我们例子中是_MainTex）之前加上uv两个字母，就代表提取它的uv值（其实就是两个代表贴图上点的二维坐标）。我们之后就可以在surf程序中直接通过访问uv_MainTex来取得这张贴图当前需要计算的点的坐标值了。 如果你坚持看到这里了，那要恭喜你，因为离最后成功读完一个Shader只有一步之遥。我们回到surf函数，它的两有参数，第一个是Input，我们已经明白了：在计算输出时Shader会多次调用surf函数，每次给入一个贴图上的点坐标，来计算输出。第二个参数是一个可写的SurfaceOutput，SurfaceOutput是预定义的输出结构，我们的surf函数的目标就是根据输入把这个输出结构填上。SurfaceOutput结构体的定义如下 struct SurfaceOutput { half3 Albedo; //像素的颜色 half3 Normal; //像素的法向值 half3 Emission; //像素的发散颜色 half Specular; //像素的镜面高光 half Gloss; //像素的发光强度 half Alpha; //像素的透明度 }; 这里的half和我们常见float与double类似，都表示浮点数，只不过精度不一样。也许你很熟悉单精度浮点数（float或者single）和双精度浮点数（double），这里的half指的是半精度浮点数，精度最低，运算性能相对比高精度浮点数高一些，因此被大量使用。 在例子中，我们做的事情非常简单： half4 c = tex2D (_MainTex, IN.uv_MainTex); o.Albedo = c.rgb; o.Alpha = c.a; 这里用到了一个tex2d函数，这是CG程序中用来在一张贴图中对一个点进行采样的方法，返回一个float4。这里对_MainTex在输入点上进行了采样，并将其颜色的rbg值赋予了输出的像素颜色，将a值赋予透明度。于是，着色器就明白了应当怎样工作：即找到贴图上对应的uv点，直接使用颜色信息来进行着色，over。 接下来…我想现在你已经能读懂一些最简单的Shader了，接下来我推荐的是参考Unity的Surface ShaderExamples多接触一些各种各样的基本Shader。在这篇教程的基础上，配合一些google的工作，完全看懂这个shader示例页面应该不成问题。如果能做到无压力看懂，那说明你已经有良好的基础可以前进到Shader的更深的层次了（也许等不到我的下一篇教程就可以自己开始动手写些效果了）；如果暂时还是有困难，那也没有关系，Shader学习绝对是一个渐进的过程，因为有很多约定和常用技巧，多积累和实践自然会进步并掌握。 在接下来的教程里，打算通过介绍一些实际例子以及从基础开始实际逐步动手实现一个复杂一点的例子，让我们能看到shader在真正使用中的威力。我希望能尽快写完这个系列，但是无奈时间确实有限，所以我也不知道什么时候能出炉…写好的时候我会更改这段内容并指向新的文章。您要是担心错过的话，也可以使用邮件订阅或者订阅本站的rss(虽然GoogleReader已经关了- -)。","categories":[{"name":"Shader","slug":"Shader","permalink":"http://www.orzangleli.com/categories/Shader/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"},{"name":"Shader","slug":"Shader","permalink":"http://www.orzangleli.com/tags/Shader/"}]},{"title":"【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（二）","slug":"【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（二）","date":"2016-06-13T16:00:00.000Z","updated":"2016-11-03T11:19:49.770Z","comments":true,"path":"2016/06/14/【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（二）/","link":"","permalink":"http://www.orzangleli.com/2016/06/14/【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（二）/","excerpt":"","content":"本文转载自OneV’s Den 的博客，OneV’s Den真是一位值得我们程序员学习的榜样，写的文章通俗易懂而且有深度，有兴趣的可以关注他的微博。 以下部分是正文： # 猫都能学会的Unity3D Shader入门指南（二）关于本系列这是Unity3DShader入门指南系列的第二篇，本系列面向的对象是新接触Shader开发的Unity3D使用者，因为我本身自己也是Shader初学者，因此可能会存在错误或者疏漏，如果您在Shader开发上有所心得，很欢迎并恳请您指出文中纰漏，我会尽快改正。在之前的开篇中介绍了一些Shader的基本知识，包括ShaderLab的基本结构和语法，以及简单逐句地讲解了一个基本的shader。在具有这些基础知识后，阅读简单的shader应该不会有太大问题，在继续教程之前简单阅读一下Unity的SurfaceShader Example，以检验您是否掌握了上一节的内容。如果您对阅读大部分示例Shader并没有太大问题，可以正确地指出Shader的结构，声明和使用的话，就说明您已经准备好继续阅读本节的内容了。 法线贴图(Normal Mapping)法线贴图是凸凹贴图(Bumpmapping)的一种常见应用，简单说就是在不增加模型多边形数量的前提下，通过渲染暗部和亮部的不同颜色深度，来为原来的贴图和模型增加视觉细节和真实效果。简单原理是在普通的贴图的基础上，再另外提供一张对应原来贴图的，可以表示渲染浓淡的贴图。通过将这张附加的表示表面凸凹的贴图的因素于实际的原贴图进行运算后，可以得到新的细节更加丰富富有立体感的渲染效果。在本节中，我们将首先实现一个法线贴图的Shader，然后对UnityShader的光照模型进行一些讨论，并实现一个自定义的光照模型。最后再通过更改shader模拟一个石头上的积雪效果，并对模型顶点进行一些修改使积雪效果看起来比较真实。在本节结束的时候，我们就会有一个比较强大的可以满足一些真实开发工作时可用的shader了，而且更重要的是，我们将会掌握它是如何被创造出来的。 关于法线贴图的效果图，可以对比看看下面。模型面数为500，左侧只使用了简单的Diffuse着色，右侧使用了法线贴图。比较两张图片不难发现，使用了法线贴图的石头在暗部和亮部都有着更好的表现。整体来说，凸凹感比Diffuse的结果增强许多，石头看起来更真实也更具有质感。 本节中需要用到的上面的素材可以在这里下载，其中包括上面的石块的模型，一张贴图以及对应的法线贴图。将下载的package导入到工程中，并新建一个material，使用简单的Diffuse的Shader（比如上一节我们实现的），再加上一个合适的平行光光源，就可以得到我们左图的效果。另外，本节以及以后都会涉及到一些Unity内建的Shader的内容，比如一些标准常用函数和常量定义等，相关内容可以在Unity的内建Shader中找到，内建Shader可以在Unity下载页面的版本右侧找到。 接下来我们实现法线贴图。在实现之前，我们先简单地稍微多了解一些法线贴图的基本知识。大多数法线图一般都和下面的图类似，是一张以蓝紫色为主的图。这张法线图其实是一张RGB贴图，其中红，绿，蓝三个通道分别表示由高度图转换而来的该点的法线指向：Nx、Ny、Nz。在其中绝大部分点的法线都指向z方向，因此图更偏向于蓝色。在shader进行处理时，我们将光照与该点的法线值进行点积后即可得到在该光线下应有的明暗特性，再将其应用到原图上，即可反应在一定光照环境下物体的凹凸关系了。关于法向贴图的更多信息，可以参考wiki上的相关条目。 回到正题，我们现在考虑的主要是Shader入门，而不是图像学的原理。再上一节我们写的Shader的基础上稍微做一些修改，就可以得到适应并完成法线贴图渲染的新Shader。新加入的部分进行了编号并在之后进行说明。 Shader &quot;Custom/Normal Mapping&quot; { Properties { _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {} //1 _Bump (&quot;Bump&quot;, 2D) = &quot;bump&quot; {} } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } LOD 200 CGPROGRAM #pragma surface surf Lambert sampler2D _MainTex; //2 sampler2D _Bump; struct Input { float2 uv_MainTex; //3 float2 uv_Bump; }; void surf (Input IN, inout SurfaceOutput o) { half4 c = tex2D (_MainTex, IN.uv_MainTex); //4 o.Normal = UnpackNormal(tex2D(_Bump, IN.uv_Bump); o.Albedo = c.rgb; o.Alpha = c.a; } ENDCG } FallBack &quot;Diffuse&quot; } 声明并加入一个显示名称为Bump的贴图，用于放置法线图 为了能够在CG程序中使用这张贴图，必须加入一个sample，希望你还记得～ 获取Bump的uv信息作为输入 从法线图中提取法线信息，并将其赋予相应点的输出的Normal属性。UnpackNormal是定义在UnityCG.cginc文件中的方法，这个文件中包含了一系列常用的CG变量以及方法。UnpackNormal接受一个fixed4的输入，并将其转换为所对应的法线值（fixed3）。在解包得到这个值之后，将其赋给输出的Normal，就可以参与到光线运算中完成接下来的渲染工作了。 现在保存并且编译这个Shader，创建新的material并使用这个shader，将石头的材质贴图和法线图分别拖放到Base和Bump里，再将其应用到石头模型上，应该就可以看到右侧图的效果了。 光照模型在我们之前的看到的Shader中（其实也就上一节的基本diffuse和这里的normalmapping），都只使用了Lambert的光照模型（#pragma surface surfLambert），这是一个很经典的漫反射模型，光强与入射光的方向和反射点处表面法向夹角的余弦成正比。关于Lambert和漫反射的一些详细的计算和推论，可以参看wiki（Lambert，漫反射）或者其他地方的介绍。一句话的简单解释就是一个点的反射光强是和该点的法线向量和入射光向量和强度和夹角有关系的，其结果就是这两个向量的点积。既然已经知道了光照计算的原理，我们先来看看如何实现一个自己的光照模型吧。 在刚才的Shader上进行如下修改。 首先将原来的#pragma行改为这样 #pragma surface surf CustomDiffuse 然后在SubShader块中添加如下代码 inline float4 LightingCustomDiffuse (SurfaceOutput s, fixed3 lightDir, fixed atten) { float difLight = max(0, dot (s.Normal, lightDir)); float4 col; col.rgb = s.Albedo * _LightColor0.rgb * (difLight * atten * 2); col.a = s.Alpha; return col; } 最后保存，回到Unity。Shader将编译，如果一切正常，你将不会看到新的shader和之前的在材质表现上有任何不同。但是事实上我们现在的shader已经与Unity内建的diffuse光照模型撇清了关系，而在使用我们自己设定的光照模型了。 喵的，这些代码都干了些什么！相信你一定会有这样的疑惑…没问题，没有疑惑的话那就不叫初学了，还是一行行讲来。首先正像我们上一篇所说，#pragma语句在这里声明了接下来的Shader的类型，计算调用的方法名，以及指定光照模型。在之前我们一直指定Lambert为光照模型，而现在我们将其换为了CustomDiffuse。 接下来添加的代码是计算光照的实现。shader中对于方法的名称有着比较严格的约定，想要创建一个光照模型，首先要做的是按照规则声明一个光照计算的函数名字，即Lighting&lt;Your Chosen Name&gt;。对于我们的光照模型CustomDiffuse，其计算函数的名称自然就是LightingCustomDiffuse了。光照模型的计算是在surf方法的表面颜色之后，根据输入的光照条件来对原来的颜色在这种光照下的表现进行计算，最后输出新的颜色值给渲染单元完成在屏幕的绘制。 也许你已经猜到了，我们之前用的Lambert光照模型是不是也有一个名字叫LightingLambert的光照计算函数呢？Bingo。在Unity的内建Shader中，有一个Lighting.cginc文件，里面就包含了LightingLambert的实现。也许你也注意到了，我们所实现的LightingCustomDiffuse的内容现在和Unity内建中的LightingLambert是完全一样的，这也就是使用新的shader的原来视觉上没有区别的原因，因为实现确实是完全一样的。 首先来看输入量，SurfaceOutput s这个就是经过表面计算函数surf处理后的输出，我们讲对其上的点根据光线进行处理，fixed3 lightDir是光线的方向，fixed atten表示光衰减的系数。在计算光照的代码中，我们先将输入的s的法线值（在Normalmapping中的话这个值已经是法线图中的对应量了）和输入光线进行点积（dot函数是CG中内置的数学函数，希望你还记得，可以参考这里）。点积的结果在-1至1之间，这个值越大表示法线与光线间夹角越小，这个点也就应该越亮。之后使用max来将这个系数结果限制在0到1之间，是为了避免负数情况的存在而导致最终计算的颜色变为负数，输出一团黑，一般来说这是我们不愿意看到的。接下来我们将surf输出的颜色与光线的颜色_LightColor0.rgb（由Unity根据场景中的光源得到的，它在Lighting.cginc中有声明）进行乘积，然后再与刚才计算的光强系数和输入的衰减系数相乘，最后得到在这个光线下的颜色输出（关于difLight atten 2中为什么有个乘2，这是一个历史遗留问题，主要是为了进行一些光强补偿，可以参见[这里的讨论](http://forum.unity3d.com/threads/94711-Why-\\(atten--2))）。 在了解了基本实现方式之后，我们可以看看做一些修改玩玩儿。最简单的比如将这个Lambert模型改亮一些，比如换成Half Lambert模型。HalfLambert是由Valve创造的可以使物体在低光线条件下增亮的技术，最早被用于半条命（HalfLife）中以避免在低光下物体的走形。简单说就是把光强系数先取一半，然后在加0.5，代码如下： inline float4 LightingCustomDiffuse (SurfaceOutput s, fixed3 lightDir, fixed atten) { float difLight = dot (s.Normal, lightDir); float hLambert = difLight * 0.5 + 0.5; float4 col; col.rgb = s.Albedo * _LightColor0.rgb * (hLambert * atten * 2); col.a = s.Alpha; return col; } 这样一来，原来光强0的点，现在对应的值变为了0.5，而原来是1的地方现在将保持为1。也就是说模型贴图的暗部被增强变亮了，而亮部基本保持和原来一样，防止过曝。使用HalfLambert前后的效果图如下，注意最右侧石头下方的阴影处细节更加明显了，而这一切都只是视觉效果的改变，不涉及任何贴图和模型的变化。 表面贴图的追加效果OK，对于光线和自定义光照模型的讨论暂时到此为止，因为如果展开的话这将会一个庞大的图形学和经典光学的话题了。我们回到Shader，并且一起实现一些激动人心的效果吧。比如，在你的游戏场景中有一幕是雪地场景，而你希望做一些石头上白雪皑皑的覆盖效果，应该怎么办呢？难道让你可爱的3D设计师再去出一套覆雪的贴图然后使用新的贴图？当然不，不是不能，而是不该。因为新的贴图不仅会增大项目的资源包体积，更会增大之后修改和维护的难度，想想要是有好多石头需要实现同样的覆雪效果，或者是要随着游戏时间堆积的雪逐渐变多的话，你应该怎么办？难道让设计师再把所有的石头贴图都盖上雪，然后再按照雪的厚度出5套不同的贴图么？相信我，他们会疯的。 于是，我们考虑用Shader来完成这件工作吧！先考虑下我们需要什么，积雪效果的话，我们需要积雪等级（用来表示积雪量），雪的颜色，以及积雪的方向。基本思路和实现自定义光照模型类似，通过计算原图的点在世界坐标中的法线方向与积雪方向的点积，如果大于设定的积雪等级的阈值的话则表示这个方向与积雪方向是一致的，其上是可以积雪的，显示雪的颜色，否则使用原贴图的颜色。废话不再多说，上代码，在上面的Shader的基础上，更改Properties里的内容为 Properties { _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {} _Bump (&quot;Bump&quot;, 2D) = &quot;bump&quot; {} _Snow (&quot;Snow Level&quot;, Range(0,1) ) = 0 _SnowColor (&quot;Snow Color&quot;, Color) = (1.0,1.0,1.0,1.0) _SnowDirection (&quot;Snow Direction&quot;, Vector) = (0,1,0) } 没有太多值得说的，唯一要提一下的是_SnowDirection设定的默认值为(0,1,0)，这表示我们希望雪是垂直落下的。对应地，在CG程序中对这些变量进行声明： sampler2D _MainTex; sampler2D _Bump; float _Snow; float4 _SnowColor; float4 _SnowDirection; 接下来改变Input的内容： struct Input { float2 uv_MainTex; float2 uv_Bump; float3 worldNormal; INTERNAL_DATA }; 相对于上面的Shader输入来说，加入了一个float3 worldNormal; INTERNAL_DATA，如果SurfaceOutput中设定了Normal值的话，通过worldNormal可以获取当前点在世界中的法线值。详细的解说可以参见Unity的Shader文档。接下来可以改变surf函数，实装积雪效果了。 void surf (Input IN, inout SurfaceOutput o) { half4 c = tex2D (_MainTex, IN.uv_MainTex); o.Normal = UnpackNormal(tex2D(_Bump, IN.uv_Bump)); if (dot(WorldNormalVector(IN, o.Normal), _SnowDirection.xyz) &gt; lerp(1,-1,_Snow)) { o.Albedo = _SnowColor.rgb; } else { o.Albedo = c.rgb; } o.Alpha = c.a; } 和上面相比，加入了一个if…else…的判断。首先看这个条件的不等式的左侧，我们对雪的方向和和输入点的世界法线方向进行点积。WorldNormalVector通过输入的点及这个点的法线值，来计算它在世界坐标中的方向；右侧的lerp函数相信只要对插值有概念的同学都不难理解：当_Snow取最小值0时，这个函数将返回1，而_Snow取最大值时，返回-1。这样我们就可以通过设定_Snow的值来控制积雪的阈值，要是积雪等级_Snow是0时，不等式左侧不可能大于右侧，因此完全没有积雪；相反要是_Snow取最大值1时，由于左侧必定大于-1，所以全模型积雪。而随着取中间值的变化，积雪的情况便会有所不同。 应用这个Shader，并且适当地调节一下积雪等级和颜色，可以得到如下右边的效果。 更改顶点模型到现在位置，我们还仅指是在原贴图上进行操作，不管是用法线图使模型看起来凸凹有致，还是加上积雪，所有的计算和颜色的输出都只是“障眼法”，并没有对模型有任何实质的改动。但是对于积雪效果来说，实际上积雪是附加到石头上面，而不应当简单替换掉原来的颜色。但是具体实施起来，最简单的办法还是直接替换颜色，但是我们可以稍微变更一下模型，使原来的模型在积雪的方向稍微变大一些，这样来达到一种雪是附加到石头上的效果。 我们继续修改之前的Shader，首先我们需要告诉surface shadow我们要改变模型的顶点。首先将#param行改为 #pragma surface surf CustomDiffuse vertex:vert 这告诉Shader我们想要改变模型顶点，并且我们会写一个叫做vert的函数来改变顶点。接下来我们再添加一个参数，在Properties中声明一个_SnowDepth变量，表示积雪的厚度，当然我们也需要在CG段中进行声明： //In Properties{…} _SnowDepth (&quot;Snow Depth&quot;, Range(0,0.3)) = 0.1 //In CG declare float _SnowDepth; 接下来实现vert方法，和之前积雪的运算其实比较类似，判断点积大小来决定是否需要扩大模型以及确定模型扩大的方向。在CG段中加入以下vert方法 void vert (inout appdata_full v) { float4 sn = mul(transpose(_Object2World) , _SnowDirection); if(dot(v.normal, sn.xyz) &gt;= lerp(1,-1, (_Snow * 2) / 3)) { v.vertex.xyz += (sn.xyz + v.normal) * _SnowDepth * _Snow; } } 和surf的原理差不多，系统会输入一个当前的顶点的值，我们根据需要计算并填上新的值作为返回即可。上面第一行中使用transpose方法输出原矩阵的转置矩阵，在这里_Object2World是UnityShaderLab的内建值，它表示将当前模型转换到世界坐标中的矩阵，将其与积雪方向做矩阵乘积得到积雪方向在物体的世界空间中的投影（把积雪方向转换到世界坐标中）。之后我们计算了这个世界坐标中实际的积雪方向和当前点的法线值的点积，并将结果与使用积雪等级的2/3进行比较lerp后的阈值比较。这样，当前点如果和积雪方向一致，并且积雪较为完整的话，将改变该点的模型顶点高度。 加入模型更改前后的效果对比如下图，加入模型调整的右图表现要更为丰满真实。 这节就到这里吧。本节中实现的Shader可以在这里找到完整版本进行参考，希望大家周末愉快～","categories":[{"name":"Shader","slug":"Shader","permalink":"http://www.orzangleli.com/categories/Shader/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"},{"name":"Shader","slug":"Shader","permalink":"http://www.orzangleli.com/tags/Shader/"}]},{"title":"使用Github中的项目 SwipeBackLayout 侧滑关闭 黑屏解决方案","slug":"使用Github中的项目 SwipeBackLayout 侧滑关闭 黑屏解决方案","date":"2016-06-13T16:00:00.000Z","updated":"2016-11-03T11:19:50.692Z","comments":true,"path":"2016/06/14/使用Github中的项目 SwipeBackLayout 侧滑关闭 黑屏解决方案/","link":"","permalink":"http://www.orzangleli.com/2016/06/14/使用Github中的项目 SwipeBackLayout 侧滑关闭 黑屏解决方案/","excerpt":"","content":"在生活中，大量APP使用了侧滑退出功能，微信中使用犹为频繁，在进入朋友圈时，右滑就能退出这个界面，返回上一层，使用起来很方便。 Github上有一个开源项目，使用这个库就能方便的实现该功能。 这个控件的名称为：WP Reposidget GitHub 仓库挂件 WordPress 插件 hust201010701 /SwipeBackLayout An Android library that help you to build app with swipe back gesture. https://github.com/hust201010701/SwipeBackLayout 00 DownloadZIP 使用起来也是很方便，将默认继承的Activity修改为SwipeBackActivity，然后设置下滑动方向即可。 mSwipeBackLayout = getSwipeBackLayout(); mSwipeBackLayout.setEdgeTrackingEnabled(edgeFlag); 套路人家做出来的程序，给出效果图。 注意一定要加上这句话： Make window translucent by adding &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt; to your theme. 否则就会出现，侧滑时，背景为黑色。 另外，滑动到哪里才会返回，是设置一个阈值，使用下面代码： mSwipeBackLayout.setScrollThresHold(0.6f); 完整代码如下： mSwipeBackLayout = getSwipeBackLayout(); mSwipeBackLayout.setEdgeTrackingEnabled(SwipeBackLayout.EDGE_LEFT); mSwipeBackLayout.setScrollThresHold(0.4f); mSwipeBackLayout.addSwipeListener(new SwipeBackLayout.SwipeListener() { @Override public void onScrollStateChange(int state, float scrollPercent) { } @Override public void onEdgeTouch(int edgeFlag) { } @Override public void onScrollOverThreshold() { } });","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"Unity3D中铰链(HingeJoint)组件的使用","slug":"Unity3D中铰链(HingeJoint)组件的使用","date":"2016-06-12T16:00:00.000Z","updated":"2016-11-03T11:19:49.143Z","comments":true,"path":"2016/06/13/Unity3D中铰链(HingeJoint)组件的使用/","link":"","permalink":"http://www.orzangleli.com/2016/06/13/Unity3D中铰链(HingeJoint)组件的使用/","excerpt":"","content":"HingeJoint(铰链关节)什么是铰链 铰链（英:hinge），又称合页,是用来连接两个固体，并允许两者之间做转动的机械装置。铰链可能由可移动的组件构成，或者由可折叠的材料构成。最常见的是门窗上安装的铰链。 开始制作自己的铰链 在unity3D中新建一个Cube,然后将X轴方向的scale调整为10，然后添加RigidBody (刚体)组件，取消掉Use Gravity选项，设置x=0 将Cube选中，按住Ctrl+D复制一份，然后将新的Cube移动到x=-10的位置 给第一个Cube添加FixedJoint，不需要修改其中属性，完成后应该与下图一致 给第二个Cube(1)添加HingeJoint，将Cube拖到Connected Body中，然后修改锚点为局部坐标下的(-0.5,0,0),同时设置旋转轴，为z轴(0,0,1),系统会自动计算出第一个Cube的锚点位置，完成后应该如下图。 让铰链运动起来因为铰链是一种物理结构，使用到物理引擎，所以控制铰链运动时，不可以使用transfrom,只能添加一个物理上的力或者速度，这里我们添加恒力。因为要使铰链结构再xy平面内旋转，所以添加一个沿着局部坐标系下的y轴的力Relative Force(0,1,0),1代表单位力，可以改成其他数值。 运动效果直接上图吧","categories":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/categories/unity3D/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"}]},{"title":"VIVE普通车床车削2   完善与优化","slug":"VIVE普通车床车削2   完善与优化","date":"2016-06-11T16:00:00.000Z","updated":"2016-11-03T11:19:49.814Z","comments":true,"path":"2016/06/12/VIVE普通车床车削2   完善与优化/","link":"","permalink":"http://www.orzangleli.com/2016/06/12/VIVE普通车床车削2   完善与优化/","excerpt":"","content":"增加了抓取动作和传送动作的实现 Share the video Facebook Twitter Google+ Email Embed Copy and paste this HTML code into your webpage to embed. flowplayer 00:00 __ 00:00 ## Copy and paste this HTML code into your webpage to embed. _space_play / pause _q_unload | stop _f_fullscreen _↑__↓_volume _m_mute _←__→_seek _ . _seek to previous 1__2… 6 seek to 10%, 20% … 60% © 2015 About Flowplayer GPL based license","categories":[{"name":"HTC VIVE","slug":"HTC-VIVE","permalink":"http://www.orzangleli.com/categories/HTC-VIVE/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"},{"name":"HTC VIVE","slug":"HTC-VIVE","permalink":"http://www.orzangleli.com/tags/HTC-VIVE/"}]},{"title":"HTC VIVE (VR)  普通车床切削过程","slug":"HTC VIVE (VR)  普通车床切削过程","date":"2016-06-04T16:00:00.000Z","updated":"2016-11-03T11:19:49.506Z","comments":true,"path":"2016/06/05/HTC VIVE (VR)  普通车床切削过程/","link":"","permalink":"http://www.orzangleli.com/2016/06/05/HTC VIVE (VR)  普通车床切削过程/","excerpt":"","content":"Share the video Facebook Twitter Google+ Email Embed Copy and paste this HTML code into your webpage to embed. flowplayer 00:00 __ 00:00 ## Copy and paste this HTML code into your webpage to embed. _space_play / pause _q_unload | stop _f_fullscreen _↑__↓_volume _m_mute _←__→_seek _ . _seek to previous 1__2… 6 seek to 10%, 20% … 60% © 2015 About Flowplayer GPL based license","categories":[{"name":"HTC VIVE","slug":"HTC-VIVE","permalink":"http://www.orzangleli.com/categories/HTC-VIVE/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"},{"name":"HTC VIVE","slug":"HTC-VIVE","permalink":"http://www.orzangleli.com/tags/HTC-VIVE/"}]},{"title":"Arduino +W5100 +DS18B20 获取温度，上传到yeelink，成功经验","slug":"Arduino +W5100 +DS18B20 获取温度，上传到yeelink，成功经验","date":"2016-05-29T16:00:00.000Z","updated":"2016-11-03T11:19:48.825Z","comments":true,"path":"2016/05/30/Arduino +W5100 +DS18B20 获取温度，上传到yeelink，成功经验/","link":"","permalink":"http://www.orzangleli.com/2016/05/30/Arduino +W5100 +DS18B20 获取温度，上传到yeelink，成功经验/","excerpt":"","content":"MarkdownPad Document 首先，从理论上来说，获取温度并上传并不算复杂，但是在尝试的过程中遇到各种坑，现在记录下来，希望后来者不要再次步入此坑。 使用正确的连线刚开始时，我从yeelink官网上看到一个demo，说的是LM35传感器获取温度，我从文章里看到连线图如下所示：照着这个图连下来，然后再串口调试中看到输出的数据完全是错误的，有负数，有200多，完全不是室内温度，后来看到半天我才知道，原来我自己使用的温度传感器是DS18B20，并不是LM35,然后根据下面这张图连线： 使用下面代码获取温度： #include &lt;OneWire.h&gt; OneWire ds(10); // 连接arduino10引脚 void setup(void) { Serial.begin(9600); } void loop(void) { byte i; byte present = 0; byte type_s; byte data[12]; byte addr[8]; float celsius, fahrenheit; if ( !ds.search(addr)) { Serial.println(&quot;No more addresses.&quot;); Serial.println(); ds.reset_search(); delay(250); return; } Serial.print(&quot;ROM =&quot;); for( i = 0; i &lt; 8; i++) { Serial.write(&apos; &apos;); Serial.print(addr[i], HEX); } if (OneWire::crc8(addr, 7) != addr[7]) { Serial.println(&quot;CRC is not valid!&quot;); return; } Serial.println(); // the first ROM byte indicates which chip switch (addr[0]) { case 0x10: Serial.println(&quot; Chip = DS18S20&quot;); // or old DS1820 type_s = 1; break; case 0x28: Serial.println(&quot; Chip = DS18B20&quot;); type_s = 0; break; case 0x22: Serial.println(&quot; Chip = DS1822&quot;); type_s = 0; break; default: Serial.println(&quot;Device is not a DS18x20 family device.&quot;); return; } ds.reset(); ds.select(addr); ds.write(0x44,1); // start conversion, with parasite power on at the end delay(1000); // maybe 750ms is enough, maybe not // we might do a ds.depower() here, but the reset will take care of it. present = ds.reset(); ds.select(addr); ds.write(0xBE); // Read Scratchpad Serial.print(&quot; Data = &quot;); Serial.print(present,HEX); Serial.print(&quot; &quot;); for ( i = 0; i &lt; 9; i++) { // we need 9 bytes data[i] = ds.read(); Serial.print(data[i], HEX); Serial.print(&quot; &quot;); } Serial.print(&quot; CRC=&quot;); Serial.print(OneWire::crc8(data, 8), HEX); Serial.println(); // convert the data to actual temperature unsigned int raw = (data[1] &lt;&lt; 8) | data[0]; if (type_s) { raw = raw &lt;&lt; 3; // 9 bit resolution default if (data[7] == 0x10) { // count remain gives full 12 bit resolution raw = (raw &amp; 0xFFF0) + 12 - data[6]; } } else { byte cfg = (data[4] &amp; 0x60); if (cfg == 0x00) raw = raw &lt;&lt; 3; // 9 bit resolution, 93.75 ms else if (cfg == 0x20) raw = raw &lt;&lt; 2; // 10 bit res, 187.5 ms else if (cfg == 0x40) raw = raw &lt;&lt; 1; // 11 bit res, 375 ms // default is 12 bit resolution, 750 ms conversion time } celsius = (float)raw / 16.0; fahrenheit = celsius * 1.8 + 32.0; Serial.print(&quot; Temperature = &quot;); Serial.print(celsius); Serial.print(&quot; Celsius, &quot;); Serial.print(fahrenheit); Serial.println(&quot; Fahrenheit&quot;); } 使用正确的上传数据代码什么是最坑的？最坑的不过是yeelink官网给我们的demo，无法运行取得正确的结果。官网给的例子：http://www.yeelink.net/developer/doc/48代码如下：https://github.com/Yeelink/example_basic_3_LM35/blob/master/LM35.ino 经过测试，发现这段代码根本无法上传数据，并不知道是为什么，而且从yeelink官网上的blog专栏也可以看到，之前别人使用的都是使用EthernetClient上传数据。http://blog.yeelink.net/?p=94 所以，根据修改这篇文章里的sendData(int data) 发送数据到后台。 但是，这个函数只能发送int类型的变量，修改为float类型后发现并不能成功，原来在EthernetClient发送数据时，有一个数据长度校验位，Content-Length，把这个后面的值修改为16就可以发送了。 使用正确的引脚在网上看到好像W5100和10号引脚有冲突，由于我们在第一步中获取温度就是使用10号引脚，所以后来到上传数据时，并不能显示温度了。修改为5号引脚，问题解决。然后把手指，放到传感器附近，可以看到数据的变化过程。 这里如果需要设置报警时发送微博，可以参考这篇文章：http://www.yeelink.net/developer/doc/49 本文源代码在这里：https://github.com/hust201010701/Arduino_W5100_Yeelink_Temperature 好的，这篇文章就到这里，谢谢大家。","categories":[{"name":"Arduino","slug":"Arduino","permalink":"http://www.orzangleli.com/categories/Arduino/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"http://www.orzangleli.com/tags/Arduino/"}]},{"title":"解决3ds max模型导出fbx到unity3d中蒙皮材质丢失的问题","slug":"解决3ds max模型导出fbx到unity3d中蒙皮材质丢失的问题","date":"2016-05-12T16:00:00.000Z","updated":"2016-11-03T11:19:48.200Z","comments":true,"path":"2016/05/13/解决3ds max模型导出fbx到unity3d中蒙皮材质丢失的问题/","link":"","permalink":"http://www.orzangleli.com/2016/05/13/解决3ds max模型导出fbx到unity3d中蒙皮材质丢失的问题/","excerpt":"","content":"经过大量的资料查询和测试，终于找到一种蒙皮的解决 人物蒙皮的方法： 首先，在3ds max中把max格式的模型转为fbx格式的，注意勾选嵌入媒体。 将fbx模型拖到unity中，并把模型拖到scene中，可以看到有一个子对象上面有Skinned Mesh Render组件。 新建一个材质，把贴图文件的RGB和normalmap赋值给材质，然后把材质拖到第2步的那个子对象上。 然后就发现，模型有了材质了。","categories":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/categories/unity3D/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"}]},{"title":"在unity3D 5.x中加入Kinect的骨骼追踪","slug":"在unity3D 5.x中加入Kinect的骨骼追踪","date":"2016-05-10T16:00:00.000Z","updated":"2016-11-03T11:19:48.049Z","comments":true,"path":"2016/05/11/在unity3D 5.x中加入Kinect的骨骼追踪/","link":"","permalink":"http://www.orzangleli.com/2016/05/11/在unity3D 5.x中加入Kinect的骨骼追踪/","excerpt":"","content":"this post is copied fromthenappingkat Kinect Skeleton in UnitySo most of this code is used from the SDK, however I will be going into adetailed explanation about how it all works. As well as how to put it intoUnity. First things First. Create a new Folder inside your Scripts folder CalledKinectScripts. Now in that folder create two new scripts; one calledBodyManger and the other called BodyView. BodyManager ScriptFirst we need a BodyManager script. This object will Mange the Kinect sensorconnection and read in all the body data coming from the Kinect. Import KinectLibrary with: 1 | using Windows.Kinect; —|— Then we need some fields for the manager to store and the data and get sensordata. 1 2 3 4 5 6 7 8 | private KinectSensor _Sensor; private BodyFrameReader _Reader; private Body[] _Data = ``null``; public Body[] GetData() { ``return _Data; } —|— Okay so now in the Start method we want to establish the connection for theKinect. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 | void Start() { ``_Sensor = KinectSensor.GetDefault(); ``if (_Sensor != ``null``) ``{ ``_Reader = _Sensor.BodyFrameSource.OpenReader(); ``if (!_Sensor.IsOpen) ``{ ``_Sensor.Open(); ``} ``} } —|— Now that the connection is open and reading in the data we need to store it inthe Body array. We will do this every frame of the game, therefore we need toedit the Update() method.First we check to see if the _Reader has been established and the connectionhas been completed. If it has we will take the last frame, the reader read inand if it’s not null, we can then check to see if the data is there. 1 2 3 4 5 6 7 8 9 10 11 12 13 | void Update() { ``if (_Reader != ``null``) ``{ ``var frame = _Reader.AcquireLatestFrame(); ``if (frame != ``null``) ``{ ``if (_Data == ``null``) ``{ ``} ``} ``} } —|— We still need to get the Body data from the Senor. To do this we will need tocreate a new Body array with data from the Sensor.BodyFrameSource.BodyCount.At the end the method should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 | void Update() { ``if (_Reader != ``null``) ``{ ``var frame = _Reader.AcquireLatestFrame(); ``if (frame != ``null``) ``{ ``if (_Data == ``null``) ``{ ``_Data = ``new Body[_Sensor.BodyFrameSource.BodyCount]; ``} ``} ``} } —|— Then we need to refresh the stream of data from the Reader. By adding thefollowing code to manipulate the frame. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 | void Update() { ``if (_Reader != ``null``) ``{ ``var frame = _Reader.AcquireLatestFrame(); ``if (frame != ``null``) ``{ ``if (_Data == ``null``) ``{ ``_Data = ``new Body[_Sensor.BodyFrameSource.BodyCount]; ``} ``frame.GetAndRefreshBodyData(_Data); ``frame.Dispose(); ``frame = ``null``; ``} ``} } —|— The last method in the Body Manager Class is OnApplicationQuit(), whichDisposes the Reader, and closes the Sensor stream, sets it to null. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 | void OnApplicationQuit() ``{ ``if (_Reader != ``null``) ``{ ``_Reader.Dispose(); ``_Reader = ``null``; ``} ``if (_Sensor != ``null``) ``{ ``if (_Sensor.IsOpen) ``{ ``_Sensor.Close(); ``} ``_Sensor = ``null``; ``} ``} —|— Now onto drawing the skeleton in the scene. BodyView ScriptThe next Script to write is one to draw the skeletal structure. We won’tnecessarily need to see the skeleton for the game, however, I’ll show you howto show skeletal body tracking. We also need the skeletal data to track thehands, whose state will dictate controller commands. For this MonoBehavoir class we will need, a material to draw the bone in theUnity scene. A gameobject to store the BodyManger, to control the stream ofthe Kinect. 1 2 | public Material BoneMaterial; public GameObject BodyManager; —|— We also need a BodyManager object and a Dictionary to store the bodies beingtracked. 1 2 | private Dictionary&lt;``ulong``, GameObject&gt; _Bodies = ``newDictionary&lt;``ulong``, GameObject&gt;(); private BodyManager _BodyManager; —|— Next we need to map out all the bones by the two joints that they will beconnected to. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 | private Dictionary&lt;Kinect.JointType, Kinect.JointType&gt; _BoneMap = ``newDictionary&lt;Kinect.JointType, Kinect.JointType&gt;() { ``{ Kinect.JointType.FootLeft, Kinect.JointType.AnkleLeft }, ``{ Kinect.JointType.AnkleLeft, Kinect.JointType.KneeLeft }, ``{ Kinect.JointType.KneeLeft, Kinect.JointType.HipLeft }, ``{ Kinect.JointType.HipLeft, Kinect.JointType.SpineBase }, ``{ Kinect.JointType.FootRight, Kinect.JointType.AnkleRight }, ``{ Kinect.JointType.AnkleRight, Kinect.JointType.KneeRight }, ``{ Kinect.JointType.KneeRight, Kinect.JointType.HipRight }, ``{ Kinect.JointType.HipRight, Kinect.JointType.SpineBase }, ``{ Kinect.JointType.HandTipLeft, Kinect.JointType.HandLeft }, ``//Need this for HandSates ``{ Kinect.JointType.ThumbLeft, Kinect.JointType.HandLeft }, ``{ Kinect.JointType.HandLeft, Kinect.JointType.WristLeft }, ``{ Kinect.JointType.WristLeft, Kinect.JointType.ElbowLeft }, ``{ Kinect.JointType.ElbowLeft, Kinect.JointType.ShoulderLeft }, ``{ Kinect.JointType.ShoulderLeft, Kinect.JointType.SpineShoulder }, ``{ Kinect.JointType.HandTipRight, Kinect.JointType.HandRight }, ``//Needthis for Hand State ``{ Kinect.JointType.ThumbRight, Kinect.JointType.HandRight }, ``{ Kinect.JointType.HandRight, Kinect.JointType.WristRight }, ``{ Kinect.JointType.WristRight, Kinect.JointType.ElbowRight }, ``{ Kinect.JointType.ElbowRight, Kinect.JointType.ShoulderRight }, ``{ Kinect.JointType.ShoulderRight, Kinect.JointType.SpineShoulder }, ``{ Kinect.JointType.SpineBase, Kinect.JointType.SpineMid }, ``{ Kinect.JointType.SpineMid, Kinect.JointType.SpineShoulder }, ``{ Kinect.JointType.SpineShoulder, Kinect.JointType.Neck }, ``{ Kinect.JointType.Neck, Kinect.JointType.Head }, }; —|— BodyView Update()Now in the Unity Update() method we need to check to see if the Body Manageris not null and that it has data. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 | void Update() ``{ ``int state = 0; ``if (BodyManager == ``null``) ``{ ``return``; ``} ``_BodyManager = BodyManager.GetComponent&lt;BodyManager&gt;(); ``if (_BodyManager == ``null``) ``{ ``return``; ``} ``Kinect.Body[] data = _BodyManager.GetData(); ``if (data == ``null``) ``{ ``return``; ``} ``} —|— Next, while still in the Update() method, we need to get the amount of bodiesin the list of tracked bodies. Then delete unknown bodies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 | List&lt;``ulong``&gt; trackedIds = ``new List&lt;``ulong``&gt;(); foreach (``var body ``in data) { ``if (body == ``null``) ``{ ``continue``; ``} ``if (body.IsTracked) ``{ ``trackedIds.Add(body.TrackingId); ``} } List&lt;``ulong``&gt; knownIds = ``new List&lt;``ulong``&gt;(_Bodies.Keys); // First delete untracked bodies foreach (``ulong trackingId ``in knownIds) { ``if (!trackedIds.Contains(trackingId)) ``{ ``Destroy(_Bodies[trackingId]); ``_Bodies.Remove(trackingId); ``} } —|— Now that we have the keys for tracking the bodies we need to create a bodyobject with that tracking ID key. We need to write two more methods. ACreateBodyObject() method that will take a ulong id and a RefreashBodyObject()method that will take a Kinect.Body object and a GameObject for the body. Wewill use these methods after we go through the data, and find if bodies insideare being tracked or not. If it is tracked but doesn’t have a TrackingId, thenwe need to create a body with that TrackingID. If it is being tracked and hasa TrackingId then we just need to refresh the drawn body. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 | foreach (``var body ``in data) ``{ ``if (body == ``null``) ``{ ``continue``; ``} ``if (body.IsTracked) ``{ ``if (!_Bodies.ContainsKey(body.TrackingId)) ``{ ``_Bodies[body.TrackingId] = CreateBodyObject(body.TrackingId); ``} ``RefreshBodyObject(body, _Bodies[body.TrackingId]); ``} ``} ``} —|— CreateBodyObject()The CreateBodyObject takes an ID and returns a body gameobject. So we firstneed to create a gameobject that will store the appropriate data retrieved;then we need a for loop to go through every joint to draw the body. 1 2 3 4 5 6 7 8 9 10 11 | private GameObject CreateBodyObject(``ulong id) ``{ ``GameObject body = ``new GameObject(``&quot;Body:&quot; + id); ``for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt &lt;= Kinect.JointType.ThumbRight; jt++) ``{ ``} ``return body; ``} —|— For every joint in the body we create a cube and add a lineRenderer to thatcube. The cube will be drawn at each joint while the line renderer will bedrawn to connect the joints. 1 | —|— 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 | private GameObject CreateBodyObject(``ulong id) ``{ ``GameObject body = ``new GameObject(``&quot;Body:&quot; + id); ``for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt &lt;= Kinect.JointType.ThumbRight; jt++) ``{ ``GameObject jointObj = GameObject.CreatePrimitive(PrimitiveType.Cube); ``LineRenderer lr = jointObj.AddComponent&lt;LineRenderer&gt;(); ``lr.SetVertexCount(2); ``lr.material = BoneMaterial; ``lr.SetWidth(0.05f, 0.05f); ``jointObj.transform.localScale = ``new Vector3(0.3f, 0.3f, 0.3f); ``jointObj.name = jt.ToString(); ``jointObj.transform.parent = body.transform; ``} ``return body; ``} —|— RefreashBodyObject()Now to write the ResfreshBodyObject method. In this method we need to gothrough each joint type possible just like we did in the CreateBodyObjectmethod. But this time we are passing in the current body, as well as theappropriate tracking number so we don’t draw the bones for the wrong person. 1 2 3 4 5 6 7 | private void RefreshBodyObject(Kinect.Body body, GameObject bodyObject) ``{ ``for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt &lt;= Kinect.JointType.ThumbRight; jt++) ``{ ``} ``} —|— Inside this for loop we need to get the key value pairs we made before in thebone loop for each joint. 1 2 3 4 5 6 7 8 9 10 11 12 13 | private void RefreshBodyObject(Kinect.Body body, GameObject bodyObject) ``{ ``for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt &lt;= Kinect.JointType.ThumbRight; jt++) ``{ ``Kinect.Joint sourceJoint = body.Joints[jt]; ``Kinect.Joint? targetJoint = ``null``; ``if``(_BoneMap.ContainsKey(jt)) ``{ ``targetJoint = body.Joints[_BoneMap[jt]]; ``} ``} ``} —|— We also need to update the skeletons position so it’s in the accurate place onthe screen. To do this we need to write a method to get the Vetcor3 from thesourceJoint. 1 2 3 4 | private static Vector3 GetVector3FromJoint(Kinect.Joint joint) { ``return new Vector3(joint.Position.X * 10, joint.Position.Y * 10, joint.Position.Z * 10); } —|— The scale by 10 is to enlarge the skeleton, which will make it easier to workwith. Now we have position to correct the gameObjects position. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 | private void RefreshBodyObject(Kinect.Body body, GameObject bodyObject) ``{ ``for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt &lt;= Kinect.JointType.ThumbRight; jt++) ``{ ``Kinect.Joint sourceJoint = body.Joints[jt]; ``Kinect.Joint? targetJoint = ``null``; ``if``(_BoneMap.ContainsKey(jt)) ``{ ``targetJoint = body.Joints[_BoneMap[jt]]; ``} ``Transform jointObj = bodyObject.transform.FindChild(jt.ToString()); ``jointObj.localPosition = GetVector3FromJoint(sourceJoint); ``} ``} —|— Next step in the for-loop is to get the linerenderer from the bodyObject,which was the cube we create for each joint. Then we need to see if targetjoint has a value. If it does we can then draw a line from the original jointto the target. 1 2 3 4 5 6 7 8 9 10 | LineRenderer lr = jointObj.GetComponent&lt;LineRenderer&gt;(); if``(targetJoint.HasValue) { ``lr.SetPosition(0, jointObj.localPosition); ``lr.SetPosition(1, GetVector3FromJoint(targetJoint.Value)); } else { ``lr.enabled = ``false``; } —|— Great! So we are almost done with drawing the skeleton. There is a bit moreinformation that will be helpful that the SDK gives you, which is trackingstatus. There are three states to choose from, Tracked, Inferred, orNotTracked. We can have the line renderer show us the state of tracking bychanging it’s color. To do this we need a method that will return a colorbased on the current state. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 | private static Color GetColorForState(Kinect.TrackingState state) { ``switch (state) ``{ ``case Kinect.TrackingState.Tracked: ``return Color.green; ``case Kinect.TrackingState.Inferred: ``return Color.red; ``default``: ``return Color.black; ``} } —|— Now we add one more line to the for-loop of the RefreachBodyObject method andwe are done. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 | private void RefreshBodyObject(Kinect.Body body, GameObject bodyObject) { ``for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt &lt;= Kinect.JointType.ThumbRight; jt++) ``{ ``Kinect.Joint sourceJoint = body.Joints[jt]; ``Kinect.Joint? targetJoint = ``null``; ``if (_BoneMap.ContainsKey(jt)) ``{ ``targetJoint = body.Joints[_BoneMap[jt]]; ``} ``Transform jointObj = bodyObject.transform.FindChild(jt.ToString()); ``jointObj.localPosition = GetVector3FromJoint(sourceJoint); ``LineRenderer lr = jointObj.GetComponent&lt;LineRenderer&gt;(); ``if (targetJoint.HasValue) ``{ ``lr.SetPosition(0, jointObj.localPosition); ``lr.SetPosition(1, GetVector3FromJoint(targetJoint.Value)); ``lr.SetColors(GetColorForState(sourceJoint.TrackingState), GetColorForState(targetJoint.Value.TrackingState)); ``} ``else ``{ ``lr.enabled = ``false``; ``} ``} } —|— And that’s it for drawing the skeleton! Putting the Skeleton into UnityNow in Unity I’ve created another scene by going to file new scene (it willprompt you to save your current scene if you haven’t already). This emptyscene will make it easier for you to test and see what you’re doing. In the empty scene, which I have saved as kinectTest, create two empty gameobjects. Call them Body Manager and Body View. Attach the Body Manager script to the body manager object. Attach the BodyView script to the BodyView object. Select the Body View object. In the inspector you need to fill in the BodyManager slot and Bone Material slot. Click and drag the BodyManager from thehierarchy to the slot. Then in your materials folder click and drag the BoneMaterial into the bone material slot. Now hit run. You should see nothing on your screen at first. This is becausethe Kinect hasn’t registered your skeleton yet. Stand back about 4 ft, and youshould see the skeleton appear. If you look closely you can tell that the legs of the skeleton are red. Thisis because the Kinect is interpreting that’s where my legs should be. My deskwas blocking the sensor from detecting where my legs actually were. But wait! You say. We don’t need a skeleton in our infinite runner game, justthe hand gestures and states! So was all this a waste? NO! Of course itwasn’t. We just don’t need to draw the whole skeleton in the scene anymore.But we now have the know-how if you need to in the future. YAY! The next part of this mini series will be getting those hand gestures to workin the game!","categories":[{"name":"Kinect","slug":"Kinect","permalink":"http://www.orzangleli.com/categories/Kinect/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"},{"name":"Kinect","slug":"Kinect","permalink":"http://www.orzangleli.com/tags/Kinect/"}]},{"title":"UNITY 5 AND KINECT 2 INTEGRATION (unity5 和kinect2.0整合)","slug":"UNITY 5 AND KINECT 2 INTEGRATION (unity5 和kinect2.0整合)","date":"2016-05-10T16:00:00.000Z","updated":"2016-11-03T11:19:49.651Z","comments":true,"path":"2016/05/11/UNITY 5 AND KINECT 2 INTEGRATION (unity5 和kinect2.0整合)/","link":"","permalink":"http://www.orzangleli.com/2016/05/11/UNITY 5 AND KINECT 2 INTEGRATION (unity5 和kinect2.0整合)/","excerpt":"","content":"Copied from JamesAshley . Until just this month one of the best Kinect 2 integration tools was hidden,like Rappuccini’s daughter, inside a walled garden. Microsoft released aUnity3D plugin for the Kinect 2 in 2014. Unfortunately, Unity 4 only supportedplugins (bridges to non-Unity technology) if you owned a Unity Pro licensewhich typically cost over a thousand dollars per year. On March 3rd, Unity released Unity 5 which includes plugin support in theirfree Personal edition – making it suddenly very easy to start buildingotherwise complex experiences like point cloud simulations that wouldotherwise require a decent knowledge of C++. In this post, I’ll show you howto get started with the plugin and start running a Kinect 2 application inabout 15 minutes. (As an aside, I always have trouble keeping this straight: Unity has plugins,openFrameworks as add-ins, while Cinder has bricks. Visual Studio hasextensions and add-ins as well as NuGet packages after a confusing few yearsof rebranding efforts. There may be a difference between them but I can’ttell.) 1. First you are going to need a Kinect 2 and the Unity 5 software. If youalready have a Kinect 2 attached to your XBox One, then this part is easy.You’ll just need to buy a Kinect AdapterKit from the Microsoft store. This will allow you toplug your XBox One Kinect into your PC. The Kinect for Windows 2 SDK isavailable from the K4W2website, though everything you need should automatically install when youfirst plug your Kinect into your computer. You don’t even need Visual Studiofor this. Finally, you can download Unity 5 from theUnity website. 2. The Kinect 2 plugin for Unity is a bit hard to find. You can go to thisKinect documentation page and scroll half-way down tofind the link called Unity Pro Packages. Aternatively, here is a directlink to the most currentversion of the plugin as of this writing. 3. After you finish downloading the zip file (currently calledKinectForWindows_UnityPro_2.0.1410.zip), extract it to a known location. Ilike to use $\\Documents\\Unity. Inside you will find three plugins as well astwo sample scenes. The three Kinect plugins are the basic one, a facerecognition plugin, and a gesture builder plugin, each wrapping functionalityfrom the Kinect 2 SDK. 4. Fire up Unity 5 and create a new project in your known folder. In my case,I’m creating a project called “KinectUnityProject” in the $\\Documents\\Unityfolder where I extracted the Kinect plugins and related assets. 5. Now we will add the Kinect plugin into our new project. When the Unity IDEopens, select Assets from the top menu and then select Import Package | CustomPackage … 6. Navigate to the folder where you extracted the KinectforWindows_Unitycomponents and select the Kinect2.0.xxxxx.unitypackage file. That’s our pluginalong with all the scripts needed to build a Kinect-enabled Unity 5application. After clicking on “Open”, an additional dialog window will openup in the Unity IDE called “Importing Package” with lots of files checked off.Just click on the “Import” button at the lower right corner of the dialog tofinish the import process. Two new folders will now be added to your Projectwindow under the Assets folder called Plugins and Standard Assets. This is thebaseline configuration for any Kinect project in Unity. 7. Now we’ll get a Kinect with Unity project quickly going by simply copyingone of the sample projects provided by the Microsoft Kinect team. Go into fileexplorer and copy the folder called “KinectView” out of theKinectforWindows_Unity folder where you extracted the plugins and paste itinto the Assets directory in your project folder. Then return to the Unity 5IDE. A warning message will pop up letting you know that there arecompatibility issues between the plugin and the newest version of Unity andthat files will automatically be updated. Go ahead and lie to the Unity IDE.Click on “I Made a Backup.” 8. A new folder has been added to your Project window under Assets calledKinectView. Select KinectView and then double click on the MainScene scenecontained inside it. This should open up your Kinect-enabled scene inside thegame window. Click on the single arrow near the top center of the IDE to seeyour application in action. The Kinect will automatically turn on and youshould see a color image, an infrared image, a rendering of any bodies in thescene and finally a point cloud simulation. 9. To build the app, select File | Build &amp; Run from the top menu. SelectWindows as your target platform in the next dialog and click the Build &amp;Run button at the lower right corner. Another dialog appears asking you toselect a location for your executable and a name. After selecting anexecutable name, click on Save in order to reach the final dialog window. Justaccept the default configuration options for now and click on “Play!”.Congratulations. You’ve just built your first Kinect-enabled Unity 5application!","categories":[{"name":"Kinect","slug":"Kinect","permalink":"http://www.orzangleli.com/categories/Kinect/"}],"tags":[{"name":"unity3D","slug":"unity3D","permalink":"http://www.orzangleli.com/tags/unity3D/"},{"name":"Kinect","slug":"Kinect","permalink":"http://www.orzangleli.com/tags/Kinect/"}]},{"title":"android  studio使用自定义签名文件","slug":"android  studio使用自定义签名文件","date":"2016-04-26T16:00:00.000Z","updated":"2016-11-03T11:19:48.087Z","comments":true,"path":"2016/04/27/android  studio使用自定义签名文件/","link":"","permalink":"http://www.orzangleli.com/2016/04/27/android  studio使用自定义签名文件/","excerpt":"","content":"在build.gradle中添加一段代码指定签名文件位置。 apply plugin: &apos;com.android.application&apos; android { compileSdkVersion 23 buildToolsVersion &quot;23.0.2&quot; defaultConfig { applicationId &quot;cn.go.lyqdh.carmap&quot; minSdkVersion 15 targetSdkVersion 23 versionCode 1 versionName &quot;1.0&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } sourceSets { main { jniLibs.srcDirs = [&apos;libs&apos;] } } signingConfigs { debug { storeFile file(&quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\taobao\\\\CarMap\\\\debug.keystore&quot;) } } } dependencies { compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) testCompile &apos;junit:junit:4.12&apos; compile &apos;com.android.support:appcompat-v7:23.0.1&apos; compile &apos;com.android.support:design:23.0.1&apos; compile files(&apos;libs/baidumapapi_base_v3_6_1.jar&apos;) compile files(&apos;libs/baidumapapi_map_v3_6_1.jar&apos;) compile files(&apos;libs/baidumapapi_util_v3_6_1.jar&apos;) compile files(&apos;libs/BmobSDK_V3.4.3_0820.jar&apos;) compile files(&apos;libs/locSDK_6.13.jar&apos;) compile files(&apos;libs/baidumapapi_search_v3_6_1.jar&apos;) compile &apos;com.google.android.gms:play-services-appindexing:8.1.0&apos; }","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"android studio修改包名","slug":"android studio修改包名","date":"2016-04-25T16:00:00.000Z","updated":"2016-11-03T11:19:47.407Z","comments":true,"path":"2016/04/26/android studio修改包名/","link":"","permalink":"http://www.orzangleli.com/2016/04/26/android studio修改包名/","excerpt":"","content":"android studio修改包名有点坑，右键refactor只能当前层的包的名字，不能修改前面的，只要把 ，然后在修改就可以了，修改完还要注意gradle module:app 里的ApplicationID也要修改。这点是需要注意的。 否则，当你安装的时候，他还会以为你是之前的那个软件，直接覆盖安装的。","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"google chrome 配合 postman插件，无敌","slug":"google chrome 配合 postman插件，无敌","date":"2016-04-11T16:00:00.000Z","updated":"2016-11-03T11:19:46.399Z","comments":true,"path":"2016/04/12/google chrome 配合 postman插件，无敌/","link":"","permalink":"http://www.orzangleli.com/2016/04/12/google chrome 配合 postman插件，无敌/","excerpt":"","content":"google chrome 配合 postman插件，无敌。 这个插件可以很轻松的模拟访问请求，并获取返回数据，用起来很方便，再也不用写代码去测试url了。","categories":[{"name":"api请求","slug":"api请求","permalink":"http://www.orzangleli.com/categories/api请求/"}],"tags":[{"name":"api请求","slug":"api请求","permalink":"http://www.orzangleli.com/tags/api请求/"}]},{"title":"今天终于完成了校招宝的评论功能","slug":"今天终于完成了校招宝的评论功能","date":"2016-03-30T16:00:00.000Z","updated":"2016-11-03T11:19:46.395Z","comments":true,"path":"2016/03/31/今天终于完成了校招宝的评论功能/","link":"","permalink":"http://www.orzangleli.com/2016/03/31/今天终于完成了校招宝的评论功能/","excerpt":"","content":"哎，好累，先贴个图吧，早点休息:)","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"},{"name":"其他","slug":"其他","permalink":"http://www.orzangleli.com/tags/其他/"}]},{"title":"基于Bmob云数据库的APP评论与赞的部分设计与实现","slug":"基于Bmob云数据库的APP评论与赞的部分设计与实现","date":"2016-03-29T16:00:00.000Z","updated":"2016-11-03T11:19:48.083Z","comments":true,"path":"2016/03/30/基于Bmob云数据库的APP评论与赞的部分设计与实现/","link":"","permalink":"http://www.orzangleli.com/2016/03/30/基于Bmob云数据库的APP评论与赞的部分设计与实现/","excerpt":"","content":"校招宝需要对宣讲会内容进行评论和点赞功能。这个功能实现通过bomb云数据库实现。 1、评论的实现 数据库的表结构 评论与帖子内容的对应关系是一个帖子可以有多个评论，但是一个评论实际上只属于一个帖子，也就是帖子和评论的关系是一对多的关系。如下图所示，分别对帖子和评论进行建表 帖子表的结构 likes和dislikes（准确的英文应该是dislikes） 是喜欢和讨厌的人。这两列是Relation关系的，也就是多对多。 评论表的结构 评论应该有自己的ID,作者，所属文章，评论内容和创建时间。文章和作者是一对多关系，使用Pointer类型。 好，现在表已经建立完成。 数据填充 两张表中必须有内容才能实现起来效果。我的文章内容通过代码填充如下。评论表暂时不添加，等到时候直接在app中自己添加评论。 分别对文章和评论建Bean类。 package com.orzangleli.xiaozhaobao.bean; import android.provider.ContactsContract; import cn.bmob.v3.BmobObject; import cn.bmob.v3.datatype.BmobRelation; /** * Created by 81118 on 2016/3/27. */ public class Article extends BmobObject { private String id; private String title; private String url; private BmobRelation likes; private BmobRelation dislikes; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public BmobRelation getLikes() { return likes; } public void setLikes(BmobRelation likes) { this.likes = likes; } public BmobRelation getDislikes() { return dislikes; } public void setDislikes(BmobRelation dislikes) { this.dislikes = dislikes; } } 评论类: package com.orzangleli.xiaozhaobao.bean; import cn.bmob.v3.BmobObject; import cn.bmob.v3.BmobUser; /** * Created by 81118 on 2016/3/27. */ public class Comment extends BmobObject { private BmobUser user; private Article article; private String content; public BmobUser getUser() { return user; } public void setUser(BmobUser user) { this.user = user; } public Article getArticle() { return article; } public void setArticle(Article Article) { this.article = Article; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } } 完成这两个类，然后像数据库中上传一些数据。 Article表就根据每次获取到宣讲会信息的时候，与服务器交流，试图上传到服务器，首先判断服务器上是否存在此数据的id，如果存在就不上传，否则就上传到服务器。 至此，评论模块基本搞定。","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"ToolBar 开发的理解与总结","slug":"ToolBar 开发的理解与总结","date":"2016-03-23T16:00:00.000Z","updated":"2016-11-03T11:19:44.912Z","comments":true,"path":"2016/03/24/ToolBar 开发的理解与总结/","link":"","permalink":"http://www.orzangleli.com/2016/03/24/ToolBar 开发的理解与总结/","excerpt":"","content":"Toolbar 从API 21(android 5.0) 由谷歌官方加入。以前使用ActionBar很麻烦，我还没怎么搞懂，不过现在Toolbar是一个控件了，大大地方便了开发者的自定义。 根据D_clock的 最详细的 Toolbar 开发实践总结这篇博客，我可以知道Toolbar的新特性： 设置导航栏图标； 设置App的logo； 支持设置标题和子标题； 支持添加一个或多个的自定义控件； 支持Action Menu； 下面开始正式使用： 首先是布局： &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#aa0000aa&quot;/&gt; Toolbar 可以内嵌控件，类似于LinnerLayout 。 然后在Java代码中设置相关属性： Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); //设置导航栏图标 toolbar.setNavigationIcon(R.mipmap.ic_drawer_home); //设置app logo toolbar.setLogo(R.mipmap.ic_launcher); //设置主标题 toolbar.setTitle(&quot;Title&quot;); //设置子标题 toolbar.setSubtitle(&quot;Subtitle&quot;); //设置右上角的填充菜单 toolbar.inflateMenu(R.menu.base_toolbar_menu); toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() { @Override public boolean onMenuItemClick(MenuItem item) { return true; } }); 一般来说，可以在java代码中设置属性就可以在xml中设置，但是原博主遇到了问题， &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/color_0176da&quot; android:logo=&quot;@mipmap/ic_launcher&quot; android:navigationIcon=&quot;@mipmap/ic_drawer_home&quot; android:subtitle=&quot;456&quot; android:title=&quot;123&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Clock&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; 效果如下，并没有出现想要的结果。为什么呢？ 解决方法是在根布局中添加自定义属性的命名空间，但是为什么？(这里我不太理解，以后理解在再做补充) 2016.3.23 补充： 经过网上查询，终于理解了，这个xmlns就是xml namespace的意思，后面跟的内容可以理解为自定义字符串， xmlns:toolbar=&quot;http://schemas.android.com/apk/res-auto&quot; 完全可以修改 xmlns:toolbar=&quot;http://schemas.android.com/apk/mytoolbar&quot; 因为toolbar下面有这几个属性： navigationIcon logo subtitle title 这个属性并不是android下面的，而且有些属性可能在android这个命名空间里也有，所以区分下。 2016.03.24补充：经过测试，在androidstudio中自定义控件的命名空间都必须为xmlns:toolbar=”http://schemas.android.com/apk/res-auto” 。需要注意下。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:toolbar=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/color_0176da&quot; toolbar:navigationIcon=&quot;@mipmap/ic_drawer_home&quot; toolbar:logo=&quot;@mipmap/ic_launcher&quot; toolbar:subtitle=&quot;456&quot; toolbar:title=&quot;123&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Clock&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/LinearLayout&gt; 然后就可以出现正确结果。 由于这个包是向下兼容的，所以在API21以下还要设置这样一句： if(Build.VERSION.SDK_INT &lt; 21) requestWindowFeature(Window.FEATURE_NO_TITLE); 修改APPTheme主题： &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot; /&gt;","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"genymotion 安装后无法启动","slug":"genymotion 安装后无法启动","date":"2016-03-22T16:00:00.000Z","updated":"2016-11-03T11:19:46.405Z","comments":true,"path":"2016/03/23/genymotion 安装后无法启动/","link":"","permalink":"http://www.orzangleli.com/2016/03/23/genymotion 安装后无法启动/","excerpt":"","content":"今天跟genymotion杠上了，我安装后打开提示我无法运行，气死我了。 在网上搜索，看到了一大堆问题，现在把我的过程给演示一遍。 首先安装genymotion 链接：http://pan.baidu.com/s/1hqXWV2G 密码：pbn5 安装完成后不可以运行，这时候，属性-兼容性 修改为win7以外的就行。 然后genymotion还是不能启动新的模拟器，单独在virtualbox中也是不行，出现了上图的错误，这个错误纠结了很久都没有搞好。 最后把genymotion 自带的vitrualbox卸载 了，然后安装刚刚百度云里面的4.3.6版本的就可以了。 附上一张完美运行图。PS :有时候会发现genymotion的标题栏超出的屏幕的边界，无法移动和关闭，这时候按住Alt+Space然后按M键，再按住方向键上下调位置即可。 2016年3月23日更新：另外可能遇到genymotion被墙的问题，在网站 http://www.xicidaili.com/wt/中找美国的节点，在设置里设置代理就可以成功登陆了。","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"NavigationView 设置头像  headlayout","slug":"NavigationView 设置头像  headlayout","date":"2016-03-15T16:00:00.000Z","updated":"2016-11-03T11:19:46.557Z","comments":true,"path":"2016/03/16/NavigationView 设置头像  headlayout/","link":"","permalink":"http://www.orzangleli.com/2016/03/16/NavigationView 设置头像  headlayout/","excerpt":"","content":"这是android Meterial Design中的NavigationView ，这个配合DrawLayout 可以实现侧滑菜单的功能。 之所以使用这个控件是因为他可以很方便的对菜单进行分类，很清晰。 本来我想加入一个自己的head部分，但是尝试了好久之后，发现NavigationView上面始终有个嘿嘿的部分，这个部分的高度应该正好等于状态栏的高度，后来我在网上查资料无意发现，原来google早就帮我想好了，有一个属性，headlayout。 代码如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:openDrawer=&quot;start&quot; &gt; &lt;include layout=&quot;@layout/app_bar_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/nav_view&quot; android:layout_width=&quot;240dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:headerLayout=&quot;@layout/drawerlayout_me&quot; app:menu=&quot;@menu/activity_main_drawer&quot; /&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; 效果如下： 哈哈，这也是我的第一篇博客啦。呜啦啦。","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"SwipeRefreshLayout  android 官方下拉刷新控件使用","slug":"SwipeRefreshLayout  android 官方下拉刷新控件使用","date":"2016-03-15T16:00:00.000Z","updated":"2016-11-03T11:19:45.222Z","comments":true,"path":"2016/03/16/SwipeRefreshLayout  android 官方下拉刷新控件使用/","link":"","permalink":"http://www.orzangleli.com/2016/03/16/SwipeRefreshLayout  android 官方下拉刷新控件使用/","excerpt":"","content":"下拉列表刷新使用非常多。记录下使用SwipeRefreshLayout 控件。 首先在布局中定义SwipeRefreshLayout ，这个layout可以包含一个ListView 。当ListView 下拉刷新的时候，实际上会触发SwipeRefreshLayout的 OnRefreshListener方法。 布局代码如下： &lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/swiperefresh&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ListView android:id=&quot;@android:id/list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 在java代码中，先找到这个控件。 mSwipeRefreshLayout = (SwipeRefreshLayout) view.findViewById(R.id.swiperefresh); // BEGIN_INCLUDE (change_colors) // Set the color scheme of the SwipeRefreshLayout by providing 4 color resource ids mSwipeRefreshLayout.setColorScheme( R.color.swipe_color_1, R.color.swipe_color_2, R.color.swipe_color_3, R.color.swipe_color_4); // END_INCLUDE (change_colors) 然后添加监听 private void initiateRefresh() { Log.i(LOG_TAG, &quot;initiateRefresh&quot;); /** * Execute the background task, which uses {@link android.os.AsyncTask} to load the data. */ new DummyBackgroundTask().execute(); } private class DummyBackgroundTask extends AsyncTask&lt;Void, Void, List&lt;String&gt;&gt; { static final int TASK_DURATION = 3 * 1000; // 3 seconds @Override protected List&lt;String&gt; doInBackground(Void... params) { // Sleep for a small amount of time to simulate a background-task try { Thread.sleep(TASK_DURATION); } catch (InterruptedException e) { e.printStackTrace(); } // Return a new random list of cheeses return Cheeses.randomList(LIST_ITEM_COUNT); } @Override protected void onPostExecute(List&lt;String&gt; result) { super.onPostExecute(result); // Tell the Fragment that the refresh has completed onRefreshComplete(result); } } private void onRefreshComplete(List&lt;String&gt; result) { Log.i(LOG_TAG, &quot;onRefreshComplete&quot;); // Remove all items from the ListAdapter, and then replace them with the new items mListAdapter.clear(); for (String cheese : result) { mListAdapter.add(cheese); } // Stop the refreshing indicator mSwipeRefreshLayout.setRefreshing(false); } 其中有一句代码： mSwipeRefreshLayout.setRefreshing(false); 这个就是控制SwipeRefreshLayout这个布局前面的加载进度条的显示与否的。","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]},{"title":"使用jitpack.io 依赖github第三方库","slug":"使用jitpack.io 依赖github第三方库","date":"2016-03-15T16:00:00.000Z","updated":"2016-11-03T11:19:45.068Z","comments":true,"path":"2016/03/16/使用jitpack.io 依赖github第三方库/","link":"","permalink":"http://www.orzangleli.com/2016/03/16/使用jitpack.io 依赖github第三方库/","excerpt":"","content":"github上有那么多好用的库，有些写的很详细，怎么在工程中引用依赖，有的则没有写。 比如，我最近看的一个项目，CircleRefreshLayout，则没有写怎么依赖，而我又不想把它下载下来。 这时候使用jitpack.io ，填入项目名称 选择版本，一般是最后一个版本咯 在自己的androidstudio中添加这个依赖就可以了。中间我的工程出了个错，是说第三行错，因为引用的工程的mipmap下面也有一个ic_launcher，修改为mipmap的路径在gradle下就没有错了。 &lt;application android:allowBackup=&quot;true&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; 最后效果：（genymotion + Gif 录制工具） 使用7牛传输来的，不知道为什么上传到wordpress就会出错","categories":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.orzangleli.com/tags/android/"}]}]}