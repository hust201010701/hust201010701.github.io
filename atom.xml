<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>orzangleli</title>
  <subtitle>活在梦里的程序员和设计师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.orzangleli.com/"/>
  <updated>2017-01-10T14:12:03.524Z</updated>
  <id>http://www.orzangleli.com/</id>
  
  <author>
    <name>orzangleli</name>
    <email>orzangleli@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python节日倒计时软件</title>
    <link href="http://www.orzangleli.com/2017/01/07/2017-01-07_Python%E8%8A%82%E6%97%A5%E5%80%92%E8%AE%A1%E6%97%B6%E8%BD%AF%E4%BB%B6/"/>
    <id>http://www.orzangleli.com/2017/01/07/2017-01-07_Python节日倒计时软件/</id>
    <published>2017-01-06T16:00:00.000Z</published>
    <updated>2017-01-10T14:12:03.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-节日倒计时软件制作"><a href="#Python-节日倒计时软件制作" class="headerlink" title="Python 节日倒计时软件制作"></a>Python 节日倒计时软件制作</h1><h2 id="一-项目描述"><a href="#一-项目描述" class="headerlink" title="一. 项目描述"></a>一. 项目描述</h2><p>本次项目以Python3 作为编程语言，制作一款能够倒计时节日的图形化软件。</p>
<h3 id="1-1-项目动机"><a href="#1-1-项目动机" class="headerlink" title="1.1 项目动机"></a>1.1 项目动机</h3><p>本次项目的开发动机是：</p>
<blockquote>
<p>我想做一个类似于微博上 <a href="http://weibo.com/p/1005052493180882/home?profile_ftype=1&amp;is_all=1#_0" target="_blank" rel="external">@古城钟楼</a> 的报时程序，只是我报的时间是节日的倒计时，还想加上 “历史上的今天” 的功能。我关注的一个博主 <a href="http://weibo.com/xinlangwx?refer_flag=1001030101_" target="_blank" rel="external">@新浪无锡</a> 这位小编也会做一个倒计时的话题的微博，我问他是怎么做的，他跟我说他是数出来的，然后我就想帮帮他并且自己也练习练习，于是就想着开发一款这样的软件。<br>同时，也欢迎大家关注我的微博 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzangleli</a></p>
</blockquote>
<h3 id="1-2-知识点"><a href="#1-2-知识点" class="headerlink" title="1.2 知识点"></a>1.2 知识点</h3><ol>
<li>PyQt5库</li>
<li>requests库</li>
<li>datetime库</li>
<li>BeautifulSoup库</li>
</ol>
<h3 id="1-3-效果截图"><a href="#1-3-效果截图" class="headerlink" title="1.3 效果截图"></a>1.3 效果截图</h3><p>默认选中最近一个月的所有传统节日和24节气。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-07_17_26_01_daojishi.png" alt=""></p>
<h2 id="二、附加依赖安装"><a href="#二、附加依赖安装" class="headerlink" title="二、附加依赖安装"></a>二、附加依赖安装</h2><h3 id="2-1-PyQt安装"><a href="#2-1-PyQt安装" class="headerlink" title="2.1 PyQt安装"></a>2.1 PyQt安装</h3><p>Qt 是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱。也可用于开发非GUI程序，比如控制台工具和服务器。</p>
<p>参考：<a href="https://zh.wikipedia.org/wiki/Qt" target="_blank" rel="external">wiki–Qt</a></p>
<h4 id="2-1-1-Windows平台"><a href="#2-1-1-Windows平台" class="headerlink" title="2.1.1 Windows平台"></a>2.1.1 Windows平台</h4><p>首先下载PyQt5,注意不要下载最新版v5.7.1，最新版目前只有源码，没有可执行(exe)安装包，推荐安装和我相同的版本。进入<a href="https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/" target="_blank" rel="external">https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/</a> 下载 PyQt GPL v5.4.1 for Pythonv3.4(x64) 。注意到底是下载x86还是x64请根据自己系统的位数决定，这里需要注意的是：<strong>Python版本的位数需要跟系统保持一致，也就是如果你是64位系统，请一定要安装64位的Python</strong></p>
<p>关于Python版本：</p>
<p>我之前使用的是Python3.5，然后知道引用pyqt库时会一直出错，最后发现Python3.5和PyQt5好像是不兼容的，因为从上面的链接<a href="https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/" target="_blank" rel="external">https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/</a>，打开网址就可以看到，人家只适配了Python 3.4版本的，所以乖乖的降级使用吧~</p>
<h4 id="2-1-2-Linux平台"><a href="#2-1-2-Linux平台" class="headerlink" title="2.1.2 Linux平台"></a>2.1.2 Linux平台</h4><p>如果 Linux 中默认的 python 3 为 3.5 版本，可以通过以下指令切换到 3.4 。</p>
<pre><code>$ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.4 70 --slave /usr/bin/python3m python3m /usr/bin/python3.4m
</code></pre><p>安装 PyQt5 。</p>
<pre><code>$ sudo apt-get install python3-pyqt5
</code></pre><p>安装完成之后，立马进入 Python 命令行交互界面测试是否正确安装。</p>
<pre><code>&gt;&gt;&gt; import PyQt5
</code></pre><p>如果执行以上的命令没有任何提示，说明成功安装。</p>
<h3 id="2-2-requests库安装"><a href="#2-2-requests库安装" class="headerlink" title="2.2 requests库安装"></a>2.2 requests库安装</h3><p>在cmd命令行中输入 <code>pip install requests</code></p>
<h3 id="2-3-datetime库"><a href="#2-3-datetime库" class="headerlink" title="2.3 datetime库"></a>2.3 datetime库</h3><p>datetime库不用安装，是Python自带的</p>
<h3 id="2-4-BeautifulSoup库"><a href="#2-4-BeautifulSoup库" class="headerlink" title="2.4 BeautifulSoup库"></a>2.4 BeautifulSoup库</h3><pre><code>pip install bs4
</code></pre><h2 id="三、编程实现"><a href="#三、编程实现" class="headerlink" title="三、编程实现"></a>三、编程实现</h2><h3 id="3-1-datetime使用"><a href="#3-1-datetime使用" class="headerlink" title="3.1 datetime使用"></a>3.1 datetime使用</h3><p>因为要计算倒计时，所以需要知道今天的日期，而且要计算两个日期之前有多少天。</p>
<p><strong>获取当前时间</strong></p>
<pre><code>from datetime import date
now = date.today()
print(now.strftime(&quot;%Y-%m-%d&quot;))
</code></pre><p><strong>获取日期差</strong></p>
<pre><code>from datetime import date
now = date.today()
chunjie = date(2017,1,28)  #春节的日期
chazhi = chunjie - now     #相差时间
print(chazhi.days)         #只需要知道相差时间的天数
</code></pre><p>现在只要的datetime的这两个用法就够了，其他的如果有兴趣可以去 <a href="http://www.wklken.me/posts/2015/03/03/python-base-datetime.html#1-datetime" target="_blank" rel="external">这里</a> 查看。</p>
<h3 id="3-2-requests库"><a href="#3-2-requests库" class="headerlink" title="3.2 requests库"></a>3.2 requests库</h3><p>因为我们要计算节日倒计时必须要知道今年哪些天是节日，而且节日数目比较多，程序员总不能一个个地手动添加到程序中吧，所以我们选择一个可以看到全年节日的网站<a href="http://tools.2345.com/jieri.htm" target="_blank" rel="external">http://tools.2345.com/jieri.htm</a> ，别看2345流氓软件一大堆，2345实用查询还是有点用的。</p>
<p>首先准备一个节日的Entity 类</p>
<pre><code>from datetime import date


class DayEntity(object):
    def __init__(self,dateStr,festival,type):
        self.dateStr = &quot;2017/&quot;+dateStr
        self.year = int(self.dateStr.split(&quot;/&quot;)[0])
        self.month = int(self.dateStr.split(&quot;/&quot;)[1])
        self.day = int(self.dateStr.split(&quot;/&quot;)[2])
        self.festival = festival
        self.type = type

    def getDate(self):
        d = date(self.year,self.month,self.day)
        return d

    def getDateString(self):
        return str(self.year)+&quot;年&quot;+str(self.month)+&quot;月&quot;+str(self.day)+&quot;日&quot;

    def getFestival(self):
        return self.festival

    def getType(self):
        return self.type
</code></pre><p>添加所有的节日，包括最后添加高考和考研日期</p>
<pre><code>result = requests.get(&quot;http://tools.2345.com/jieri.htm&quot;)
html_data = result.content.decode(&quot;gb2312&quot;)
soup = BeautifulSoup(html_data,&quot;html5lib&quot;)
year = soup.find(&quot;div&quot;,class_ = &quot;jieri&quot;)
clearfix = year.find_all(&quot;dl&quot;,class_=&quot;clearfix&quot;)
allFestival = list()

for month in clearfix:
    days = month.find(&quot;dd&quot;).find(&quot;ul&quot;).find_all(&quot;li&quot;)
    for day in days:
        a_tag = day.find(&quot;a&quot;)
        type = &quot;中国传统节日&quot;
        if &quot;cRed&quot; in str(a_tag[&quot;class&quot;]):
            type = &quot;中国传统节日&quot;
        elif &quot;cGreen&quot; in str(a_tag[&quot;class&quot;]):
            type = &quot;公众 / 国际节日&quot;
        elif &quot;cBlue&quot; in str(a_tag[&quot;class&quot;]):
            type = &quot;24节气&quot;
        else:
            type = &quot;中国传统节日&quot;
        dayEntity = DayEntity(day.text.split(&quot;[&quot;)[1][:-1],day.text.split(&quot;[&quot;)[0],type)
        allFestival.append(dayEntity)

allFestival.append(DayEntity(&quot;6/7&quot;,&quot;2017高考&quot;,&quot;中国传统节日&quot;))
allFestival.append(DayEntity(&quot;12/24&quot;, &quot;2017考研&quot;, &quot;中国传统节日&quot;))
</code></pre><h3 id="3-3-Qt界面"><a href="#3-3-Qt界面" class="headerlink" title="3.3 Qt界面"></a>3.3 Qt界面</h3><p>最终要做出来的程序是需要有界面的，而不是终端中显示结果，所以需要使用Qt进行界面设计。</p>
<h4 id="3-3-1-Pycharm中PyQt5的配置"><a href="#3-3-1-Pycharm中PyQt5的配置" class="headerlink" title="3.3.1 Pycharm中PyQt5的配置"></a>3.3.1 Pycharm中PyQt5的配置</h4><p>主要是添加三个External Tool,具体添加教程可以参考 <a href="http://blog.csdn.net/a359680405/article/details/45074761" target="_blank" rel="external">http://blog.csdn.net/a359680405/article/details/45074761</a></p>
<h4 id="3-3-2-使用QtDesigner-设计界面"><a href="#3-3-2-使用QtDesigner-设计界面" class="headerlink" title="3.3.2 使用QtDesigner 设计界面"></a>3.3.2 使用QtDesigner 设计界面</h4><p>在项目名上右键选择external tool打开<code>qtdesiginer</code> .</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_14_55_39_qtdesigner.png" alt=""></p>
<p> 这是图形化设计界面的工具，可以直接在窗口中拖动控件，并会保存为.ui格式。如图所示，设计界面。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_14_58_33_jiemian.png" alt=""></p>
<p>对象结构如下所示：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_14_57_44_jiegou.png" alt=""></p>
<p>保存文件，生成的文件形如 <code>window.ui</code> .</p>
<h4 id="3-3-3-使用QtDesigner-设计界面"><a href="#3-3-3-使用QtDesigner-设计界面" class="headerlink" title="3.3.3 使用QtDesigner 设计界面"></a>3.3.3 使用QtDesigner 设计界面</h4><p>在生成的 <code>window.ui</code> 上右键，选择external tool中的PyUIC,然后会自动生成window.py文件，打开后可以看到，里面是UI的程序。</p>
<h4 id="3-3-4-打包资源"><a href="#3-3-4-打包资源" class="headerlink" title="3.3.4 打包资源"></a>3.3.4 打包资源</h4><p>需要注意的是，如果程序中使用到了图片资源，虽然可以直接引用图片的资源文件，如下面的代码：</p>
<pre><code>self.buttonList[i].setStyleSheet(&quot;background-image:url(checked.png)&quot;)
</code></pre><p><code>checked.png</code> 是放在项目根目录下的一个图片资源，直接运行是没有问题的，但是如果打包程序，在生成的dist文件夹中只有exe文件，并没有<code>checked.png</code>资源，运行就会没有效果甚至出错，当然你可以把图片复制到dist文件中，但是如果图片很多呢？而且也不便于传播，一个完整exe程序，双击打开就能用是最好的。</p>
<p>所以就需要使用qt的资源包，在qtdesigner中右下角的资源浏览器中，点击“铅笔”图标，添加资源文件。然后点击新建资源文件（弹出的对话框中有6个图标，第一个是新建资源文件），然后点击添加新前缀，取个名字如button,然后选中刚刚新建的button这个前缀，添加文件（倒数第二个图标），这样把需要用到的图标添加进去，可以自己根据需要调整分类。添加好之后的资源文件形如下图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_15_12_14_ziyuan.png" alt=""></p>
<h4 id="3-3-5-显示窗口"><a href="#3-3-5-显示窗口" class="headerlink" title="3.3.5 显示窗口"></a>3.3.5 显示窗口</h4><p>在主入口文件中 定义一个窗口类。</p>
<pre><code>class MainWindow(QMainWindow):
    def __init__(self,allFestival,parent = None):
        QMainWindow.__init__(self,parent)
        self.ui = Ui_mainWindow()
        self.ui.setupUi(self)
        self.ui.setFestivalList(allFestival)
        for festival in allFestival:
            text = festival.getFestival()+&quot;\n&quot;+festival.getDateString()
            left_date = festival.getDate() - now
            if left_date.days &gt; 0  and left_date.days &lt; 30 and festival.getType() != &quot;公众 / 国际节日&quot;:
                self.ui.addWidgetIntoGridLayout(text,True)
            else:
                self.ui.addWidgetIntoGridLayout(text, False)

app = QApplication(sys.argv)
mainWindow = MainWindow(allFestival)
mainWindow.show()
app.exec_()
</code></pre><p>其中addWidgetIntoGridLayout是我自己在Window.py中添加的一个函数，主要目的是动态添加一个按钮到GridLayout中</p>
<pre><code>def addWidgetIntoGridLayout(self,text,state):
    button = QtWidgets.QPushButton(text)

    if self.currentColumn &lt; self.maxColumn - 1:
        self.currentColumn = self.currentColumn + 1
    else:
        self.currentRow = self.currentRow + 1
        self.currentColumn = 0
    if state:
        button.setStyleSheet(&quot;background-image:url(:checkbox/checked.png)&quot;)
    else:
        button.setStyleSheet(&quot;background-image:none&quot;)
    button.setObjectName(str(self.currentRow*self.maxColumn + self.currentColumn))
    button.clicked.connect(lambda: self.changeState(int(button.objectName())))
    self.buttonList.append(button)
    self.gridLayout.addWidget(button, self.currentRow, self.currentColumn)
    self.stateList.append(state)
</code></pre><h4 id="3-3-6-统计倒计时结果"><a href="#3-3-6-统计倒计时结果" class="headerlink" title="3.3.6 统计倒计时结果"></a>3.3.6 统计倒计时结果</h4><p>程序中使用了一个list来保存GridLayout中所有的按钮的状态，点击一次按钮时为选中状态，再点击一次就会变成非选中状态。<br>还是用了一个festivalList保存所有的节日信息。<br>点击计算倒计时按钮的时候，就会遍历这个list,如果button为选中状态，那么根据按钮的下标在festivalList查询中查询节日信息，从而计算倒计时时间，具体代码：</p>
<pre><code>def calculate(self):
    now = date.today()
    flag = True
    resultStr = &quot;今天是&quot;+str(now.year)+&quot;年&quot;+str(now.month)+&quot;月&quot;+str(now.day)+&quot;日，星期&quot;+self.getChineseStr(now.weekday())+&quot;。今天&quot;
    for i in range(len(self.stateList)):
        if self.stateList[i]:
            festival = self.festivalList[i]
            resultStr += &quot;距%s还有%d天,&quot;%(festival.getFestival(),(festival.getDate() - now).days)
        if now == self.festivalList[i].getDate() and flag:
            resultStr = &quot;今天是&quot; + str(now.year) + &quot;年&quot; + str(now.month) + &quot;月&quot; + str(
                now.day) + &quot;日，星期&quot; + self.getChineseStr(now.weekday()) + &quot;。今天是&quot;+self.festivalList[i].getFestival()+&quot;。今天&quot;
            flag = False
    resultStr = resultStr[:-1]+&quot;。&quot;
    self.textEdit.clear()
    self.textEdit.append(resultStr)
</code></pre><h2 id="四-程序发布"><a href="#四-程序发布" class="headerlink" title="四. 程序发布"></a>四. 程序发布</h2><h3 id="4-1-安装PyInstaller"><a href="#4-1-安装PyInstaller" class="headerlink" title="4.1 安装PyInstaller"></a>4.1 安装PyInstaller</h3><p>使用 <code>pip install pyinstaller</code>安装 PyInstaller.</p>
<h3 id="4-2-打包程序"><a href="#4-2-打包程序" class="headerlink" title="4.2 打包程序"></a>4.2 打包程序</h3><p>首先注意打包过程可能出现各种错误，先做好心理准备。</p>
<p>按照网络上的一般教程，使用pyqt库时候，一般是在主入口文件中添加，无论这个文件是否使用到，都需要导入以下库：</p>
<pre><code>from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
</code></pre><p>但是这样，在我的机器上是无法成功打包程序的，经常之前大量的尝试和搜索，找到了解决方案，需要在上面的库之前再加上一行：</p>
<pre><code>from PyQt5 import *
</code></pre><p>告诉打包程序需要使用PyQt5.</p>
<p>打包命令使用  </p>
<pre><code>pyinstaller --hidden-import queue -F -w GetFestivalDate.py
</code></pre><p>其中<code>--hidden-import queue</code> 很重要，如果不加上，可以生成exe但是运行时会闪退。</p>
<ul>
<li>-F 代表生成一个整体exe文件.</li>
<li>-w 代表生成的是图形化程序，对应-c 代表控制台程序。</li>
</ul>
<p>然后在生成的dist文件夹下就能找到生成的exe文件了，赶紧双击打开试试吧。生成的exe是可以直接拷贝到其他电脑运行的，只是需要注意的是，如果运行的系统的位数需要和你打包程序时的系统一致。</p>
<h2 id="五-后记"><a href="#五-后记" class="headerlink" title="五.后记"></a>五.后记</h2><p>以上就是整个程序的开发过程，特记录下来，有两个目的，一个是希望后来的初学者不要步入这些坑了，另一个是帮助自己记录这些细节，方便以后查阅。</p>
<p>代码我上传到Github上了，欢迎大家Star her和 Follow me.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-节日倒计时软件制作&quot;&gt;&lt;a href=&quot;#Python-节日倒计时软件制作&quot; class=&quot;headerlink&quot; title=&quot;Python 节日倒计时软件制作&quot;&gt;&lt;/a&gt;Python 节日倒计时软件制作&lt;/h1&gt;&lt;h2 id=&quot;一-项目描述&quot;&gt;&lt;
    
    </summary>
    
      <category term="Python" scheme="http://www.orzangleli.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.orzangleli.com/tags/Python/"/>
    
      <category term="软件" scheme="http://www.orzangleli.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结</title>
    <link href="http://www.orzangleli.com/2016/12/29/2016-12-29_2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://www.orzangleli.com/2016/12/29/2016-12-29_2016年度总结/</id>
    <published>2016-12-28T16:00:00.000Z</published>
    <updated>2017-01-10T14:13:17.551Z</updated>
    
    <content type="html"><![CDATA[<p>今年做了四件事：</p>
<ol>
<li><p>找工作</p>
</li>
<li><p>Android </p>
</li>
<li><p>Unity</p>
</li>
<li><p>Python</p>
</li>
</ol>
<h2 id="1-找工作"><a href="#1-找工作" class="headerlink" title="1. 找工作"></a>1. 找工作</h2><p>今年9月份开始回的武汉找工作，到11月份回无锡，正好两个月时间。因为9月份就找到了比较合适的，所以找工作主要集中在9月份，10月份在武汉基本没怎么去面试，就在剩下的时间里开始了自学Python。</p>
<p>一共找到以下几家公司的Offer,在我所在的学院里，既不算多的，也不算好的。</p>
<ol>
<li>斗鱼TV      <em>一家总部在武汉的视频直播公司，以前一家独大</em></li>
<li>中兴   <em>面试的岗位是移动开发工程师，主要觉得没有发展前景</em></li>
<li>58同城  <em>在北京，远，岗位挺好的，转转里的Android开发</em></li>
<li>华信证券  <em>在上海，工资一般，但是android团队竟然只有4个人，感觉没有任何希望</em></li>
<li>善行医疗  <em>在深圳，做医疗VR的，但是工资低</em></li>
</ol>
<p>以上几家公司，我选择了58同城，因为相对来说，它是技术上能够拿得有进步的，而且前景也比较好，虽然公司前景跟个人没啥根本利益关系，但是在一家有互联网氛围的公司学习工作也是一种好的体验。</p>
<h2 id="2-Android"><a href="#2-Android" class="headerlink" title="2. Android"></a>2. Android</h2><p>今年基本上结束了前几年开发android的方式，前几年是利用老的技术不断去开发各种APP,然后上传到应用市场，拿去售卖，再获得广告收入。<br>改变的原因有两个：一方面，我认为加广告对用户体验有很大影响，不愿意使用广告；另一方面，这些广告的收入也是很微薄。所以我就没有必要去为了挣钱去做那些没有特殊意义，为了迎合别人的APP了，我要做我自己想做的APP，学自己想学的技术。</p>
<p>今年Android方面的热门技术都有一些大致的了解：</p>
<ul>
<li>图片加载库： UIL,Picasso,Glide,Fresco.</li>
<li>网络通信库： Volley,OkHttp,NoHttp</li>
<li>MultiDex与热修复: 阿里的AndFix，QQ空间的HotFix,微信的Tinker（还没了解） </li>
</ul>
<h3 id="1-开源控件"><a href="#1-开源控件" class="headerlink" title="1. 开源控件"></a>1. 开源控件</h3><p>自己也还写了几个开源控件，都上传都Github上了，Github上的图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_27_34_github_contributions.png" alt=""></p>
<p><strong>1.<a href="https://github.com/hust201010701/RoateIndicatorViewDemo" target="_blank" rel="external">RoateIndicatorViewDemo</a></strong></p>
<p>高仿转转APP中的轮播图片的指示器</p>
<p><img src="http://lxctest.qiniudn.com/2016-11-10_15:57:31_zhuanzhuan2.webp" alt=""></p>
<p><strong>2.<a href="https://github.com/hust201010701/Danmu" target="_blank" rel="external">Danmu</a></strong></p>
<p>弹幕控件，可以切换弹幕水平/竖直运动方向,可以控制弹幕正向/逆向运动</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_09_04_danmu.gif" alt=""></p>
<p><strong>3. <a href="https://github.com/hust201010701/CouponView" target="_blank" rel="external">CouponView</a></strong></p>
<p>卡券视图: CouponView 是一个继承自LinearLayout的布局View,边缘可以实现自动裁剪效果，所以用来做优惠券等视图效果很好。</p>
<p><img src="http://i.imgur.com/pj4XTxr.png" alt=""></p>
<h3 id="2-Android项目"><a href="#2-Android项目" class="headerlink" title="2. Android项目"></a>2. Android项目</h3><p><strong>1. Hust-Wuxi 考勤查询系统</strong></p>
<p>因为官方的APP中，没有给考勤查询的功能，要查看考勤只能登陆网页，这很不方便，所以我通过分析网络请求找到了查询的API，然后自己写了一个客户端，用颜色标识考勤结果。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_09_04_kaoqin1.png" alt=""><br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_09_04_kaoqin2.png" alt=""><br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_08_55_kaoqin3.png" alt=""></p>
<p><strong>2. 校招宝</strong></p>
<p>一款获取海投网上宣讲会数据的APP,自己利用Bmob增加了评论和收藏的功能。海投网API老是变，我这会写总结的时候，APP又挂了。</p>
<p><strong>3. LOL视频宝</strong></p>
<p>这款软件使用了Python爬虫获取多玩饭盒APP中LOL视频资源，然后存到LeanCloud云端数据库，android端再通过SDK获取云端数据库资源。还未发布，目前正在内测和修改中。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol1.png" alt=""></p>
<p>主页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol2.png" alt=""></p>
<p>关注页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol3.png" alt=""></p>
<p>详情页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol4.png" alt=""></p>
<p>下载页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol5.png" alt=""></p>
<p>首页菜单</p>
<h2 id="3-Unity3D"><a href="#3-Unity3D" class="headerlink" title="3. Unity3D"></a>3. Unity3D</h2><p>今年的主要任务也是Unity3D,本身是一款游戏引擎，我们拿来做工业VR应用也是可以的。<br>因为一直没有接到正式的项目，所以在探索与尝试加上导师的指示中做了以下几点工作：</p>
<p><strong>1. TQ的发动机装配生产线的监控系统</strong></p>
<p>因为没有传感器数据，自己根据动画生成了数据库，然后又根据这些数据来模拟车间机械结构动作，只是模型好像有点问题，播放起来有点卡。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_13_39_tq1.png" alt=""></p>
<p><strong>2. 某起重机的模拟</strong></p>
<p>这个做了两个项目，一个是在Oculus Rift Dk2下做的，因为oculus这款不带交互设备，只能通过目光中心选取物体，所以动画都是半自动的，点一个按钮，动画就会播放，不可以控制运动过程。</p>
<p>后面Htc Vive眼镜到货了，就开始使用这款眼镜，自带定位器和控制器，所以利用了这个做了一个可以控制运动过程的系统，而且还单独配了一套使用LeapMotion的系统，可以用手直接操作VR场景中的物体。</p>
<p><strong>3. 车床切削过程的VR模拟系统</strong></p>
<p>选取了一款简单的车床，模拟车削加工过程。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_13_39_chexie.png" alt=""></p>
<p><strong>4. 发动机侧护板装配VR系统</strong></p>
<p>在VR系统中操作吊机完成侧护板的装配，还可以监控车间的状态参数。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_13_39_cehuban.png" alt=""></p>
<h2 id="4-Python"><a href="#4-Python" class="headerlink" title="4. Python"></a>4. Python</h2><p>有人说，人生苦短，我用Python. 真的，自从11月份开始学习Python来，我越来越认同这个观点。Python的强大第三方库，让我渐渐见识到一个新的世界。</p>
<p><strong>1. 七牛文件上传器</strong></p>
<p>利用七牛云，可以把电脑上的文件上传到云空间中，对于图片还可以自动生成Markdown格式外链，方便写博客的时候插入链接，我这篇文章用的就是自己的软件上传的图片。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/8cb58cc2gw1faq1vvmv5gj20vh0ho0y3.jpg" alt=""></p>
<p><strong>2. 博客迁移爬虫</strong></p>
<p>之前的博客在主机公园上，真的差，打开首页都要10几秒，后来用了Hexo+Github Pages.<br>要是一份份的复制粘贴之前的博客文章也是效率低，于是写了一个爬虫将博客文章，按照日期保存到本地。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_30_49_blogqianyi.png" alt=""></p>
<p><strong>3. LOL视频宝的视频数据爬虫</strong></p>
<p> 之前本来想在年前做一款新闻阅读APP的，至于为什么要改成做LOL视频咨询客户端，原因如下：</p>
<blockquote>
<p>因为我认为一款新闻客户端是否优秀不在于它交互方式或者UI多么炫酷，而在于新闻的内在质量和推荐算法，就算我能够爬到很多新闻源，也不能将它们堆砌的提交给用户，这是对用户不负责任，所以筛选算法和推荐算法很重要，出于能力问题，这一块我决定放弃。</p>
<p>为什么我要做LOL视频合集，因为现在在PC上找不到完整的LOL分类，大都是零散的，混乱的，不便于用户使用；而目前APP上，我也只看到多玩饭盒做的还可以，有很详细的分类，但是仍然不够好，曾经因为一段时间主播跳槽，虎牙将主播封杀，该主播视频就没有，另一方面，它们这些APP永远在做加法，功能越来越臃肿，我作为LOL玩家，我只想关于LOL的新闻咨询或者视频，不想玩你的社区，不想看你的美女视频，我只想静静的看视频。</p>
</blockquote>
<p>所以宗旨是：给用户一个干净的，完整的LOL视频观看体验。</p>
<p>利用Packet Capture和浏览器的F12功能，推理+解析了很久，终于剥离出查询的API.然后赶紧写了一个python把服务器中的视频资源存到数据库中。视频资源挺丰富，数据量有20k.</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_30_49_shipinbao.png" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>2016年，我主要的我就是四件事情，很惭愧，就做了一点微小的工作，谢谢大家。2017年，继续加油。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年做了四件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;找工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unity&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-找工作&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="未分类" scheme="http://www.orzangleli.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="未分类" scheme="http://www.orzangleli.com/tags/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>侧护板装配VR系统技术细节</title>
    <link href="http://www.orzangleli.com/2016/12/14/2016-12-14_%E4%BE%A7%E6%8A%A4%E6%9D%BF%E8%A3%85%E9%85%8DVR%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    <id>http://www.orzangleli.com/2016/12/14/2016-12-14_侧护板装配VR系统技术细节/</id>
    <published>2016-12-13T16:00:00.000Z</published>
    <updated>2017-01-10T14:13:30.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li>模型格式转化和处理</li>
<li>装配流程设计</li>
<li>动画设计</li>
<li>第三方库（VRTK，DOTween）的使用</li>
<li>交互方式设计</li>
</ol>
<h2 id="一-模型格式转化和处理"><a href="#一-模型格式转化和处理" class="headerlink" title="一.模型格式转化和处理"></a>一.模型格式转化和处理</h2><p>在任意的VR系统都有大量的模型需求，我总结了以下两种模型获取方式：</p>
<h3 id="1-使用三维绘图软件绘制模型并转换格式"><a href="#1-使用三维绘图软件绘制模型并转换格式" class="headerlink" title="1. 使用三维绘图软件绘制模型并转换格式"></a>1. 使用三维绘图软件绘制模型并转换格式</h3><p>以我常用的Catia为例，先绘制出模型，然后将模型转为CGR格式，注意一定要这个格式，经过我的测试，如果不是这个格式再接下来转换格式时会失败。</p>
<h3 id="2-使用3Ds-Max绘制模型"><a href="#2-使用3Ds-Max绘制模型" class="headerlink" title="2. 使用3Ds Max绘制模型"></a>2. 使用3Ds Max绘制模型</h3><p>这需要会使用3Ds Max的人员来做，由于我们这边缺乏这样的人，所以一般使用3Ds Max的模型都是从网络上下载下来的。</p>
<h2 id="二-装配流程设计"><a href="#二-装配流程设计" class="headerlink" title="二. 装配流程设计"></a>二. 装配流程设计</h2><p>根据三维仿真视频，可以看出装配流程如下所示：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_10_37_34_流程图.png" alt="去"></p>
<p>为了增强交互性，动画中人模型所做的事，将在VR系统中以第一人称的视角完成所有装配。</p>
<h2 id="三-动画设计"><a href="#三-动画设计" class="headerlink" title="三. 动画设计"></a>三. 动画设计</h2><p>可以从动画中看出有几处机构的运动形式：</p>
<ol>
<li>吊机的控制</li>
<li>侧护板的移动</li>
<li>夹具的夹紧和松开动作</li>
</ol>
<p>这几种是比较典型的几种运动形式，针对不同的运动形式，需要进行不用的动画设计。</p>
<h3 id="1-吊机的控制"><a href="#1-吊机的控制" class="headerlink" title="1. 吊机的控制"></a>1. 吊机的控制</h3><p>吊机的示意图如下：<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_10_59_38_吊机结构.png" alt=""></p>
<p>吊机的控制，这个是最基本的，就是通Transform组件，对物体进行移动。只不过这些需要注意的是，不同方向的移动是针对不同物体的，例如，上下方向移动是挂钩的移动，而左右移动是电机的移动，前后的移动是横梁的移动。</p>
<p>在程序，我定义了一个枚举类型，表示吊机目前的状态：</p>
<pre><code>public enum State {UP,DOWN,FRONT,BACK,LEFT,RIGHT,IDLE};
</code></pre><p>其中<code>IDLE</code>表示吊机静止状态。</p>
<p><strong>需要注意的细节</strong></p>
<p>这里有一个技术细节：连接电机和挂钩的『绳子』，它的长度是变化的，需要和挂钩保持同步。在VR系统中它并不是真正的绳子，而是一个圆柱体，绳子长度变化的时候，实际上是圆柱体沿竖直方向的scale值变化。另外，因为绳子总是从电机出发出，所以需要将圆柱体的锚点设置在电机处，否则绳子在变长到一定程度时，会看到绳子已经穿过了电机。</p>
<h3 id="2-侧护板的移动"><a href="#2-侧护板的移动" class="headerlink" title="2. 侧护板的移动"></a>2. 侧护板的移动</h3><p>相对来说，侧护板的移动不是一种『自主运动』，它是被吊机吊起来的，所以这种运动是不同于上述方法的处理。对于侧护板需要事先添加碰撞器，并添加脚本，碰撞器添加在挂带的中心位置，这样当挂钩碰到中心位置时，就能检测到。<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_11_26_52_侧护板碰撞器.png" alt=""><br>在检测到碰撞后，判断如果碰撞器如果是来自侧护板，就代表现在用户想使用挂钩将侧护板吊起来。在<code>OnTriggerEnter</code>中，将侧护板的parent设置为挂钩，这样侧护板就能够跟着挂钩移动了。</p>
<pre><code>collider.transform.parent = this.transform;
collider.transform.position = bornPlace.position;
</code></pre><h3 id="3-夹具的夹紧和松开动作"><a href="#3-夹具的夹紧和松开动作" class="headerlink" title="3. 夹具的夹紧和松开动作"></a>3. 夹具的夹紧和松开动作</h3><p>夹具的动作包括张开和闭合，动画如图所示：<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_13_47_43_夹具.gif" alt=""><br>夹具的动作很复杂，基本上无法通过脚本控制实现，所以，最好使用Unity中的Animation完成动画，而且夹具的动作张开和闭合是对称的，所以只需要完成闭合的动作就可以了，张开的动作可以将动画的播放速度调整为-1即可倒着播放。另外，在夹具闭合的时候，要把护板添加到夹具的两侧中，以达到夹具加紧侧护板的视觉效果。下面就是夹具闭合的代码：</p>
<pre><code>public void bihe()
{
    AnimatorStateInfo info = animator.GetCurrentAnimatorStateInfo(0);
    if ((info.IsName(&quot;jiaju_zhangkai&quot;) &amp;&amp; info.normalizedTime &gt;= 1) || info.IsName(&quot;idle&quot;))
    {

        //将左右护板添加到夹具中
        Transform yeyazhijia = this.transform.parent;
        Transform left_huban = yeyazhijia.FindChild(&quot;huban_guadai_left(Clone)&quot;);
        Transform right_huban = yeyazhijia.FindChild(&quot;huban_guadai_right(Clone)&quot;);
        Transform zuodangban = this.transform.FindChild(&quot;jiajuzhengti_copy/jiaju/zuodangban&quot;);
        Transform youdangban = this.transform.FindChild(&quot;jiajuzhengti_copy/jiaju/youdangban&quot;);

        if (Vector3.Distance(left_huban.position, zuodangban.position) &gt; Vector3.Distance(left_huban.position, youdangban.position))
        {
            normal = false;
            if (left_huban != null)
                left_huban.parent = youdangban;
            if (right_huban != null)
                right_huban.parent = zuodangban;
        }
        else
        {
            normal = true;
            if (left_huban != null)
                left_huban.parent = zuodangban;
            if (right_huban != null)
                right_huban.parent = youdangban;
        }

        animator.Play(&quot;jiaju_bihe&quot;);
        biheButton.interactable = false;
        zhangkaiButton.interactable = true;

        //同时使碰撞器失效，防止在未松开之前拉上去
        this.GetComponent&lt;Collider&gt;().enabled = false;
        stepHint.text = &quot;夹紧操作完成，请点击菜单中的『夹具张开』按钮&quot;;
    }
}
</code></pre><h2 id="四-第三方库（VRTK，DOTween）的使用"><a href="#四-第三方库（VRTK，DOTween）的使用" class="headerlink" title="四. 第三方库（VRTK，DOTween）的使用"></a>四. 第三方库（VRTK，DOTween）的使用</h2><p>本VR系统中主要使用了两个第三方库：</p>
<ul>
<li><p><strong>VRTK</strong>    <em>这个工具包提供了很多Unity3d里的常用VR功能，如下（但并不局限于此）：</em></p>
<ul>
<li>带有通用别名的控制器按钮事件</li>
<li>控制器世界指针（如激光指针）</li>
<li>玩家传送</li>
<li>用控制器抓取对象</li>
<li>用控制器和对象交互</li>
</ul>
</li>
<li><p><strong>DOTween</strong>  <em>DOTween是Unity中具有强大功能的动画插件</em></p>
</li>
</ul>
<h3 id="1-VRTK的使用"><a href="#1-VRTK的使用" class="headerlink" title="1. VRTK的使用"></a>1. VRTK的使用</h3><h4 id="1）-VRTK的安装"><a href="#1）-VRTK的安装" class="headerlink" title="1）. VRTK的安装"></a>1）. VRTK的安装</h4><p>VRTK从Assets Store中下载，下载完成后导入即可。</p>
<h4 id="2）-VRTK-射线的使用"><a href="#2）-VRTK-射线的使用" class="headerlink" title="2）. VRTK 射线的使用"></a>2）. VRTK 射线的使用</h4><p>在SteamVR包中[CameraRig]的Controller(right)上添加脚本VRTK_UI_Pointer,这是射线基本脚本，可以设置射线何时显示，比如按住按钮或者切换按钮或者一直显示等。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_35_51_VRTK_UI_Pointer.png" alt=""></p>
<p>还需要添加<code>VRTK_Simple_Pointer</code>脚本，这是直线射线发射脚本，除此之外还可以使用 <code>VRTK_Bezier_Pointer</code><br>它是贝泽尔曲线脚本。要指定按钮按住之后发射射线，还需要添加<code>VRTK_Controller Events</code>脚本，可以设置按下哪个按钮后发出射线。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_37_27_VRTK_ControllerEvents.png" alt=""></p>
<h4 id="3）-VRTK-中UI的使用"><a href="#3）-VRTK-中UI的使用" class="headerlink" title="3）. VRTK 中UI的使用"></a>3）. VRTK 中UI的使用</h4><p>VRTK中UI使用非常简单，只需要在普通的UGUI的Canvas上添加<code>VRTK_UI Canvas</code>脚本即可。</p>
<h3 id="2-DOTween的使用"><a href="#2-DOTween的使用" class="headerlink" title="2. DOTween的使用"></a>2. DOTween的使用</h3><p>DOTween十分强大，但是我在本系统中也只是使用到了其中的一部分功能。</p>
<h4 id="1-物体的移动"><a href="#1-物体的移动" class="headerlink" title="1). 物体的移动"></a>1). 物体的移动</h4><p>比如场景中，装配完成后，让生产线移动，实际上就是使用DOTween中的DOMove方法</p>
<pre><code>go.transform.DOLocalMoveZ(go.transform.localPosition.z - 1200f, 60).SetEase(Ease.Linear);
</code></pre><p>DOLocalMoveZ指的是在局部坐标系的Z轴方向上移动到go.transform.localPosition.z - 1200f这个位置，实际上就是向Z轴反方向移动1200，所用的时间是60秒，动画插值器使用的是线性插值。</p>
<h4 id="2-物体的缩放"><a href="#2-物体的缩放" class="headerlink" title="2). 物体的缩放"></a>2). 物体的缩放</h4><p>在菜单显示和关闭的时候，增加一个缩放的动画可以增强用户体验</p>
<pre><code>toolbox.transform.DOScale(0.005f, 0.5f);
</code></pre><p>这句代码的意思就是将菜单的大小放大到0.005,使用的时间是0.5秒。</p>
<h4 id="3-滚动数码管显示器"><a href="#3-滚动数码管显示器" class="headerlink" title="3). 滚动数码管显示器"></a>3). 滚动数码管显示器</h4><p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_51_22_显示器.gif" alt=""></p>
<p>要实现以上效果，需要在Canvas下添加一个遮罩层(Image组件)，给遮罩层添加Mask脚本，并且给Image指定一个图片，这个图片就是指定的Mask的遮罩形状，这样在遮罩层以外的UI都不会显示了。</p>
<p>要实现文字连续滚动，事先添加两个Text，如图所示，由于有Mask层存在，第二个是看不到的。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_56_26_状态监测UI.png" alt=""></p>
<p>然后给这两个Text上添加脚本，让他们移动。</p>
<pre><code>this.transform.DOLocalMoveX(this.transform.localPosition.x -1000f,5).SetEase(Ease.Linear).SetLoops(-1,LoopType.Restart);
</code></pre><p>数码管的长度正好为1000，让两个文字一起在5秒中内向左移动1000，移动完成后重新启动动画(复位)，这样就实现了文字无限循环的滚动了。</p>
<h2 id="五-交互方式设计"><a href="#五-交互方式设计" class="headerlink" title="五. 交互方式设计"></a>五. 交互方式设计</h2><p>系统做出来是给人使用的，交互设计也是十分重要，虽然目前我对本系统的交互设计上也有点意见，但是目前尚未找到更好的方案，下面将详细说明。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_15_16_34_手柄按键说明.png" alt=""></p>
<h3 id="1-左手手柄"><a href="#1-左手手柄" class="headerlink" title="1. 左手手柄"></a>1. 左手手柄</h3><ul>
<li>左手手柄的触摸板，轻触时显示控制吊机移动的菜单，滑动可以选择菜单，按下时将执行动作。</li>
<li>左手手柄的Grip键(侧面的两个按钮)是旋转挂钩的方向的。</li>
<li>Application键用来显示和隐藏手柄上的提示文字</li>
</ul>
<h3 id="2-右手手柄"><a href="#2-右手手柄" class="headerlink" title="2. 右手手柄"></a>2. 右手手柄</h3><ul>
<li><p>触摸板按下时发出射线</p>
<ul>
<li>若发出的射线指向地面，松开触摸板即可瞬移到该位置</li>
<li>若发出的射线指向UI界面，配合Trigger(扳机键)可以实现点击按钮的操作。</li>
</ul>
</li>
<li><p>Grip键(侧面的两个按钮)是用于显示和关闭菜单的</p>
</li>
</ul>
<h3 id="3-目前方案存在的问题"><a href="#3-目前方案存在的问题" class="headerlink" title="3.目前方案存在的问题"></a>3.目前方案存在的问题</h3><p>之前说过这个方案是有不足的，主要在于吊机的控制。吊机需要6个按钮来控制，分别是上下东西南北，如果要将这6个按钮显示在一起，就是上面的方案，可以看到无论怎么分布，使用无法保证东西南北的四个方向与真实的场景中的方向一致，所以在操作吊机时，不熟悉的使用者需要一直看着手柄进行操作。</p>
<h3 id="4-潜在的解决方法"><a href="#4-潜在的解决方法" class="headerlink" title="4.潜在的解决方法"></a>4.潜在的解决方法</h3><h4 id="1-分解菜单"><a href="#1-分解菜单" class="headerlink" title="1). 分解菜单"></a>1). 分解菜单</h4><p>在展会的时候，有人就提出了这个问题，后来我问他有什么好的建议，他说可以把东西南北做到左手手柄上，将上下两个按钮做到右手手柄上，这样右手手柄上发射射线的按钮就需要修改下了，不过这也是一种方案。</p>
<h4 id="2-将6等分菜单变为8等分菜单"><a href="#2-将6等分菜单变为8等分菜单" class="headerlink" title="2). 将6等分菜单变为8等分菜单"></a>2). 将6等分菜单变为8等分菜单</h4><p>很简单的原理，示意图如下所示：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_15_51_08_按键方案2.png" alt=""></p>
<p>至于哪种方案好，我暂时也没有办法判断，所以只好先全部记录下来了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;模型格式转化和处理&lt;/li&gt;
&lt;li&gt;装配流程设计&lt;/li&gt;
&lt;li&gt;动画设计&lt;/li&gt;
&lt;li&gt;第三方库（VRTK，DOTwe
    
    </summary>
    
      <category term="unity3D" scheme="http://www.orzangleli.com/categories/unity3D/"/>
    
    
      <category term="unity3D" scheme="http://www.orzangleli.com/tags/unity3D/"/>
    
  </entry>
  
  <entry>
    <title>pyqt打包失败.md</title>
    <link href="http://www.orzangleli.com/2016/12/13/2016-12-13_pyqt%E6%89%93%E5%8C%85%E5%A4%B1%E8%B4%A5/"/>
    <id>http://www.orzangleli.com/2016/12/13/2016-12-13_pyqt打包失败/</id>
    <published>2016-12-12T16:00:00.000Z</published>
    <updated>2016-12-29T13:51:57.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题"><a href="#pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题" class="headerlink" title="pyqt 打包失败 出现pyi_rth_qt4plugins 找不到的问题"></a>pyqt 打包失败 出现pyi_rth_qt4plugins 找不到的问题</h1><ol>
<li><p>pyqt5的位数和系统位数要一致。</p>
</li>
<li><p>pyqt版本为：PyQt GPL v5.4.1 for Pythonv3.4(x64)</p>
</li>
</ol>
<p>环境截图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_09_59_32_python环境截图.png" alt=""></p>
<p>使用下面的语句进行打包：<br>pyinstaller –hidden-import queue -F -w MainWindow.py</p>
<p>后来由出现QtCore可以找到，但是QtWidgets找不到，但是不知道怎么回事，重新打包了n次后就自动好了，不知道是不是之前设置的环境变量要过一会才会生效，设置的环境变量就是QtCore,QtGui,QtWidgets三个dll文件。</p>
<p>在管理员模式下运行命令行，进行PyInstaller安装</p>
<p>加上这句话：<br>    from PyQt5 import *<br>这句话才是精髓，不加就不能运行，加了就可以。。。额！</p>
<p>C:\Users\Administrator\AppData\Roaming\pyinstaller\bincache00_py34_64bit\qt5gui.dll 可能是去这个目录找那个dll，然后没找到。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题&quot;&gt;&lt;a href=&quot;#pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题&quot; class=&quot;headerlink&quot; title=&quot;pyqt 打包失败 出现pyi_rt
    
    </summary>
    
      <category term="python" scheme="http://www.orzangleli.com/categories/python/"/>
    
    
      <category term="python" scheme="http://www.orzangleli.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>自己动手造轮子系列———实现『转转APP』Indicator 效果</title>
    <link href="http://www.orzangleli.com/2016/11/10/2016-11-19_%E8%BD%AC%E8%BD%ACIndicator/"/>
    <id>http://www.orzangleli.com/2016/11/10/2016-11-19_转转Indicator/</id>
    <published>2016-11-09T16:00:00.000Z</published>
    <updated>2016-11-10T14:06:01.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自己动手造轮子系列———实现『转转APP』Indicator-效果"><a href="#自己动手造轮子系列———实现『转转APP』Indicator-效果" class="headerlink" title="自己动手造轮子系列———实现『转转APP』Indicator 效果"></a>自己动手造轮子系列———实现『转转APP』Indicator 效果</h1><h2 id="一-『转转APP』效果预览"><a href="#一-『转转APP』效果预览" class="headerlink" title="一.『转转APP』效果预览"></a>一.『转转APP』效果预览</h2><p>注意看Indicator指示器</p>
<p><img src="http://lxctest.qiniudn.com/2016-11-10_15:57:31_zhuanzhuan2.webp" alt=""></p>
<h2 id="二-动作分析"><a href="#二-动作分析" class="headerlink" title="二.动作分析"></a>二.动作分析</h2><ol>
<li>左边部分</li>
</ol>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-10_19_59_20.png?imageView2/0/w/800" alt=""></p>
<p>左边部分是一个白色的圆圈，圆圈中用红色字体显示当前页数，在ViewPager滑动时，白色圆圈绕Y轴旋转，在旋转180度时，即显示背面的时候，圆圈中字变成下一页的页码。</p>
<ol>
<li>右边部分</li>
</ol>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-10_20_00_01.png?imageView2/0/w/800" alt=""></p>
<p>右边部分比较简单，一个带缺口的椭圆，上面显示着总页数。</p>
<h2 id="三-各个击破难点"><a href="#三-各个击破难点" class="headerlink" title="三.各个击破难点"></a>三.各个击破难点</h2><h3 id="1-用canvas绘制绕Y轴旋转"><a href="#1-用canvas绘制绕Y轴旋转" class="headerlink" title="1. 用canvas绘制绕Y轴旋转"></a>1. 用canvas绘制绕Y轴旋转</h3><p>Canvas 绘制图片时，如果是在绕Z轴旋转是比较简单，使用Matrix矩阵：</p>
<pre><code>Matrix matrix = new Matrix();
matrix.setRotate(angle);
Bimtap newBitmap = Bitmap.createBitmap(oldBitmap,0,0,oldBitmap.getWidth(),
    oldBitmap.getHeight(),matrix,true);
</code></pre><p>但是这只能在绘制图片时进行旋转，如果要对一个整体旋转则无法做到，比如，上面转转的指示器坐标的圆圈，圆圈是一个圆，上面还有数字，要实现圆和数字一起旋转，所以无法通过上述方法完成。</p>
<p>而且这个问题我在谷歌上搜索，也不太好表述，刚开始搜索「android canvas 3D旋转」，结果也不太相符，后来搜索「android canvas绕y轴 旋转」，才找到符合的。</p>
<p>使用 Android.graphics.Camera 的 rotateY 接口实现绕 Y 轴旋转时矩阵的运算。</p>
<p>首先声明camera </p>
<pre><code>camera = new Camera();
</code></pre><p>在Ondraw方法中，首先对canvas状态进行保存，使用的是<code>canvas.save()</code>,然后将camera状态保存，将camera旋转一个角度rotateAngle，在获取camera的矩阵赋值到matrix中，最后将camera状态恢复至旋转之前的状态。然后将matrix追加到当前canvas的矩阵中，使用的是concat方法，这时候整个画布相当于旋转了rotateAngle角度，画完圆之后再恢复至原来的状态。</p>
<pre><code>canvas.save();
Matrix matrix = new Matrix(); 
camera.save();
camera.rotateY(rotateAngle);
camera.getMatrix(matrix);
camera.restore();

mPaint.setColor(textBackgroundColor);
int centerX = diameter / 2;
int centerY = diameter / 2;
matrix.preTranslate(-centerX, -centerY);
matrix.postTranslate(centerX, centerY);
canvas.concat(matrix);

canvas.drawCircle(diameter / 2, diameter / 2, diameter / 2, mPaint);

canvas.restore();
</code></pre><h3 id="2-canvas-drawText文字垂直居中"><a href="#2-canvas-drawText文字垂直居中" class="headerlink" title="2. canvas drawText文字垂直居中"></a>2. canvas drawText文字垂直居中</h3><p>这个问题，如果没有遇到还真不知道会出现这种问题，一般想象的，我设置画笔的gravity属性为Paint.Align.CENTER，在将文字的中点设置下不就ok了么，如下面的代码：</p>
<pre><code>textPaint.setTextAlign(Paint.Align.CENTER);
canvas.drawText(&quot;of &quot; + maxPage, rect.centerX(), rect.centerY(), textPaint);
</code></pre><p>出现的效果，如图所示，发现文字是偏上：</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-10_21_15_24.png?imageView2/0/w/800" alt=""></p>
<p>这是怎么回事呢？其实我们设置的文字爱中心点处绘制，实际上，文字是以基准线为锚点进行绘制的，英文叫做baseline.</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-10_21_17_07.png?imageView2/0/w/800" alt=""></p>
<p>在维基百科中可以看到<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E7%B7%9A" target="_blank" rel="external">基线</a>的解释：</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-10_21_24_40.png?imageView2/0/w/800" alt=""></p>
<p>所以我们如果想让文字居中，则需要将绘制点的Y坐标向下移动。</p>
<p>基线到字体顶端的距离为top,基线到字体底端距离为bottom,则有以下等式：</p>
<pre><code>(top + baseline)+ (bottom + baseline) / 2 = centenY() 
</code></pre><p>那么经过计算就可以算出baseline的值，通过Paint.FontMetrics获取top和bottom值，代码如下：</p>
<pre><code>//画文字
Rect rect = new Rect(diameter, 0, (int) (diameter * 3.4f), diameter);//右边的背景图片的Rect
Paint textPaint = new Paint();
textPaint.setColor(Color.WHITE);
textPaint.setTextSize((int) (diameter * 0.6f));
textPaint.setStyle(Paint.Style.FILL);
//该方法即为设置基线上那个点究竟是left,center,还是right  这里我设置为center
textPaint.setTextAlign(Paint.Align.CENTER);

Paint.FontMetrics fontMetrics = textPaint.getFontMetrics();
float top = fontMetrics.top;//为基线到字体上边框的距离,即上图中的top
float bottom = fontMetrics.bottom;//为基线到字体下边框的距离,即上图中的bottom
int baseLineY = (int) (rect.centerY() - top / 2 - bottom / 2);//基线中间点的y轴计算公式
canvas.drawText(&quot;of &quot; + maxPage, rect.centerX(), baseLineY, textPaint);
</code></pre><h3 id="3-自动轮播"><a href="#3-自动轮播" class="headerlink" title="3. 自动轮播"></a>3. 自动轮播</h3><p>自动轮播，通过Handler+Timer即可。</p>
<pre><code>//定时自动播放
timer = new Timer();
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        Message message = new Message();
        message.what = 1;
        if (mViewPager.getCurrentItem() == Integer.MAX_VALUE - 1) {
            currentIndex = -1;
        }
        currentIndex = mViewPager.getCurrentItem();
        message.arg1 = currentIndex + 1;
        mHandler.sendMessage(message);
    }
},1000,2000);
</code></pre><p>然后自定义Handler.</p>
<pre><code>//定时轮播图片，需要在主线程里面修改 UI
private Handler mHandler = new Handler() {
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case 1:
                mViewPager.setCurrentItem(msg.arg1,true);
        }
    }
};
</code></pre><h2 id="四-代码实现"><a href="#四-代码实现" class="headerlink" title="四.代码实现"></a>四.代码实现</h2><p>代码在Github上，请不要吝啬Star噢。</p>
<p><a href="https://github.com/hust201010701/RoateIndicatorViewDemo" target="_blank" rel="external">RotateIndicatorView</a></p>
<h2 id="联系方式和建议"><a href="#联系方式和建议" class="headerlink" title="联系方式和建议"></a>联系方式和建议</h2><p>微博：orzangleli</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;自己动手造轮子系列———实现『转转APP』Indicator-效果&quot;&gt;&lt;a href=&quot;#自己动手造轮子系列———实现『转转APP』Indicator-效果&quot; class=&quot;headerlink&quot; title=&quot;自己动手造轮子系列———实现『转转APP』Indic
    
    </summary>
    
      <category term="android" scheme="http://www.orzangleli.com/categories/android/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="自己动手造轮子系列" scheme="http://www.orzangleli.com/tags/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%80%A0%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>使用Python将Jpeg Png Gif 图片转换为 webp格式</title>
    <link href="http://www.orzangleli.com/2016/11/10/2016-11-10_Python%E5%B0%86Jpeg%20Png%20Gif%E8%BD%AC%E6%8D%A2%E4%B8%BAWebp%E6%A0%BC%E5%BC%8F/"/>
    <id>http://www.orzangleli.com/2016/11/10/2016-11-10_Python将Jpeg Png Gif转换为Webp格式/</id>
    <published>2016-11-09T16:00:00.000Z</published>
    <updated>2016-11-10T14:05:29.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Python将Jpeg-Png-Gif-图片转换为-webp格式"><a href="#使用Python将Jpeg-Png-Gif-图片转换为-webp格式" class="headerlink" title="使用Python将Jpeg Png Gif 图片转换为 webp格式"></a>使用Python将Jpeg Png Gif 图片转换为 webp格式</h1><h2 id="一-动机"><a href="#一-动机" class="headerlink" title="一.动机"></a>一.动机</h2><p>因为webp的优良特性：</p>
<ul>
<li><p>占空间小，节省带宽</p>
</li>
<li><p>总体加载速度快</p>
</li>
</ul>
<p>这里有详细的介绍： 摘自 <a href="https://zh.wikipedia.org/wiki/WebP" target="_blank" rel="external">维基百科-WebP词条</a></p>
<p>WebP（发音weppy）[6][7]，是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式[8]，派生自视频编码格式VP8[9]，被认为是WebM多媒体格式的姊妹项目，是由Google在购买On2 Technologies后发展出来[10]，以BSD授权条款发布。[11]<br>WebP最初在2010年发布，目标是减少文件大小，但达到和JPEG格式相同的图片质量，希望能够减少图片档在网络上的发送时间。 [12]2011年11月8日，Google开始让WebP支持无损压缩和透明色（alpha通道）的功能，而在2012年8月16日的参考实做libwebp 0.2.0中正式支持[13][14]。根据Google较早的测试，WebP的无损压缩比网络上找到的PNG档少了45％的文件大小，即使这些PNG档在使用pngcrush和PNGOUT处理过，WebP还是可以减少28％的文件大小[15]。<br>WebP支持的像素最大数量是16383x16383。有损压缩的WebP仅支持8-bit的YUV 4:2:0格式。而无损压缩（可逆压缩）的WebP支持VP8L编码与8-bit之ARGB色彩空间。又无论是有损或无损压缩皆支持Alpha透明通道、ICC色彩配置、XMP诠释数据。<br>WebP有静态与动态两种模式。动态WebP（Animated WebP）支持有损与无损压缩、ICC色彩配置、XMP诠释数据、Alpha透明通道。而无损压缩的动态WebP亦支持8-bit之ARGB色彩空间。</p>
<h2 id="二-方案实验"><a href="#二-方案实验" class="headerlink" title="二. 方案实验"></a>二. 方案实验</h2><h3 id="1-使用PIL-转换格式"><a href="#1-使用PIL-转换格式" class="headerlink" title="1. 使用PIL 转换格式"></a>1. 使用PIL 转换格式</h3><p>首先指出，PIL转换在大部分情况下都能起到很好的效果，比如讲jpeg转为webp，节省空间约90%。<br>首先安装PIL模块</p>
<pre><code>pip install pillow
</code></pre><p>然后在程序中 <code>localfile</code> 为图片路径</p>
<pre><code>im = Image.open(localfile)
f,ext = os.path.splitext(localfile.split(&quot;/&quot;)[-1])
webp_path = &quot;%s.webp&quot;%f
im.convert(&apos;RGB&apos;).save(webp_path, &quot;webp&quot;)
</code></pre><p>这里需要注意需要将图片先转化为RGB模式，否则报错</p>
<pre><code>cannot write mode P as WEBP
</code></pre><p>现在，是时候说下PIL「失效」的情况了。</p>
<ol>
<li>将动图转为gif时，转化过程没有报错，但是打开后，只保存了第一帧的图片，变成了静态图。</li>
<li>将 gif 转为 webp格式时，同样也只保存了第一帧。</li>
</ol>
<p>第一种情况我没有测试，但是在stackoverflow上可以看到有人提问过： <a href="http://stackoverflow.com/questions/24688802/saving-an-animated-gif-in-pillow" target="_blank" rel="external">Saving an animated GIF in Pillow</a> 。回答者是建议使用gifmaker 模块进行处理gif.</p>
<p>第二张情况，我遇到了，所以可以证实。</p>
<p>通过搜索，在官网上看到<a href="https://developers.google.com/speed/webp/docs/gif2webp" target="_blank" rel="external">gif2webp</a>,证明官网给出了gif转webp的解决方案，那我们就下载适合自己版本的库<a href="https://storage.googleapis.com/downloads.webmproject.org/releases/webp/index.html" target="_blank" rel="external"></a>.<br>解压后，将bin 目录下的 gif2webp.exe 复制到 工作目录下。接下来，我们使用它来转化格式。</p>
<h3 id="2-使用gif2webp-exe转化格式"><a href="#2-使用gif2webp-exe转化格式" class="headerlink" title="2. 使用gif2webp.exe转化格式"></a>2. 使用gif2webp.exe转化格式</h3><p>根据官网给的文档<a href="https://developers.google.com/speed/webp/docs/gif2webp" target="_blank" rel="external">gif2webp</a>，我们可以很方便的使用下面的语句来实现：</p>
<pre><code>f,ext = os.path.splitext(localfile.split(&quot;/&quot;)[-1])
webp_path = &quot;%s.webp&quot;%f
os.system(&quot;gif2webp.exe &quot;+ localfile + &quot; -quiet &quot; + &quot; -o &quot; + f + &quot;.webp&quot;)
</code></pre><p>这里可能会提示：</p>
<pre><code>GIF decode warning: invalid background color index. Assuming white background.
</code></pre><p>转换过程持续好几秒，请耐心等待，转化完成后，工作目录下多一个webp文件.</p>
<h2 id="三-效果比较"><a href="#三-效果比较" class="headerlink" title="三.效果比较"></a>三.效果比较</h2><center>左边是gif格式的               右边是webp格式</center>


<p><img src="http://i.imgur.com/aFTWeSK.gif" alt="">   <img src="http://lxctest.qiniudn.com/2016-11-10_15:57:31_zhuanzhuan2.webp" alt=""></p>
<p>你的肉眼能看出区别么？</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用Python将Jpeg-Png-Gif-图片转换为-webp格式&quot;&gt;&lt;a href=&quot;#使用Python将Jpeg-Png-Gif-图片转换为-webp格式&quot; class=&quot;headerlink&quot; title=&quot;使用Python将Jpeg Png Gif 图片
    
    </summary>
    
      <category term="python" scheme="http://www.orzangleli.com/categories/python/"/>
    
    
      <category term="python" scheme="http://www.orzangleli.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Plugin is too old, please update to a more recent version解决方法</title>
    <link href="http://www.orzangleli.com/2016/11/04/2016-11-04_Plugin%20is%20too%20old,%20please%20update%20to%20a%20more%20recent%20version%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.orzangleli.com/2016/11/04/2016-11-04_Plugin is too old, please update to a more recent version解决方法/</id>
    <published>2016-11-03T16:00:00.000Z</published>
    <updated>2017-01-10T14:13:45.083Z</updated>
    
    <content type="html"><![CDATA[<p>#Plugin is too old, please update to a more recent version问题解决方法</p>
<p>Android Studio 报错：</p>
<p>Plugin is too old, please update to a more recent version, or set ANDROID_DAILY_OVERRIDE environment variable to…</p>
<p>网上众说纷纭，但是实际上没有几个能用。<br>首先当然你可以把gradle版本调低，运行没问题，但是就不能体验到Instant Run等新功能，为了体验新功能，按照以下步骤进行。</p>
<h2 id="1-查看最新的gradle插件"><a href="#1-查看最新的gradle插件" class="headerlink" title="1. 查看最新的gradle插件"></a>1. 查看最新的gradle插件</h2><p>修改Project的build.gradle中版本<br><a href="https://bintray.com/android/android-tools/com.android.tools.build.gradle" target="_blank" rel="external">查看最新版本gradle插件</a></p>
<p>打开build.gradle(Project:xxx),修改下面代码为</p>
<p>修改前</p>
<pre><code>classpath &apos;com.android.tools.build:gradle:1.3&apos;
</code></pre><p>修改后</p>
<pre><code>classpath &apos;com.android.tools.build:gradle:+&apos;
</code></pre><h2 id="2-查看最新版本的gradle"><a href="#2-查看最新版本的gradle" class="headerlink" title="2. 查看最新版本的gradle"></a>2. 查看最新版本的gradle</h2><p>进入gralde下载网站： <a href="https://services.gradle.org/distributions/" target="_blank" rel="external">Gradle Distributions</a> </p>
<p>如图所示：</p>
<p><img src="http://lxctest.qiniudn.com/2016-11-04_11:34:36_1.png?imageView2/0/w/800" alt=""></p>
<p>可以看到最新版是gradle-3.2-rc-2-all.zip</p>
<h2 id="3-修改gradle-wrapper-properties"><a href="#3-修改gradle-wrapper-properties" class="headerlink" title="3.修改gradle-wrapper.properties"></a>3.修改gradle-wrapper.properties</h2><p>将gradle-wrapper.properties 中<code>distributionUrl</code>指向的内容修改为：</p>
<pre><code>distributionUrl=https\://services.gradle.org/distributions/xxx
</code></pre><p><code>xxx</code> 为你在官网看到的最新版的文件名字</p>
<p>如：<br>    distributionUrl=https\://services.gradle.org/distributions/gradle-3.2-rc-2-all.zip</p>
<p>现在就可以使用新版功能了，而且之后也看不到烦人的更新提示了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Plugin is too old, please update to a more recent version问题解决方法&lt;/p&gt;
&lt;p&gt;Android Studio 报错：&lt;/p&gt;
&lt;p&gt;Plugin is too old, please update to a m
    
    </summary>
    
      <category term="android" scheme="http://www.orzangleli.com/categories/android/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Python 实用技巧————博客文档备份及格式转化</title>
    <link href="http://www.orzangleli.com/2016/11/03/Python%E5%AE%9E%E6%88%98_%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>http://www.orzangleli.com/2016/11/03/Python实战_博客备份及格式转换/</id>
    <published>2016-11-02T16:00:00.000Z</published>
    <updated>2017-01-10T14:15:05.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要备份博客文章？"><a href="#1-为什么要备份博客文章？" class="headerlink" title="1. 为什么要备份博客文章？"></a>1. 为什么要备份博客文章？</h2><p>备份博客文章原因有很多，其中很重要的一点就是担心服务器数据丢失。我购买的是主机公园的香港主机，当时图便宜，也图方便（不需要备案），因此购买此主机，购买之后发现使用很是不方便：</p>
<ol>
<li><p>一方面速度很慢，打开主页都需要几秒钟，而且有时候我的浏览器已经有缓存了，打开还是很慢；</p>
</li>
<li><p>二是服务器时不时的挂掉，服务商还做过几次空间迁移。</p>
</li>
</ol>
<p>正因为这些原因，让用户体验很差，网友们通过搜索引擎搜索到之后，打开网站等待时间过长，一般来说就会直接关闭网页了。另一方面，空间中的文章也处于一种不安全的状态，随时可能找不到备份文件。</p>
<h2 id="2-为什么要放弃wordpress？"><a href="#2-为什么要放弃wordpress？" class="headerlink" title="2. 为什么要放弃wordpress？"></a>2. 为什么要放弃wordpress？</h2><p>之前建博客的重点是有一个可以保存自己文章的位置，可以随时记录，随时查阅，但是作为一个极简主义者，实在受不了wp的臃肿设计，而且使用几个插件之后网页巨卡无比，让人无法接受。</p>
<p>在知乎和google上搜索“个人编程博客框架”时，很多推荐了Hexo，这是一个基于Node.js的博客框架，非常好用，对于日常博客类网站十分适合。</p>
<h2 id="3-Hexo的安装和配置教程"><a href="#3-Hexo的安装和配置教程" class="headerlink" title="3.Hexo的安装和配置教程"></a>3.Hexo的安装和配置教程</h2><p>参见这位大神的教程： <a href="http://blog.niices.com/Hexo-Blog-Github-Page-Coding-Page-Domain/" target="_blank" rel="external">niices</a></p>
<h2 id="4-博客备份原理及步骤"><a href="#4-博客备份原理及步骤" class="headerlink" title="4.博客备份原理及步骤"></a>4.博客备份原理及步骤</h2><p>下面进入正题。</p>
<h3 id="4-1-博客备份原理"><a href="#4-1-博客备份原理" class="headerlink" title="4.1 博客备份原理"></a>4.1 博客备份原理</h3><p>首先需要知道wp站点有大量的css和js，是动态网站，无法使用urllib直接获取网站源码。<br>这里使用selenium 中的webdriver 配合phantomjs.exe ，这是一个真实的浏览器访问网站，所以不需要添加任何UA标识等。<br>在wp的首页，使用浏览器访问主页，按F12或者右键审查元素，查看文章标题的class.(不同的主题可能略微有些不同)</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-03_14:24:52_1.jpg?imageView2/0/w/800" alt=""></p>
<p>可以知道文章的标题由 <code>&lt;h2 class=&quot;entry-title&quot;&gt;</code> 包含，再使用selenium获取网页源码之后，使用BeautifulSoup可以定位到这个标签：</p>
<pre><code>titles =soup.findAll(class_=&quot;entry-title&quot;)
</code></pre><p>因为主页中有很多文章，所以有很多类似的标题，我们需要将所有的都获取到。</p>
<pre><code>for title in titles:
        address = title.find(&quot;a&quot;)[&quot;href&quot;]
        self.articles.add(address)
</code></pre><p><code>self.articles</code> 是一个set集合。用于保存所有文章的url,通过上面的代码可以将每篇文章中的代码保存到<code>self.articles</code>中    </p>
<p>这是获取主页的第一页的所有文章，还有第2页等。所以定义一个函数，根据页码获取文章地址：</p>
<pre><code>def getArticlesByPageIndex(self,pageIndex):
    self.browser.get(&quot;http://www.orzangleli.com/page/%d/&quot;%pageIndex)
    time.sleep(6)
    soup = BeautifulSoup(self.browser.page_source,&quot;html5lib&quot;)
    titles =soup.findAll(class_=&quot;entry-title&quot;)
    for title in titles:
        address = title.find(&quot;a&quot;)[&quot;href&quot;]
        self.articles.add(address)
        print(address)
</code></pre><p>通过一个for循环完成所有页面的文章url添加，之所以是<code>i+1</code>,是因为range(3)表示{0，1，2}：</p>
<pre><code>def getAllArticles(self):
        for i in range(self.pages):
            self.getArticlesByPageIndex(i+1)
</code></pre><p>这样，所有文章的url都存在<code>self.articles</code>中了，在浏览器中访问一个文章，观察文章的中信息，同样通过bs4可以获取文章的标题，发表时间，分类目录，hexo中的md文档还需要指明tag，这里我用分类代替，而分类使用之前分类的第一个分类代替，这些信息还要以特定格式保存在md中，下面代码负责返回一个md文档中head：</p>
<pre><code>def mdheader(self,title,date,tags,category):
        head = &quot;&quot;&quot;---
title: %s
date: %s
tags:
%scategories: %s
---&quot;&quot;&quot;%(title,date,tags,category)
        return head
</code></pre><p>获取到文章的正文内容后，使用html2text将html语言转为markdown语言。html2text的文档在：<a href="https://pypi.python.org/pypi/html2text/2016.9.19" target="_blank" rel="external">html2text</a>，将head和html2text转化的内容连接，组成完整的md文档。</p>
<p>入口函数为：</p>
<pre><code>def saveBlog(self):
        self.getAllArticles()
        for url in self.articles:
            self.save2md(url)
</code></pre><p>在最外层使用下面代码初始化类：<br>    browser = webdriver.PhantomJS(executable_path =”phantomjs.exe”)<br>    blog = Blog(browser,5)<br>    blog.saveBlog()</p>
<p>完整代码：</p>
<pre><code>import requests
from selenium import webdriver
import time
import html2text
from bs4 import BeautifulSoup


class Blog():
    def __init__(self,browser,pages):
        self.browser = browser
        self.pages = pages
        self.articles = set()

    def getArticlesByPageIndex(self,pageIndex):
        self.browser.get(&quot;http://www.orzangleli.com/page/%d/&quot;%pageIndex)
        time.sleep(6)
        soup = BeautifulSoup(self.browser.page_source,&quot;html5lib&quot;)
        #print(self.browser.page_source)
        titles =soup.findAll(class_=&quot;entry-title&quot;)
        for title in titles:
            address = title.find(&quot;a&quot;)[&quot;href&quot;]
            self.articles.add(address)
            print(address)

    def getAllArticles(self):
        for i in range(self.pages):
            self.getArticlesByPageIndex(i+1)

    def save2md(self,page_address):
        self.browser.get(page_address)
        time.sleep(6)
        #需要事先在wp后台关闭禁用掉代码高亮显示插件

        soup = BeautifulSoup(self.browser.page_source,&quot;html5lib&quot;)
        title = soup.find(class_=&quot;entry-title&quot;).text
        date = soup.find(class_=&quot;updated&quot;)[&quot;datetime&quot;].split(&quot;T&quot;)[0]
        content = soup.find(class_=&quot;entry-content&quot;)
        #获取标签
        categorys = soup.findAll(&quot;a&quot;,{&quot;rel&quot;:&quot;category tag&quot;})
        tags = &quot;&quot;
        for category in categorys:
            if category.text.startswith(&quot;未分类&quot;):
                break
            tags = &quot;%s- %s\n&quot;%(tags,category.text)

        head = self.mdheader(title,date,tags,categorys[0].text)        
        #print(content)

        mdcontent = html2text.html2text(str(content))
        #给md文档加上头
        mdcontent = &quot;%s\n%s&quot;%(head,mdcontent)
        #删除作者署名信息
        mdcontent = mdcontent.split(&quot;![](http://2.gravatar.com/avatar/e9a1c2c77d47ac4dcfeb1fa2fc1c936a?s=42&amp;d=mm&amp;r=g)&quot;)[0]

        with open(&quot;%s_%s.md&quot;%(date,title),&quot;w+&quot;,encoding=&quot;utf-8&quot;) as file:
            file.write(mdcontent)
            file.close()

    def saveBlog(self):
        self.getAllArticles()
        for url in self.articles:
            self.save2md(url)


    def mdheader(self,title,date,tags,category):
        head = &quot;&quot;&quot;---
title: %s
date: %s
tags:
%scategories: %s
---&quot;&quot;&quot;%(title,date,tags,category)
        return head


browser = webdriver.PhantomJS(executable_path =&quot;phantomjs.exe&quot;)
blog = Blog(browser,5)
blog.saveBlog()
</code></pre><p>附上，我将博客上所有文章保存下来的截图，幸福感满满~，待会可以使用hexo提交到hust201010701.github.io上：</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-03_15:10:25_3.jpg?imageView2/0/w/1000" alt=""></p>
<p>源码地址：<a href="https://github.com/hust201010701/WpBlogToMarkdownFile.git" target="_blank" rel="external">WpBlogToMarkdownFile.git</a></p>
<h2 id="5-为什么Python这么强大？"><a href="#5-为什么Python这么强大？" class="headerlink" title="5. 为什么Python这么强大？"></a>5. 为什么Python这么强大？</h2><p>从上面的完整代码就可以看出，python代码使用了77行，实现了整个需求，真的是：<strong>人生苦短，我用python.</strong> </p>
<p>Pyhton的强大的内置库和第三方库，让轮子不再重复制造，完成一个网页源码的数据获取只需要两三行代码，请问除了python还有谁？</p>
<p>学习代码这么长时间，之间一直使用C++,java,android,C#，没有哪种语言能够真真切切地解决生活中的麻烦事，直到遇到了python，庆幸~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-为什么要备份博客文章？&quot;&gt;&lt;a href=&quot;#1-为什么要备份博客文章？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要备份博客文章？&quot;&gt;&lt;/a&gt;1. 为什么要备份博客文章？&lt;/h2&gt;&lt;p&gt;备份博客文章原因有很多，其中很重要的一点就是担心
    
    </summary>
    
      <category term="Python" scheme="http://www.orzangleli.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.orzangleli.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Windows 平台下的整站抓取工具  WinHTTrack Website Copier 使用</title>
    <link href="http://www.orzangleli.com/2016/10/30/Windows%20%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E6%95%B4%E7%AB%99%E6%8A%93%E5%8F%96%E5%B7%A5%E5%85%B7%20%20WinHTTrack%20Website%20Copier%20%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.orzangleli.com/2016/10/30/Windows 平台下的整站抓取工具  WinHTTrack Website Copier 使用/</id>
    <published>2016-10-29T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:55.162Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上本来想看android文档，使用之前好久没用的Lantern，发现已经不能打开墙外网站了，于是就想着android官方文档很重要，而且可能随时会看，就想着自己做一个镜像网站。</p>
<p>本来想的是使用Python爬虫，将developer.android.com上的所有guide网站目录下的网站爬取下来，然后在解析html内容，将所有的链接地址指向本地的相对地址，然后再下载html中的图片，flash,js,css等文件。</p>
<p>但是当我爬取下来一个首页的html之后，发现图片可能还比较好分辨，css感觉规则很不明显，会有这种css格式出现：</p>
<p>&lt;link rel=”stylesheet”<br>href=”//fonts.googleapis.com/css?family=Roboto+Condensed”&gt;</p>
<p>一时间，感觉做一个python版的整站爬取工作，需要处理的细节还是很多，而我明天可能要回无锡，所以时间并不多，就在搜索引擎上找到一款软件：WinHTTracker.</p>
<p>下载地址：<a href="http://www.httrack.com/page/2/" target="_blank" rel="external">http://www.httrack.com/page/2/</a> 网站做的挺简陋的。。。</p>
<p>下载下来安装即可，进入软件可以设置语言，我选择的简体中文。</p>
<p>首先需要设置工程名字，比如我的：AndroidOfficalDocument,下面的那个叫做工程目录可以不填，总文件保存位置选择一个空间较大的目录(因为不知道待爬取的网站的源码有多少空间，所以大点总比小的好)。</p>
<p>然后就是等待镜像过程了~</p>
<p><img src="http://lxctest.qiniudn.com/2016-10-30_11:41:10_QQ截图20161030114047.jpg?imageView2/0/w/900" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天晚上本来想看android文档，使用之前好久没用的Lantern，发现已经不能打开墙外网站了，于是就想着android官方文档很重要，而且可能随时会看，就想着自己做一个镜像网站。&lt;/p&gt;
&lt;p&gt;本来想的是使用Python爬虫，将developer.android.com
    
    </summary>
    
      <category term="未分类" scheme="http://www.orzangleli.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Python3 实现淘女郎照片爬虫 （完整版教程）</title>
    <link href="http://www.orzangleli.com/2016/10/28/Python3%20%E5%AE%9E%E7%8E%B0%E6%B7%98%E5%A5%B3%E9%83%8E%E7%85%A7%E7%89%87%E7%88%AC%E8%99%AB%20%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%E6%95%99%E7%A8%8B%EF%BC%89/"/>
    <id>http://www.orzangleli.com/2016/10/28/Python3 实现淘女郎照片爬虫 （完整版教程）/</id>
    <published>2016-10-27T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:54.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python3-实现淘女郎照片爬虫-（完整版教程）"><a href="#Python3-实现淘女郎照片爬虫-（完整版教程）" class="headerlink" title="Python3 实现淘女郎照片爬虫 （完整版教程）"></a>Python3 实现淘女郎照片爬虫 （完整版教程）</h1><hr>
<h2 id="一-项目介绍"><a href="#一-项目介绍" class="headerlink" title="一. 项目介绍"></a>一. 项目介绍</h2><p>本项目通过Python 3实现一个爬取淘女郎网页上的美女的头像和详细介绍帖子中的所有图片并下载到本地来。</p>
<p><strong>Todo:</strong><br>1. 将图片自动上传到七牛等云存储空间中<br>2. 将图片的信息添加到在线数据库中</p>
<h2 id="二-知识点"><a href="#二-知识点" class="headerlink" title="二. 知识点"></a>二. 知识点</h2><ol>
<li>使用Python 3编程</li>
<li>使用BeautifulSoup解析html网页</li>
<li>使用Selenium抓取动态网页</li>
<li>下载文件的几种方式</li>
<li>正则表达式的使用</li>
</ol>
<h2 id="三-项目效果"><a href="#三-项目效果" class="headerlink" title="三. 项目效果"></a>三. 项目效果</h2><p>这是我们要爬取的目标页面：</p>
<p>淘女郎：<a href="https://mm.taobao.com/search_tstar_model.htm" target="_blank" rel="external">https://mm.taobao.com/search_tstar_model.htm</a></p>
<p><strong>目标页面</strong></p>
<p><img src="http://lxctest.qiniudn.com/2016-10-28_17:45:12_111111.jpg?imageView2/0/w/600" alt=""><br><strong>爬取后的本地目录</strong><br><img src="https://dn-anything-about-doc.qbox.me/document-
uid30174labid1970timestamp1470190197607.png/wm" alt="此处输入图片的描述"><br><strong>每个目录中的图片</strong></p>
<p><img src="https://dn-anything-about-doc.qbox.me/document-
uid30174labid1970timestamp1470190356134.png/wm" alt="此处输入图片的描述"></p>
<h2 id="四-项目实战"><a href="#四-项目实战" class="headerlink" title="四. 项目实战"></a>四. 项目实战</h2><h1 id="4-1-安装需要使用的库"><a href="#4-1-安装需要使用的库" class="headerlink" title="4.1 安装需要使用的库"></a>4.1 安装需要使用的库</h1><p>以下是本项目需要使用到的库文件：</p>
<pre><code>from bs4 import BeautifulSoup
import urllib
from selenium import webdriver
import time
import os
import re
import requests
</code></pre><p>需要安装的几个库是bs4，selenium,requests.安装方式是使用pip，分别运行下面的命令：</p>
<pre><code>pip install BeautifulSoup4
pip install selenium
pip install requests
pip install html5lib
</code></pre><p>Selenium<br>是一个强大的网络数据采集工具，最初是为网站自动化测试而开发的。近几年，他还被广泛用于获取精确的网站快照，因为他们可以直接运行在浏览器上。Selenium<br>可以让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作上是否发生。</p>
<p>Selenium 自己不带浏览器，它需要与第三方浏览器结合在一起使用。我们使用的是PhantomJS浏览器，这是一个无头的浏览器，PhantomJS<br>会把网站加载到内存并执行页面上的 JavaScript，但是不会向用户展示网页的图形化界面，可以用来处理 cookie、JavaScript 及<br>header 信息，以及任何你需要浏览器协助完成的事情。</p>
<p>可以去链接下载，也可以自行搜索下载：</p>
<p>链接：<a href="http://pan.baidu.com/s/1eSLrpzs" target="_blank" rel="external">http://pan.baidu.com/s/1eSLrpzs</a> 密码：vsq9</p>
<h1 id="4-2-项目目标"><a href="#4-2-项目目标" class="headerlink" title="4.2 项目目标"></a>4.2 项目目标</h1><ol>
<li>抓取淘女郎页面中美女的封面，昵称和城市</li>
<li>抓取个人主页中图片</li>
<li>将每个美女的图片以文件夹的形式存储在文件夹中</li>
</ol>
<h1 id="4-3-可行性分析"><a href="#4-3-可行性分析" class="headerlink" title="4.3 可行性分析"></a>4.3 可行性分析</h1><p>淘女郎首页上的源码信息是公开的，本次实验仅仅是用来技术实践，并不带盈利性目的，也不将图片用于其他商业环境，并不会产生商业上的产权纠纷，所以这个项目是可行的。</p>
<h1 id="4-4-流程说明"><a href="#4-4-流程说明" class="headerlink" title="4.4 流程说明"></a>4.4 流程说明</h1><p>通过 Selenium Webdriver 获得目标页面源码，之后通过 BeautifulSoup<br>解析概源码，通过正则表达式提取出模特名字、所在城市、身高、体重，个人主页、封面图片地址等信息，根据模特名字和城市建立文件夹。</p>
<p>再次通过 Selenium Webdriver 获得模特个人主页的页面源码，之后通过 BeautifulSoup<br>解析源码，通过正则获得页面艺术照的URL地址信息。</p>
<p>最后通过 urllib 内置库，打开图片地址，通过二进制读写的方式获得模特艺术照，并将艺术照存在相应文件夹里面。</p>
<h1 id="4-5-网页源码分析"><a href="#4-5-网页源码分析" class="headerlink" title="4.5 网页源码分析"></a>4.5 网页源码分析</h1><p><img src="http://i.imgur.com/gtNM6Un.jpg" alt=""></p>
<p>图中的1,2,3,4分别代表该MM的个人介绍主页地址，封面图片地址，名字和城市，身高体重。第四个我们不使用，只需要获取前三个信息即可。进入个人主页，我们继续类似前面的审查元素，可以看到</p>
<pre><code>&lt;img style=&quot;width: 630.0px;float: none;margin: 10.0px;height: 945.0px;&quot; width=&quot;630&quot; height=&quot;945&quot; src=&quot;//img.alicdn.com/imgextra/i2/927018118/TB1vpJVNVXXXXXzaXXXXXXXXXXX_!!0-tstar.jpg&quot;&gt;
</code></pre><p>里面的图片的标签都是img，而且图片的网址前面是一样的，因此可以使用正则表达式来匹配图片地址：</p>
<pre><code>^\/\/img\.alicdn\.com\/imgextra\/.*\.jpg$
</code></pre><p>这样可以过滤掉其他图片。</p>
<h1 id="4-6-程序实战"><a href="#4-6-程序实战" class="headerlink" title="4.6 程序实战"></a>4.6 程序实战</h1><p>首先导入要使用的库</p>
<pre><code>from bs4 import BeautifulSoup
import urllib
from selenium import webdriver
import time
import os
import re
import requests
</code></pre><p>建一个类，叫做Taonvlang,里面有几个函数：</p>
<p>get_detail_imgs(self,detail_url,dir_name): 根据detail_url获取个人主页图片，并存到目录dir_name中</p>
<p>get_all_data(self): 获取主页的所有的美女封面和个人主页</p>
<p><strong>init</strong>(self,driver,homePage,outputDir): 初始化函数，初始化类中变量</p>
<p>具体查看代码</p>
<pre><code>from bs4 import BeautifulSoup
import urllib
from selenium import webdriver
import time
import os
import re
import requests

class Taolvlang(object):
    def __init__(self,driver,homePage,outputDir):
        self.driver = driver
        self.homePage = homePage
        self.outputDir = outputDir

    def get_detail_imgs(self,detail_url,dir_name):
        num = 0    #计数器，用于统计页面上的图片，作为图片名字
        self.driver.get(detail_url)  #访问个人主页
        js=&quot;var q=document.documentElement.scrollTop=10000&quot;
        self.driver.execute_script(js)    #执行JS脚本，这个脚本主要是滚动页面到最下面，
        #因为有些网页是动态加载的，用户滑动到哪里加载到哪里
        bs = BeautifulSoup(driver.page_source,&quot;html5lib&quot;)   #使用BeautifulSoup解析网页源码，使用的是html5lib,如果不安装这个库，会报错
        allImage = bs.findAll(&quot;img&quot;,{&quot;src&quot;:re.compile(&quot;^\/\/img\.alicdn\.com\/imgextra\/.*.jpg$&quot;)}) #使用正则表达式匹配所有图片 
        for image in allImage:
            img_url = image[&quot;src&quot;]    #获取图片的src
            if not img_url.startswith(&quot;http:&quot;): 
                img_url = &quot;http:&quot;+img_url    #给图片地址加上http：
            num = num +1    #计数器+1
            r = requests.get(img_url)   #使用requests获取图片
            if not os.path.exists(&quot;%s/%d.jpg&quot;%(dir_name,num)):    #判断是否已经存在这个文件了
                with open(&quot;%s/%d.jpg&quot;%(dir_name,num),&quot;wb&quot;) as pic:
                    pic.write(r.content)    #不存在的话就保存到文件中

    def get_all_data(self):  
        self.driver.get(homePage)   #访问主页
        js=&quot;var q=document.documentElement.scrollTop=10000&quot;
        self.driver.execute_script(js)
        time.sleep(3)    #等待网页加载完成
        self.driver.get_screenshot_as_file(&quot;1.jpg&quot;)    #保存网页截图
        bs = BeautifulSoup(self.driver.page_source,&quot;html5lib&quot;)    #使用BeautifulSoup解析网页源码，使用的是html5lib,如果不安装这个库，会报错
        allItem = bs.findAll(class_=&quot;item&quot;)   #找到所有的项，是class 为item的
        for item in allItem:
            detail_url = item.find(class_=&quot;item-link&quot;)[&quot;href&quot;]  #获取个人主页连接
            header_img_url = item.find(&quot;img&quot;)[&quot;src&quot;]   #获取封面图片链接
            dir_name = outputDir+&quot;%s_%s&quot;%(item.find(class_=&quot;name&quot;).get_text(),item.find(class_=&quot;city&quot;).get_text())   #获取名字和城市名组成文件夹名字
            if not os.path.exists(dir_name):   #如果文件夹不存在新建
                os.makedirs(dir_name)
            if not detail_url.startswith(&quot;http:&quot;):
                detail_url = &quot;http:&quot;+detail_url
            if not header_img_url.startswith(&quot;http:&quot;):
                header_img_url = &quot;http:&quot;+header_img_url
            print(&quot;detail_url=%s&quot;%detail_url)
            print(&quot;header_img_url=%s&quot;%header_img_url)
            #将头像存入目录
            if not os.path.exists(outputDir+&quot;%s/0.jpg&quot;%dir_name):
                urllib.request.urlretrieve(header_img_url,outputDir+&quot;%s/0.jpg&quot;%dir_name)
            #获取详细帖子中的照片
            self.get_detail_imgs(detail_url,dir_name)


#本地浏览器路径        
browserPath = &quot;phantomjs.exe&quot;
#主页路径
homePage = &apos;https://mm.taobao.com/search_tstar_model.htm?&apos;
#输出目录
outputDir = &quot;/photos/&quot;   
driver = webdriver.PhantomJS(executable_path = browserPath)
#实例化类，执行获取数据
taoObj = Taolvlang(driver,homePage,outputDir)
taoObj.get_all_data()
</code></pre><h2 id="五-项目地址"><a href="#五-项目地址" class="headerlink" title="五.项目地址"></a>五.项目地址</h2><p><a href="https://github.com/hust201010701/TaonvlangCrawler" target="_blank" rel="external">https://github.com/hust201010701/TaonvlangCrawler</a></p>
<p>欢迎大家Star.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python3-实现淘女郎照片爬虫-（完整版教程）&quot;&gt;&lt;a href=&quot;#Python3-实现淘女郎照片爬虫-（完整版教程）&quot; class=&quot;headerlink&quot; title=&quot;Python3 实现淘女郎照片爬虫 （完整版教程）&quot;&gt;&lt;/a&gt;Python3 实现淘
    
    </summary>
    
      <category term="未分类" scheme="http://www.orzangleli.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 3.5的环境下使用opencv 3.1版本</title>
    <link href="http://www.orzangleli.com/2016/10/21/Python%203.5%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8opencv%203.1%E7%89%88%E6%9C%AC/"/>
    <id>http://www.orzangleli.com/2016/10/21/Python 3.5的环境下使用opencv 3.1版本/</id>
    <published>2016-10-20T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:54.781Z</updated>
    
    <content type="html"><![CDATA[<p>本来照着这个教程学习OpenCV，说3.5版本不能使用opencv,需要转换版本，可以是用的是linux命令，我也看不懂。上网搜了下，可以在3.5中使用opencv的，安装方法就是下载<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/6kbpejrn/opencv_python-3.1.0-cp35-cp35m-win_amd64.whl" target="_blank" rel="external">opencv<br>for<br>python</a>.<br>然后新建一个py脚本进行测试，脚本内容为：</p>
<pre><code>import cv2
import numpy as np
image = cv2.imread(&quot;1.jpg&quot;)
cv2.imshow(&quot;Image&quot;,image)
cv2.waitKey(0)
</code></pre><p>需要提前安装numpy，使用 pip install numpy .</p>
<p>当然会提示这样的错误：</p>
<pre><code>Traceback (most recent call last):
File &quot;test.py&quot;, line 1, in &lt;module&gt;
import cv2
ImportError: DLL load failed: 找不到指定的模块。
</code></pre><p>这时候，安装一个vs的C++库就行了，下载地址：</p>
<p><a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=48145" target="_blank" rel="external">https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=48145</a></p>
<p>安装完成后，就发现可以正常显示图片了~~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来照着这个教程学习OpenCV，说3.5版本不能使用opencv,需要转换版本，可以是用的是linux命令，我也看不懂。上网搜了下，可以在3.5中使用opencv的，安装方法就是下载&lt;a href=&quot;http://www.lfd.uci.edu/~gohlke/pytho
    
    </summary>
    
      <category term="Python" scheme="http://www.orzangleli.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.orzangleli.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeapMotion 在Unity中的手势识别</title>
    <link href="http://www.orzangleli.com/2016/10/12/LeapMotion%20%E5%9C%A8Unity%E4%B8%AD%E7%9A%84%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/"/>
    <id>http://www.orzangleli.com/2016/10/12/LeapMotion 在Unity中的手势识别/</id>
    <published>2016-10-11T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:54.356Z</updated>
    
    <content type="html"><![CDATA[<p>今天终于把LeapMotion的手势（特指静态手势）识别搞懂了，现在以下记录。</p>
<p>首先识别的脚本是绑定在物理手臂上。对手势的识别是通过对手势的分析做出来的。如果你的手势是比较复杂的手势，例如下图：<br><img src="http://i.imgur.com/MgEXWgx.png" alt=""></p>
<p>这个手势几个特点：</p>
<ol>
<li>大拇指和食指需要伸出；</li>
<li>大拇指指向正上方；</li>
<li>食指指向左边。</li>
</ol>
<p>而且这三个条件之间的关系是And，所以需要添加一个逻辑控制模块DetectorLogicGate<br>，这个模块可以将多个条件进行与或运算，而且可以对输出进行取非运算。</p>
<p><img src="http://i.imgur.com/gJvq0fY.png" alt=""></p>
<p>下面详细介绍:</p>
<p>1.代表如果混合逻辑满足条件时的动作。</p>
<p>2.代表如果混合逻辑不满足条件时的动作。</p>
<p>3.代表检测器，可以理解为条件，这里就代表上面描述的三个条件。注意到修改size时，Element的元素是不需要自己填写的，应该是系统自动添的，需要注意的是，如果是复杂逻辑的自条件的顺序要紧连。</p>
<p>4.选择运算符，是与还是或。</p>
<p>5.对结果取非运算。</p>
<h3 id="子条件可以有以下几种组合而成"><a href="#子条件可以有以下几种组合而成" class="headerlink" title="子条件可以有以下几种组合而成:"></a>子条件可以有以下几种组合而成:</h3><p>ExtendedFingerDetector : 伸出手指检测，可以指定伸出哪些手指</p>
<p>FingerDirectionDetector ： 手指方向检测，一次只能指定一个方向，如果想指定多个手指的方向，需要添加多个脚本</p>
<p>PalmDirectionDetector ： 手掌方向监测，是从掌心发出的法线方向</p>
<p>还有两个脚本，PinchDetector和ProximityDetector ，因为暂时还不清楚它们的用途，所以暂不介绍。</p>
<p><img src="http://i.imgur.com/EguVj1l.jpg" alt=""></p>
<p>可以从图片中看到，大拇指和食指我指定为Extended,代表需要这两根手指伸出，而OnActivate和OnDeactivate()保持为空，这是因为我现在使用的这个ExtendedFingerDetector是作为复杂运算的子运算，所以里面不需要写输出。另一方面，如果只想单独地判断是否有手指伸出的话，可以直接在里面定义输出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天终于把LeapMotion的手势（特指静态手势）识别搞懂了，现在以下记录。&lt;/p&gt;
&lt;p&gt;首先识别的脚本是绑定在物理手臂上。对手势的识别是通过对手势的分析做出来的。如果你的手势是比较复杂的手势，例如下图：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/
    
    </summary>
    
      <category term="unity3D" scheme="http://www.orzangleli.com/categories/unity3D/"/>
    
    
      <category term="unity3D" scheme="http://www.orzangleli.com/tags/unity3D/"/>
    
  </entry>
  
  <entry>
    <title>Android中上拉、下拉刷新的解决方案总结</title>
    <link href="http://www.orzangleli.com/2016/10/09/Android%E4%B8%AD%E4%B8%8A%E6%8B%89%E3%80%81%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
    <id>http://www.orzangleli.com/2016/10/09/Android中上拉、下拉刷新的解决方案总结/</id>
    <published>2016-10-08T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:53.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android中上拉、下拉刷新的解决方案总结"><a href="#Android中上拉、下拉刷新的解决方案总结" class="headerlink" title="Android中上拉、下拉刷新的解决方案总结"></a>Android中上拉、下拉刷新的解决方案总结</h1><blockquote>
<p>序：<br>android中上拉、下拉刷新在日常的交互中最为常见，而android系统并没有提供完善的解决方案，本文通过总结几种常见的刷新解决方案的优缺点，供各位读者方便选取适合自己的方案。本文的内容控件以RecyclerView为例。</p>
</blockquote>
<p>常见的方案主要有以下几种：</p>
<p><strong>1. SwipeRefreshLayout 解决方案</strong></p>
<p>根据需求不同可以分为两类</p>
<ul>
<li>只需要显示刷新的进度动画</li>
<li>需要在底部显示加载更多</li>
</ul>
<p><strong>2. 第三方自定义控件 解决方案</strong></p>
<ul>
<li><a href="https://github.com/OrangeGangsters/SwipyRefreshLayout" target="_blank" rel="external">SwipyRefreshLayout</a></li>
<li><a href="https://github.com/lynnchurch/PullToRefresh" title="PullToRefresh" target="_blank" rel="external">PullToRefresh</a></li>
<li><a href="https://github.com/bingoogolapple/BGARefreshLayout-Android" target="_blank" rel="external">BGARefreshLayout-Android</a></li>
</ul>
<p>咱们按照顺序依次剖析</p>
<h2 id="1-SwipeRefreshLayout-解决方案"><a href="#1-SwipeRefreshLayout-解决方案" class="headerlink" title="1. SwipeRefreshLayout 解决方案"></a>1. SwipeRefreshLayout 解决方案</h2><p>SwipeRefreshLayout是android官方出的下拉组件，但是只拥有监听下拉刷新的功能，并没有开放上拉刷新的功能，所以这部分我们需要自定义。</p>
<p>以下主要说上拉功能，分为根据需求分为两种：</p>
<ul>
<li>只需要显示刷新的进度动画</li>
<li>需要在底部显示加载更多</li>
</ul>
<h3 id="1-只需要显示刷新的进度动画"><a href="#1-只需要显示刷新的进度动画" class="headerlink" title="1. 只需要显示刷新的进度动画"></a>1. 只需要显示刷新的进度动画</h3><p>监听上拉动作的原理是对RecyclerView设置滑动监听器OnScrollListener，如果当前滑动状态为<code>RecyclerView.SCROLL_STATE_IDLE</code><br>而且当前最后一个可见项的位置正好是列表中最后一项，代码如下：</p>
<pre><code>recyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() {
    @Override
    public void onScrollStateChanged(RecyclerView recyclerView,
                                     int newState) {
        super.onScrollStateChanged(recyclerView, newState);
        if (newState == RecyclerView.SCROLL_STATE_IDLE
                &amp;&amp; lastVisibleItem + 1 == adapter.getItemCount()) {
            swipeRefreshLayout.setRefreshing(true);
            //在这里添加请求数据代码，请求完成后 swipeRefreshLayout.setRefreshing(false);
        }
    }
    @Override
    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
        super.onScrolled(recyclerView, dx, dy);
        lastVisibleItem = linearLayoutManager.findLastVisibleItemPosition();
    }

});
</code></pre><p>显示效果为，上拉时也显示刷新提示，和下拉的那个没有区别，只是提示刷新，所以用户体验略差点，但是使用方法简单。</p>
<p><img src="http://pic.sdodo.com/tool/picadjust/r.php?fu=../_tempf/1009/1475991116-28.png&amp;fn=1475991116-28.png&amp;type=png" alt=""></p>
<h3 id="2-需要在底部显示加载更多"><a href="#2-需要在底部显示加载更多" class="headerlink" title="2. 需要在底部显示加载更多"></a>2. 需要在底部显示加载更多</h3><p>如果需要给RecyclerView添加刷新提示，比如HeaderView和FooterView 。 先上代码，</p>
<pre><code>public class RecyclerViewAdapter extends RecyclerView.Adapter {

private ArrayList&lt;String&gt; mList;
int load_more_status ;
public static final int PULLUP_LOAD_MORE = 0;
public static final int LOADING_MORE = 1;
public static final int NO_MORE = 2;

RecyclerViewAdapter(Context context)
{
    mList = MainActivity.list;
}
@Override
public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    if (viewType == 0) {
        View view = LayoutInflater.from(parent.getContext()).inflate(
                R.layout.layout_item, null);
        return new ItemViewHolder(view);
    }
    // type == TYPE_FOOTER 返回footerView
    else if (viewType == 1) {
        View view = LayoutInflater.from(parent.getContext()).inflate(
                R.layout.layout_footerview, null);
        return new FooterViewHolder(view);
    }

    return null;
}

public void changeFooterViewState(int status)
{
    load_more_status = status;
    notifyDataSetChanged();
}

public void addMoreItem(List&lt;String&gt; newDatas) {
    mList.addAll(newDatas);
    notifyDataSetChanged();
}

@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
    if(holder instanceof ItemViewHolder)
        ((ItemViewHolder) holder).textView.setText(position+&quot;位置&quot;);
    else
    {
        FooterViewHolder footViewHolder = (FooterViewHolder)holder;
        switch (load_more_status){
            case PULLUP_LOAD_MORE:
                footViewHolder.foot_view_item_tv.setText(&quot;上拉加载更多...&quot;);
                break;
            case LOADING_MORE:
                footViewHolder.foot_view_item_tv.setText(&quot;正在加载更多数据...&quot;);
                break;
            case NO_MORE:
                footViewHolder.foot_view_item_tv.setText(&quot;没有更多数据&quot;);
                break;
        }
    }
}

@Override
public int getItemCount() {
    return mList.size()+1;
}

public class ItemViewHolder extends RecyclerView.ViewHolder
{
    public ItemViewHolder(View itemView) {
        super(itemView);
        textView = (TextView)itemView.findViewById(R.id.textView);
    }
    public TextView textView;
}

class FooterViewHolder extends RecyclerView.ViewHolder {
    public FooterViewHolder(View view) {
        super(view);
        foot_view_item_tv = (TextView) view.findViewById(R.id.textView);
    }
    TextView foot_view_item_tv;
}

@Override
public int getItemViewType(int position) {
        if (position + 1 == getItemCount() )
            return 1;
        else
            return 0;
}
}
</code></pre><p>注意看下就发现有几个地方与普通的不一样：</p>
<ul>
<li>getItemCount 的返回值是 <code>mList.size()+1;</code> 因为当滑动到最后一项时，最后一项需要添加一个提示：“继续滑动加载更多”</li>
<li>添加两个ViewHolder，分别为普通的item和footer的ViewHolder,在onCreateViewHolder中为不同的item绑定不同的布局。</li>
<li>在getItemViewType中建两个ViewType，分别代表普通item和FooterView。</li>
<li>在onBindViewHolder中对FooterView项进行处理，判断当前状态，显示不同的文字。</li>
</ul>
<p>实际上的原理是这样的，其实列表中会一直比数据的List多一项，这一项在列表最后，每次滑动到最后时，就可以看到这个项，而加载不仅是当前最后一项可见而且需要停止滑动，所以滑动到最后一项并松手可以就刷新了，刷新时通过以下代码调用：</p>
<pre><code>recyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() {
        @Override
        public void onScrollStateChanged(RecyclerView recyclerView,
                                         int newState) {
            super.onScrollStateChanged(recyclerView, newState);
            if (newState == RecyclerView.SCROLL_STATE_IDLE
                    &amp;&amp; lastVisibleItem + 1 == adapter.getItemCount()) {
                adapter.changeFooterViewState(RecyclerViewAdapter.LOADING_MORE);
                // 此处在现实项目中，请换成网络请求数据代码，sendRequest .....
                new Handler().postDelayed(new Runnable() {
                    @Override
                    public void run() {
                        List&lt;String&gt; newDatas = new ArrayList&lt;String&gt;();
                        for (int i = 0; i&lt; 5; i++) {
                            int index = i +1;
                            newDatas.add(&quot;more item&quot; + index);
                        }
                        adapter.addMoreItem(newDatas);
                        adapter.changeFooterViewState(RecyclerViewAdapter.PULLUP_LOAD_MORE);
                    }
                }, 2500);
            }
        }
        @Override
        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
            super.onScrolled(recyclerView, dx, dy);
            lastVisibleItem = linearLayoutManager.findLastVisibleItemPosition();
        }

    });
</code></pre><p>效果如图，类似地可以做HeaderView。代码上略微复杂，但是交互效果好，而且目前市面上的大部分啊拍拍也是如此做的。</p>
<p><img src="http://pic.sdodo.com/tool/picadjust/r.php?fu=../_tempf/1009/1475993744-62.png&amp;fn=1475993744-62.png&amp;type=png" alt=""></p>
<p>未完待续。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android中上拉、下拉刷新的解决方案总结&quot;&gt;&lt;a href=&quot;#Android中上拉、下拉刷新的解决方案总结&quot; class=&quot;headerlink&quot; title=&quot;Android中上拉、下拉刷新的解决方案总结&quot;&gt;&lt;/a&gt;Android中上拉、下拉刷新的解决方案
    
    </summary>
    
      <category term="android" scheme="http://www.orzangleli.com/categories/android/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android  关于图片加载速度优化方案</title>
    <link href="http://www.orzangleli.com/2016/09/20/android%20%20%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>http://www.orzangleli.com/2016/09/20/android  关于图片加载速度优化方案/</id>
    <published>2016-09-19T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:53.863Z</updated>
    
    <content type="html"><![CDATA[<p>今天下载了58同城旗下的转转app,发现那里的图片加载速度真的是太快了，快的我基本没有感觉到这是网络上下载的，第一次见到这么快的加载速度，让我惊讶，问了下转转的负责人，他跟我说了几个关键词，这里我记录下，以后方便自己实现体验：</p>
<p>1.webp 合适的尺寸</p>
<p>2.腾讯云cdn</p>
<p>3.fresco框架</p>
<p>4.还有后端的服务</p>
<p>后端我接触不了，我就下次根据前三点做个测试，记录出详细的测试数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天下载了58同城旗下的转转app,发现那里的图片加载速度真的是太快了，快的我基本没有感觉到这是网络上下载的，第一次见到这么快的加载速度，让我惊讶，问了下转转的负责人，他跟我说了几个关键词，这里我记录下，以后方便自己实现体验：&lt;/p&gt;
&lt;p&gt;1.webp 合适的尺寸&lt;/p&gt;
    
    </summary>
    
      <category term="未分类" scheme="http://www.orzangleli.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>对java集合类的理解</title>
    <link href="http://www.orzangleli.com/2016/09/14/%E5%AF%B9java%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://www.orzangleli.com/2016/09/14/对java集合类的理解/</id>
    <published>2016-09-13T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:53.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对java集合类的理解"><a href="#对java集合类的理解" class="headerlink" title="对java集合类的理解"></a>对java集合类的理解</h1><hr>
<h2 id="1-ArrayList扩容策略"><a href="#1-ArrayList扩容策略" class="headerlink" title="1. ArrayList扩容策略"></a>1. ArrayList扩容策略</h2><p>这段时间，找工作，一方面是辛苦，另一方面也是收获，知道自己的哪些不足或者哪些技术没有完全弄清楚，是一个不错的检测自己的方式。</p>
<blockquote>
<p>-面试官问道：说下ArrayList和LinkedList的区别？</p>
</blockquote>
<p>首先这道题的答案我当时是知道的，我开始说ArrayList是动态数组，LinkedList是链表，然后面试官打断我：</p>
<blockquote>
<ul>
<li>ArrayList是怎么实现动态数组的？</li>
</ul>
</blockquote>
<p>&gt;</p>
<p>当时就有点懵，实在想不起来了，我就按照我的想法说：</p>
<blockquote>
<ul>
<li>里面用一个数组存数据，当新加的数据超出数组长度的时候，就新建一个数组长度多1的数组，然后把之前的数组复制过去，在添加新的数组。</li>
</ul>
</blockquote>
<p>&gt;</p>
<p>面试官又说</p>
<blockquote>
<ul>
<li>那我有需要添加一个数据呢？继续增加1个长度在复制？</li>
</ul>
</blockquote>
<p>&gt;</p>
<p>面试过后，我就查阅ArrayList的源代码（jdk 1.8.0_101）：</p>
<pre><code>@Override public boolean add(E object) {
    Object[] a = array;
    int s = size;
    if (s == a.length) {
        Object[] newArray = new Object[s +
                (s &lt; (MIN_CAPACITY_INCREMENT / 2) ?
                 MIN_CAPACITY_INCREMENT : s &gt;&gt; 1)];
        System.arraycopy(a, 0, newArray, 0, s);
        array = a = newArray;
    }
    a[s] = object;
    size = s + 1;
    modCount++;
    return true;
}
</code></pre><p>具体解释下这段代码，在添加新元素时，首先判断当前容量是否超过MIN_CAPACITY_INCREMENT / 2 =<br>6，如果不超过6就直接把长度变为s+12,否则当容量大于6时，扩容为之前容量的1.5倍。再使用System.arraycopy复制数组，添加新元素。</p>
<p>而在jdk1.7版本，扩容策略上略有不同：</p>
<pre><code>private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre><p>扩容策略为新的数组长度是之前的1.5倍，然后再进行判断，如果当前新长度小于当前最小容量，数组长度就等于最小容量，如果新的长度长度大于最大长度，就返回hugeCapacity(minCapacity)。</p>
<h2 id="2-ArrayList和Vector区别"><a href="#2-ArrayList和Vector区别" class="headerlink" title="2. ArrayList和Vector区别"></a>2. ArrayList和Vector区别</h2><p>ArrayList和Vector都是动态数组，不过二者的主要区别是Vector内部大部分方法使用syncchronized关键字同步，所以是线程安全的，而ArrayList则不是线程安全的。</p>
<p>所以在单线程或者多线程但是不会同时访问同一个对象时可以使用ArrayList,速度快；多线程操作同一个对象的情况下使用Vector因为安全。</p>
<p>另外，ArrayList和Vector在扩容策略上也有一点区别：</p>
<blockquote>
<ul>
<li><p>ArrayList的策略上一段文字已经说明，基本可以概述为容量满时扩容为原来的1.5倍；</p>
</li>
<li><p>而Vector则是在容量满时扩容为原来的2倍。</p>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<p><em>注：CopyOnWriteArrayList是线程安全的ArrayList,一般来说可以替代Vector使用</em></p>
<h2 id="3-ArrayList和LinkedList的区别"><a href="#3-ArrayList和LinkedList的区别" class="headerlink" title="3.ArrayList和LinkedList的区别"></a>3.ArrayList和LinkedList的区别</h2><p>ArrayList是线性表结构，而LinkedList是链表结构。<br>ArrayList内部由数组实现，数组可以由下标快速寻址，所以ArrayList的get和set速度很快。<br>LinkedList内部使用Node类包含上一个节点，下一个节点的指针和当前节点的值，所以对于LinkedList<br>使用add和remove速度很快，而get和set则需要一个遍历来寻址节点。</p>
<p>LinkedList还可以实现队列，双向队列，栈等数据结构。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对java集合类的理解&quot;&gt;&lt;a href=&quot;#对java集合类的理解&quot; class=&quot;headerlink&quot; title=&quot;对java集合类的理解&quot;&gt;&lt;/a&gt;对java集合类的理解&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-ArrayList扩容策略&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="面试" scheme="http://www.orzangleli.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://www.orzangleli.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义弹幕 View</title>
    <link href="http://www.orzangleli.com/2016/09/05/Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%B9%E5%B9%95%20View/"/>
    <id>http://www.orzangleli.com/2016/09/05/Android 自定义弹幕 View/</id>
    <published>2016-09-04T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:53.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-自定义弹幕-View-高度自定义"><a href="#Android-自定义弹幕-View-高度自定义" class="headerlink" title="Android 自定义弹幕 View 高度自定义"></a>Android 自定义弹幕 View 高度自定义</h1><p>##<br><a href="https://github.com/hust201010701/Danmu/tree/master#1自定义弹幕的model层" target="_blank" rel="external"></a>1.自定义弹幕的Model层</p>
<p>本着MVC的框架，弹幕分为弹幕的Model层和View层，Activity中负责Controller层连接二者。 自定义一个DanmuText类</p>
<pre><code>private String content ;
private int textSize ;
private int textColor;
private int x;
private int y;
private double xRate;
private double yRate;
private Paint paint;
private boolean isShow ;
private int speed ;
private int width;
private int height;
private int orientation; //方向，0代表水平，1代表竖直
private int antiDirection; //是否反方向运动，0代表否，1代表是
</code></pre><p>分别定义以上弹幕属性，然后添加get，set方法。 并添加默认构造方法：</p>
<pre><code>DanmuText()
{
    paint = new Paint();
    paint.setColor(Color.BLUE);
    paint.setTextSize(80);
    width = 0;
    speed = 1;
    xRate = yRate = Math.random();
    orientation = 0;
    antiDirection = 0;
    new Thread(new DanmuRollRunnable()).start();
}
</code></pre><p>在构造方法中启动一个线程，以对弹幕进行滚动处理。</p>
<pre><code>public class DanmuRollRunnable implements Runnable {
        @Override
        public void run() {
            while (true) {
                if(orientation == 0)
                    x += speed;
                else
                    y += speed;
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
}
</code></pre><p>DanmuRollRunnable 中是一个死循环，每隔10ms判断一次，orientation 代表<br>弹幕的滚动方向是水平的还是竖直的，0代表水平，1代表竖直。</p>
<p>##<br><a href="https://github.com/hust201010701/Danmu/tree/master#2自定义弹幕view层" target="_blank" rel="external"></a>2.自定义弹幕View层</p>
<p>自定义一个DanmuView类，DanmuView是继承自View，其中主要的变量是</p>
<pre><code>private String mOrientation = &quot;horizontal&quot;;
private boolean mAntidirection = false;
private int width;
private int height;
ArrayList&lt;DanmuText&gt; list;
</code></pre><p>mOrientation 和 mAntidirection 用来保存从XML文件中获取的弹幕的排列方向和运动方向。<br>width和height用于保存DanmuView的宽和高。list用于动态存储弹幕DanmuText类。</p>
<p>重点： 在onDraw中对list中所有弹幕进行判断处理。</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    for (int i = 0; i &lt; list.size(); i++) {
        if(list.get(i).getAntiDirection() == 0) {
            //竖直方向运动
            if (list.get(i).getOrientation() == 1) {
                if (list.get(i).getY() &lt; height + list.get(i).getHeight()) {
                    canvas.drawText(list.get(i).getContent(), (int) (list.get(i).getxRate() * width), height - list.get(i).getY(), list.get(i).getPaint());
                    postInvalidate();
                } else {
                    list.get(i).setShow(false);
                    removeDanmu(i);
                    postInvalidate();
                }
            } else {
                if (list.get(i).getX() &lt; width + list.get(i).getWidth()) {
                    canvas.drawText(list.get(i).getContent(), width - list.get(i).getX(), (int) (list.get(i).getyRate() * height), list.get(i).getPaint());
                    postInvalidate();
                } else {
                    list.get(i).setShow(false);
                    removeDanmu(i);
                    postInvalidate();
                }
            }
        }
        else
        {
            //竖直方向运动
            if (list.get(i).getOrientation() == 1) {
                if (list.get(i).getY() &lt; height) {
                    canvas.drawText(list.get(i).getContent(), (int) (list.get(i).getxRate() * width), list.get(i).getY() - list.get(i).getHeight(), list.get(i).getPaint());
                    postInvalidate();
                } else {
                    list.get(i).setShow(false);
                    removeDanmu(i);
                    postInvalidate();
                }
            } else {
                if (list.get(i).getX() &lt; width) {
                    canvas.drawText(list.get(i).getContent(), list.get(i).getX() - list.get(i).getWidth(), (int) (list.get(i).getyRate() * height), list.get(i).getPaint());
                    postInvalidate();
                } else {
                    list.get(i).setShow(false);
                    removeDanmu(i);
                    postInvalidate();
                }
            }
        }
    }

}
</code></pre><p>同时增加添加弹幕和移除弹幕的方法：</p>
<pre><code>public void addDanmu(DanmuText text) {
    if (mOrientation.equals(&quot;vertical&quot;))
        text.setOrientation(1);
    else
        text.setOrientation(0);
    if (mAntidirection)
        text.setAntiDirection(1);
    else
        text.setAntiDirection(0);
    list.add(text);
}

public void removeDanmu(int i) {
    list.remove(i);
}
</code></pre><p>3.在Activity中对弹幕进行调用</p>
<pre><code>package com.orzangleli.danmu;

import android.graphics.Color;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;

import java.util.Random;

public class MainActivity extends AppCompatActivity {

    String danmu[] = new String[]{&quot;这是一个Danmu Demo&quot;,&quot;它可以自定义Danmu的速度&quot;,&quot;方向&quot;,&quot;还有颜色&quot;,&quot;文本大小&quot;,&quot;还有滑动方向&quot;};
    DanmuView danmuView;
    EditText message;
    Button send;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        toolbar.setOnMenuItemClickListener(onMenuItemClick);

        danmuView = (DanmuView) this.findViewById(R.id.danmuView);
        message = (EditText) this.findViewById(R.id.message);
        send = (Button) this.findViewById(R.id.send);

        send.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if(!message.getText().toString().trim().equals(&quot;&quot;))
                {
                    DanmuText danmuText = new DanmuText();
                    danmuText.setContent(message.getText().toString().trim());
                    Random random =new Random();
                    danmuText.setTextColor(Color.rgb(random.nextInt(255), random.nextInt(255), random.nextInt(255)));
                    danmuView.addDanmu(danmuText);
                    message.setText(&quot;&quot;);
                }
            }
        });

        for(int i=0;i&lt;danmu.length;i++)
        {
            DanmuText danmuText = new DanmuText();
            danmuText.setContent(danmu[i]);
            Random random =new Random();
            danmuText.setTextColor(Color.rgb(random.nextInt(255), random.nextInt(255), random.nextInt(255)));
            danmuView.addDanmu(danmuText);
        }

    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main_menu, menu);
        return true;
    }

    private Toolbar.OnMenuItemClickListener onMenuItemClick = new Toolbar.OnMenuItemClickListener() {
        @Override
        public boolean onMenuItemClick(MenuItem menuItem) {
            switch (menuItem.getItemId()) {
                case R.id.action_vertical:
                    danmuView.setOrientation(&quot;vertical&quot;);
                    break;
                case R.id.action_horizontal:
                    danmuView.setOrientation(&quot;horizontal&quot;);
                    break;
                case R.id.action_normaldirection:
                    danmuView.setmAntidirection(false);
                    break;
                case R.id.action_antinormaldirention:
                    danmuView.setmAntidirection(true);
                    break;
            }
            return true;
        }
    };

}
</code></pre><p>添加一个效果图：</p>
<p><a href="https://camo.githubusercontent.com/e8e079a4d259df8e4ee1eb7e468d397d457ab46b/687474703a2f2f377872726e692e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f53637265656e5265636f72645f323031362d30392d30352d31332d35332d31342e6d70345f313437333035353632392e6769663f696d61676556696577322f302f772f333630" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/e8e079a4d259df8e4ee1eb7e468d397d457ab46b/687474703a2f2f377872726e692e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f53637265656e5265636f72645f323031362d30392d30352d31332d35332d31342e6d70345f313437333035353632392e6769663f696d61676556696577322f302f772f333630" alt=""></a></p>
<p>项目托管地址：</p>
<p><a href="https://github.com/myst729/wp-reposidget" target="_blank" rel="external">GitHub 仓库挂件 WordPress 插件</a></p>
<h2 id="hust201010701"><a href="#hust201010701" class="headerlink" title="hust201010701 /"></a><a href="https://github.com/hust201010701" target="_blank" rel="external">hust201010701</a> /</h2><p><a href="https://github.com/hust201010701/Danmu" target="_blank" rel="external"><strong>Danmu</strong></a></p>
<p>自定义弹幕视图，可以实现水平/竖直方向，正向/反向弹幕，可以自定义颜色、文字大小等</p>
<p><a href="http://www.orzangleli.com"><strong>http://www.orzangleli.com</strong></a></p>
<p>21 <a href="https://github.com/hust201010701/Danmu/archive/master.zip" target="_blank" rel="external">Download ZIP</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-自定义弹幕-View-高度自定义&quot;&gt;&lt;a href=&quot;#Android-自定义弹幕-View-高度自定义&quot; class=&quot;headerlink&quot; title=&quot;Android 自定义弹幕 View 高度自定义&quot;&gt;&lt;/a&gt;Android 自定义弹幕 
    
    </summary>
    
      <category term="未分类" scheme="http://www.orzangleli.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Android Service 持久运行不被杀死方法总结</title>
    <link href="http://www.orzangleli.com/2016/08/22/Android%20Service%20%E6%8C%81%E4%B9%85%E8%BF%90%E8%A1%8C%E4%B8%8D%E8%A2%AB%E6%9D%80%E6%AD%BB%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.orzangleli.com/2016/08/22/Android Service 持久运行不被杀死方法总结/</id>
    <published>2016-08-21T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:54.102Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>序：好久没有写文字了，并不代表我不在学习，只是学习的过程有些漫长，加上总结需要时间。</p>
</blockquote>
<h1 id="Android-Service-持久运行不被杀死方法总结"><a href="#Android-Service-持久运行不被杀死方法总结" class="headerlink" title="Android Service 持久运行不被杀死方法总结"></a>Android Service 持久运行不被杀死方法总结</h1><p>&gt;<br>简介：Android应用开发中，我们经常会遇到各种各样的场景需要保持Service不被杀死的需求。最常见的即时通讯类软件，由于实时性需求，需要保持消息服务类的运行状态。这里我总结了当下几种常见的解决方法及其利弊。首先申明：迄今为止我没有发现能够通过常规方法达到流氓需求(通过长按home键清除都清除不掉)的方法，目前所有方法都是指通过Android的内存回收机制和普通的第三方内存清除等手段后仍然保持运行的方法。</p>
<h2 id="方法1：申明Service为前台服务和提高Service的优先级"><a href="#方法1：申明Service为前台服务和提高Service的优先级" class="headerlink" title="方法1：申明Service为前台服务和提高Service的优先级"></a>方法1：申明Service为前台服务和提高Service的优先级</h2><p>这里说到了两个小分类，申明Service为前台服务和提高Service的优先级，实际上申明Service为前台服务也是提高服务的优先级，因为Android系统中默认的内存回收顺序(越往下越先回收)是：</p>
<blockquote>
<p>( 引用自：<a href="http://blog.csdn.net/mad1989/article/details/22492519" target="_blank" rel="external">http://blog.csdn.net/mad1989/article/details/22492519</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>前台进程( FOREGROUND_APP)</p>
</li>
<li><p>可视进程(VISIBLE_APP )</p>
</li>
<li><p>次要服务进程(SECONDARY_SERVER )</p>
</li>
<li><p>后台进程 (HIDDEN_APP)</p>
</li>
<li><p>内容供应节点(CONTENT_PROVIDER)</p>
</li>
<li><p>空进程(EMPTY_APP)</p>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<p>具体方法是在Service的onStartCommand方法中初始化Notification对象并将其绑定在服务上成为前台(Foreground)服务。<br>具体代码：</p>
<pre><code>@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    //使用Notification.Builder构造Notification
    Notification.Builder builder = new Notification.Builder(this.getApplicationContext());
    builder.setContentInfo(&quot;补充内容&quot;);
    builder.setContentText(&quot;主内容区&quot;);
    builder.setContentTitle(&quot;通知标题&quot;);
    builder.setSmallIcon(R.mipmap.ic_launcher);
    builder.setTicker(&quot;新消息&quot;);
    builder.setAutoCancel(true);
    builder.setWhen(System.currentTimeMillis());
    Intent intent2 = new Intent(this.getApplicationContext(), MainActivity.class);
    PendingIntent pendingIntent = PendingIntent.getActivity(this.getApplicationContext(), 0, intent2, PendingIntent.FLAG_CANCEL_CURRENT);
    builder.setContentIntent(pendingIntent);
    Notification notification = builder.build();
    //设置为前台服务，必须绑定一个notification对象，实际上也就是说如果你想做持久化的Service就得让用户知道，PID是自定义的整数表明notification的ID
    startForeground(PID, notification);

    return START_STICKY;
}
</code></pre><p>代码中提到：<em>设置为前台服务，必须绑定一个notification对象，实际上也就是说如果你想做持久化的Service就得让用户知道，PID是自定义的整数表明notification的ID</em><br>，实际上有一种方法可以达到前台服务不显示通知栏的效果。</p>
<h3 id="前台服务不显示通知栏"><a href="#前台服务不显示通知栏" class="headerlink" title="前台服务不显示通知栏"></a>前台服务不显示通知栏</h3><p>这里用到的黑科技来自博客：<a href="http://blog.csdn.net/wxx614817/article/details/50669420" target="_blank" rel="external">http://blog.csdn.net/wxx614817/article/details/50669420</a>。文中所提的方法即为：再新开一个辅助Service，onStartCommand里面同样设置为前台服务，而且startForeground(PID,<br>notification)的PID和第一个Service相同，然后在辅助Service中关闭前台服务，这样第一个Service还在运行，但是第二个服务会让通知栏关闭，这样就实现了所需功能。具体实现方式为：</p>
<ol>
<li><p>修改第一个Service里的onStartCommand方法，在后面启动辅助Service. </p>
<p>   @Override<br>   public int onStartCommand(Intent intent, int flags, int startId) {<br>   //使用Notification.Builder构造Notification<br>   Notification.Builder builder = new Notification.Builder(this.getApplicationContext());<br>   builder.setContentInfo(“补充内容”);<br>   builder.setContentText(“主内容区”);<br>   builder.setContentTitle(“通知标题”);<br>   builder.setSmallIcon(R.mipmap.ic_launcher);<br>   builder.setTicker(“新消息”);<br>   builder.setAutoCancel(true);<br>   builder.setWhen(System.currentTimeMillis());<br>   Intent intent2 = new Intent(this.getApplicationContext(), MainActivity.class);<br>   PendingIntent pendingIntent = PendingIntent.getActivity(this.getApplicationContext(), 0, intent2, PendingIntent.FLAG_CANCEL_CURRENT);<br>   builder.setContentIntent(pendingIntent);<br>   Notification notification = builder.build();<br>   //设置为前台服务，必须绑定一个notification对象，实际上也就是说如果你想做持久化的Service就得让用户知道，PID是自定义的整数表明notification的ID<br>   startForeground(PID, notification);</p>
<p>   //启动辅助Service<br>   Intent intent3 = new Intent(MyService.this,AssistService.class);<br>   MyService.this.startService(intent3);</p>
<p>   return START_STICKY;<br>}</p>
</li>
</ol>
<ol>
<li><p>在辅助Service中开启一个同样ID的notification，并取消。 </p>
<p>   @Override<br>   public int onStartCommand(Intent intent, int flags, int startId) {</p>
<pre><code>Notification.Builder builder = new Notification.Builder(this.getApplicationContext());
builder.setContentInfo(&quot;补充内容&quot;);
builder.setContentText(&quot;主内容区&quot;);
builder.setContentTitle(&quot;通知标题&quot;);
builder.setSmallIcon(R.mipmap.ic_launcher);
builder.setTicker(&quot;新消息&quot;);
builder.setAutoCancel(true);
builder.setWhen(System.currentTimeMillis());
Intent intent2 = new Intent(this.getApplicationContext(), MainActivity.class);
PendingIntent pendingIntent = PendingIntent.getActivity(this.getApplicationContext(), 0, intent2, PendingIntent.FLAG_CANCEL_CURRENT);
builder.setContentIntent(pendingIntent);
Notification notification = builder.build();
NotificationManager manager =
        (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
//先显示
startForeground(PID, notification);
//再销毁
stopForeground(true);

return START_STICKY;
</code></pre><p>   }</p>
</li>
</ol>
<p>修改Service优先级比较简单：在AndroidManifest.xml文件中添加intent-<br>fliter,priority值在-1000到1000范围内，数值越高优先级越高。</p>
<pre><code>&lt;service android:name=&quot;.MyService&quot;&gt;
    &lt;intent-filter android:priority=&quot;1000&quot;&gt;
        &lt;action android:name=&quot;com.orzangleli.qqservicekeepdemo&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre><p><strong>测试效果：</strong>这种方法经过测试，在手机较高内存使用率时，大概能够运行5分钟左右（测试手机型号：nubia z7 mini ,内存2G）。这实际上也就表明了其缺点，申明为前台服务只能提高优先级，并不能保证在低内存时不被回收。</p>
<h2 id="方法2：通过BroadcastReceiver-重启服务"><a href="#方法2：通过BroadcastReceiver-重启服务" class="headerlink" title="方法2：通过BroadcastReceiver 重启服务"></a>方法2：通过BroadcastReceiver 重启服务</h2><p>首先解释下BroadcastReceiver的两种注册方式，动态注册和静态注册，两者大多数情况下可以通用，但存在以下l两点区别：</p>
<ol>
<li>动态注册在程序关闭时，无法接收到广播，因为注册广播是在程序运行时执行的。</li>
<li>静态注册虽然可以在程序未打开时接收到广播，但是有三种广播无法静态注册： <ul>
<li>android.intent.action.SCREEN_ON</li>
<li>android.intent.action.SCREEN_OFF</li>
<li>android.intent.action.BATTERY_CHANGED</li>
<li>android.intent.action.CONFIGURATION_CHANGED</li>
<li>android.intent.action.TIME_TICK</li>
</ul>
</li>
</ol>
<p>在测试时，我使用android.intent.action.TIME_TICK动态注册广播接受者，在onReceive方法中添加判断目标服务是否在运行的判断，如果不在运行就重新启动。代码如下：</p>
<pre><code>public class MyBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        if(intent.getAction().equals(Intent.ACTION_TIME_TICK))
        {
            Log.i(&quot;lxc&quot;,&quot;接收到广播了&quot;);
            if(!isServiceRunning(context,&quot;com.orzangleli.qqservicekeepdemo.MyService&quot;))
            {
                Intent service = new Intent(context,MyService.class);
                service .setAction(&quot;com.orzangleli.qqservicekeepdemo&quot;);
                context.startService(service);
            }
        }
    }

    public static boolean isServiceRunning(Context context,String serviceClassName){
        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        final List&lt;ActivityManager.RunningServiceInfo&gt; services = activityManager.getRunningServices(Integer.MAX_VALUE);

        for (ActivityManager.RunningServiceInfo runningServiceInfo : services) {
            if (runningServiceInfo.service.getClassName().equals(serviceClassName)){
                return true;
            }
        }
        return false;
    }

}
</code></pre><p>测试结果：在程序不退出但是服务停止的情况下，的确可以重启服务，但是重启不是即时的，而是每隔1分钟(在每分钟的第0秒触发)，没有尝试其他的静态注册方式，因为我没有找到一个静态注册的广播，它的广播频率比这个android.intent.action.TIME_TICK还要高的，如果各位读者有知道的，麻烦告知下。而在程序完全退出时，动态注册的BroadcastReceiver不再接受广播，所以也就不会重启Service.</p>
<h2 id="方法3-双进程守护"><a href="#方法3-双进程守护" class="headerlink" title="方法3.双进程守护"></a>方法3.双进程守护</h2><p>双进程守护是指开启两个进程，这两个进程相互独立但是又相互守护，如果其中一个进程被杀死，另一个进程则重启该进程，因为一般情况下不会发生两个进程同时死亡的场景，所以在Service常驻功能上能够满足。</p>
<p>这里插上一句话：在手机的应用程序中可以看到我们手机里大部分常驻内存的Service都是两个或以上的，比如下图中的微信电话本，Hola桌面和<del>QQ</del>(后面解释了QQ不是用的这种方法).</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/Screenshot_2016-08-21-22-52-24.png?imageView2/0/w/360" alt="运行中的程序"></p>
<p>具体操作步骤为：</p>
<p><strong>1. 申明Service的进程，主服务和辅助服务不要同一个进程</strong></p>
<pre><code>&lt;service android:name=&quot;.MyService&quot;
            android:process=&quot;:myservice&quot;
            &gt;
            &lt;intent-filter android:priority=&quot;1000&quot;&gt;
                &lt;action android:name=&quot;com.orzangleli.qqservicekeepdemo&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/service&gt;
        &lt;service android:name=&quot;.AssistService&quot;
            android:process=&quot;:assistservice&quot;
            &gt;
        &lt;/service&gt;
</code></pre><p><strong>2. 在两个服务中分别启动一个线程检查另一个服务的状态</strong></p>
<pre><code>class MyRunnable implements  Runnable
{
    @Override
    public void run() {
        while(enable) {
            Log.i(TAG, &quot; 时间： &quot; + Calendar.getInstance().get(Calendar.SECOND));
            keepAssistService();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
private  void keepAssistService(){
    boolean isRun = isServiceRunning(this, Process_Name);
    if (isRun == false) {

            Log.i(TAG,&quot;重新启动 AssistService&quot;);
            Intent intent = new Intent(this,AssistService.class);
            intent .setAction(&quot;com.orzangleli.qqservicekeepdemo&quot;);
            this.startService(intent);
    }

}

public static boolean isServiceRunning(Context context,String serviceClassName){
    final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    final List&lt;ActivityManager.RunningServiceInfo&gt; services = activityManager.getRunningServices(Integer.MAX_VALUE);

    for (ActivityManager.RunningServiceInfo runningServiceInfo : services) {
        if (runningServiceInfo.service.getClassName().equals(serviceClassName)){
            return true;
        }
    }
    return false;
}
</code></pre><p>测试结果：经过一个多小时的使用，后台服务仍然在运行状态。比较完美实现了，唯一的确定就是里面有两个线程循环执行，会导致耗电更快。</p>
<h2 id="方法4-QQ的一像素保持前台服务方法"><a href="#方法4-QQ的一像素保持前台服务方法" class="headerlink" title="方法4.QQ的一像素保持前台服务方法"></a>方法4.QQ的一像素保持前台服务方法</h2><p>先推荐阅读文章： <a href="http://www.expreview.com/39438.html" target="_blank" rel="external">手机QQ后台为何清不掉？MIUI工程师：全靠1像素的页面保命</a></p>
<p>文中提到，QQ通过一个像素，在程序退出时，显示这个像素，使得系统认为该服务为前台服务，所以允许常驻内存，这种方法我不很懂。</p>
<p>我在测试的时候，在Service显示一个悬浮窗，用这个悬浮窗代替QQ的一个像素，但是在运行5分钟左右后，悬浮窗消失同时后台服务也停止运行，不是说有可见的UI的后台服务就是为前台服务了么，怎么也会被杀死。而且如果是用这种方法实现的常驻内存，为什么QQ也会使用到双进程呢？(<strong>更新：经过测试，QQ的双进程并没有守护关系，关闭掉Downloader的那个进程并不会重新启动</strong>)。</p>
<p>现在的问题就是：为什么我在Service中启动的悬浮窗会被杀死呢？本文会持续更新。</p>
<h2 id="方法5：使用一些常见的白名单推送包"><a href="#方法5：使用一些常见的白名单推送包" class="headerlink" title="方法5：使用一些常见的白名单推送包"></a>方法5：使用一些常见的白名单推送包</h2><p>据说使用常见的白名单推送包在保持进行活跃上也有一定效果，例如Jpush，或者内置的系统账户同步系统等，定时推送消息然后启动服务。此方法暂未测试，不知道效果如何，暂时留白。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;序：好久没有写文字了，并不代表我不在学习，只是学习的过程有些漫长，加上总结需要时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Android-Service-持久运行不被杀死方法总结&quot;&gt;&lt;a href=&quot;#Android-Service
    
    </summary>
    
      <category term="android" scheme="http://www.orzangleli.com/categories/android/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【源码解析】UIL的图片缓存策略</title>
    <link href="http://www.orzangleli.com/2016/08/16/%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%91UIL%E7%9A%84%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <id>http://www.orzangleli.com/2016/08/16/【源码解析】UIL的图片缓存策略/</id>
    <published>2016-08-15T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:52.954Z</updated>
    
    <content type="html"><![CDATA[<p>UIL中缓存分为内存缓存（MemoryCache）和磁盘缓存(DiscCache).</p>
<h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>1.强引用缓存</p>
<p><strong>LRUMemoryCache:</strong> 这个类缓存的都是bitmap对象的强引用.强引用只要引用存在，就不会被回收，而且bitmap的数据量很大，很容易导致程序超过最大内存限制，容易发生OOM.LRUMemoryCache就是最近最少使用内存缓存先删除的原理，这样保证程序不会发生OOM.</p>
<p>2.弱引用缓存</p>
<p><strong>WeakMemoryCache:</strong> 这个类缓存的都是bitmap的弱引用，对内存的总大小没有限制，但是不稳定，容易被gc回收掉。</p>
<p>3.强引用和弱引用相结合</p>
<ul>
<li><strong>UsingFreqLimitedMemoryCache:</strong> 先删除最少使用的bitmap</li>
<li><strong>LRULimitedMemoryCache:</strong> 先删除<strong>最近</strong>最少使用的bitmap</li>
<li><strong>FIFOLimitedMemoryCache:</strong> 先删除最先加入缓存的bitmap</li>
<li><strong>LargestLimitedMemortCache:</strong> 先删除最大内存的bitmap</li>
<li><strong>LimitedAgeMemoryCache:</strong> 先删除比设定值早加入缓存中的bitmap</li>
</ul>
<h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><ol>
<li><strong>FileCountLimitedDiscCache:</strong> 当缓存图片个数超过设定值时，先删除最先加入到磁盘中的文件</li>
<li><strong>TotalSizeLimitedDiscCache:</strong> 当缓存图片的总文件大小超过设定值时，先删除最先加入到磁盘中的文件</li>
<li><strong>LimitedAgeDiscCache:</strong> 设置图片存活的最长时间，超过这个时间的，就删除该文件</li>
<li><strong>UnlimitedDiscCache:</strong> 不限制地在磁盘上缓存</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UIL中缓存分为内存缓存（MemoryCache）和磁盘缓存(DiscCache).&lt;/p&gt;
&lt;h3 id=&quot;内存缓存&quot;&gt;&lt;a href=&quot;#内存缓存&quot; class=&quot;headerlink&quot; title=&quot;内存缓存&quot;&gt;&lt;/a&gt;内存缓存&lt;/h3&gt;&lt;p&gt;1.强引用缓存&lt;/p&gt;

    
    </summary>
    
      <category term="android" scheme="http://www.orzangleli.com/categories/android/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="面试" scheme="http://www.orzangleli.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>HTC VIVE VR关卡场景切换原理</title>
    <link href="http://www.orzangleli.com/2016/08/09/HTC%20VIVE%20VR%E5%85%B3%E5%8D%A1%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
    <id>http://www.orzangleli.com/2016/08/09/HTC VIVE VR关卡场景切换原理/</id>
    <published>2016-08-08T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:52.938Z</updated>
    
    <content type="html"><![CDATA[<p>在VR中，有时候不止一个场景，我们需要把他单独的场景连接起来，这里我们模仿普遍的网游中“传送门”的原理。</p>
<p>如图所示，在某一处，有一个传送门标志：</p>
<p><img src="http://www.orzangleli.com/wp-
content/uploads/2016/08/chuansong.gif" alt="chuansong"></p>
<p>然后主角移动到传送门附近时，跳转到下一关。</p>
<p>这里是根据两者之间的距离来判断的，我们要VIVE<br>包中camer(head)来表示主角位置。场景的加载可以通过Application.LoadLevel来切换，在这里之前，我们需要在File-<br>Build中添加需要加载的所有场景，我这里只有两个，系统会自动分配id给它们，如我的两个场景是0和1。</p>
<p><img src="http://www.orzangleli.com/wp-
content/uploads/2016/08/20160809211302.png" alt="20160809211302"></p>
<p>我们新建一个脚本，然后把脚本托给传送门的GameObject.脚本代码为：</p>
<pre><code>using UnityEngine;
using System.Collections;

public class ChangeSence : MonoBehaviour {
    public GameObject cameraRig;
    // Use this for initialization
    void Start () {

    }

    // Update is called once per frame
    void Update () {
        if (Vector3.Distance (cameraRig.transform.position, this.transform.position) &lt; 2f) {
            if (MyApplication.level == 0) {
                Application.LoadLevel (1);
                MyApplication.level = 1;
            } else if (MyApplication.level == 1) {
                Application.LoadLevel (0);
                MyApplication.level = 0;
            }
        }
    }
}
</code></pre><p>恩，主要就是这样。下一讲，我们来看看VIVE控制器下的武器切换原理。</p>
<p>组件我打包了，可以下载：需要unity 5.3+版本。</p>
<p>链接：<a href="http://pan.baidu.com/s/1gfAvRX5" target="_blank" rel="external">http://pan.baidu.com/s/1gfAvRX5</a> 密码：zrk8</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在VR中，有时候不止一个场景，我们需要把他单独的场景连接起来，这里我们模仿普遍的网游中“传送门”的原理。&lt;/p&gt;
&lt;p&gt;如图所示，在某一处，有一个传送门标志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.orzangleli.com/wp-
content/up
    
    </summary>
    
      <category term="HTC VIVE" scheme="http://www.orzangleli.com/categories/HTC-VIVE/"/>
    
    
      <category term="unity3D" scheme="http://www.orzangleli.com/tags/unity3D/"/>
    
      <category term="HTC VIVE" scheme="http://www.orzangleli.com/tags/HTC-VIVE/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D 虚拟现实FPS游戏</title>
    <link href="http://www.orzangleli.com/2016/08/07/Unity3D%20%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9EFPS%E6%B8%B8%E6%88%8F/"/>
    <id>http://www.orzangleli.com/2016/08/07/Unity3D 虚拟现实FPS游戏/</id>
    <published>2016-08-06T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:52.460Z</updated>
    
    <content type="html"><![CDATA[<p>Share the video</p>
<ul>
<li><a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fwww.orzangleli.com%2F2016%2F08%2F07%2Funity3d-%25e8%2599%259a%25e6%258b%259f%25e7%258e%25b0%25e5%25ae%259efps%25e6%25b8%25b8%25e6%2588%258f%2F" target="_blank" rel="external">Facebook</a></li>
<li><a href="https://twitter.com/home?status=Unity3D+%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9EFPS%E6%B8%B8%E6%88%8F+http%3A%2F%2Fwww.orzangleli.com%2F2016%2F08%2F07%2Funity3d-%25e8%2599%259a%25e6%258b%259f%25e7%258e%25b0%25e5%25ae%259efps%25e6%25b8%25b8%25e6%2588%258f%2F" target="_blank" rel="external">Twitter</a></li>
<li><a href="https://plus.google.com/share?url=http%3A%2F%2Fwww.orzangleli.com%2F2016%2F08%2F07%2Funity3d-%25e8%2599%259a%25e6%258b%259f%25e7%258e%25b0%25e5%25ae%259efps%25e6%25b8%25b8%25e6%2588%258f%2F" target="_blank" rel="external">Google+</a></li>
<li><a href="mailto:?body=Check%20the%20amazing%20video%20here%3A%20http%3A%2F%2Fwww.orzangleli.com%2F2016%2F08%2F07%2Funity3d-%25e8%2599%259a%25e6%258b%259f%25e7%258e%25b0%25e5%25ae%259efps%25e6%25b8%25b8%25e6%2588%258f%2F" target="_blank" rel="external">Email</a></li>
</ul>
<p><strong>Embed</strong></p>
<p>Copy and paste this HTML code into your webpage to embed.</p>
<hr>
<p><a href="http://flowplayer.org" target="_blank" rel="external">flowplayer</a></p>
<p><em>00:00</em> __ <em>00:00</em></p>
<p>##</p>
<p>Copy and paste this HTML code into your webpage to embed.</p>
<p>_space_play / pause</p>
<p>_q_unload | stop</p>
<p>_f_fullscreen</p>
<p>_↑__↓_volume</p>
<p>_m_mute</p>
<p>_←__→_seek</p>
<p>_ . _seek to previous</p>
<p><em>1__2</em>… <em>6</em> seek to 10%, 20% … 60%</p>
<ul>
<li>© 2015</li>
<li><a href="http://flowplayer.org" target="_blank" rel="external">About Flowplayer</a></li>
<li><a href="http://flowplayer.org/license" target="_blank" rel="external">GPL based license</a></li>
</ul>
<p><a href="http://flowplayer.org" target="_blank" rel="external"></a></p>
<p>以下为技术细节记录：</p>
<h4 id="1-自动寻路组件-Navigation"><a href="#1-自动寻路组件-Navigation" class="headerlink" title="1.自动寻路组件 Navigation"></a>1.自动寻路组件 Navigation</h4><p>首先在Unity3D中打开Window菜单的Navigation,然后依次选择场景中的模型，然后标记为这三种状态：</p>
<ul>
<li>Walkable</li>
<li>NotWalkable</li>
<li>Jump</li>
</ul>
<p>分别代表该处地形，可以行走，不可以行走和允许跳跃。</p>
<p>然后在需要自动寻迹的目标上添加 Nav Mesh<br>Agent，自动寻迹代理组件。可以设置代理组件的寻迹速度和加速度，然后给目标上添加一个脚本，把它的终点位置设置好。以本游戏为例，就是僵尸自动寻找主角，主角是僵尸的目标，僵尸身上会有Nav<br>Mesh Agent组件。</p>
<p>本游戏中，将所有建筑设置状态后，烘焙后显示寻迹路线（绿色为可以行走的部门）：</p>
<p>特别需要注意的是，如果寻迹路线中断，僵尸是不能通过的，所以只能通过修改某些碰撞器重新烘焙，就可以生成一条连续的寻迹路线。</p>
<p>在脚本中，使用下面的语句设置寻迹目标：</p>
<pre><code>// Update is called once per frame
void Update () {
    if (agent.enabled) {
        agent.destination = player.transform.position;
        if (Vector3.Distance (this.transform.position, player.transform.position) &lt; 2.2f) {
            SwitchAttack (true);    
            agent.Stop ();
        } else {
            SwitchAttack (false);
            agent.Resume ();
        }
    }
}
</code></pre><p>基本原理就是，当寻迹组件激活时，如果僵尸和主角距离超过2.2m则自动追踪主角，如果小于2.2m,就切换为攻击模式。</p>
<h4 id="2-射击原理"><a href="#2-射击原理" class="headerlink" title="2.射击原理"></a>2.射击原理</h4><p>射击就是给子弹一个速度，然后让子弹从发射口发射出去，发射过程中，不断的在子弹的正前方发射射线，射线的长度为0.1m，这样就能检测出射击击中的位置。</p>
<p>具体代码为：</p>
<pre><code>using UnityEngine;
using System.Collections;

public class BulletLife : MonoBehaviour {

    private Vector3 direction;
    public GameObject holePrefab,bloodPrefab;
    private GameObject baozha;


    RaycastHit hit ;
    // Use this for initialization
    void Start () {
        //手枪的发射方向
        direction = -this.transform.right;
        Destroy (gameObject,5);
    }

    // Update is called once per frame
    void Update () {
        Physics.Raycast (this.transform.position, direction, out hit, 0.1f);
    }

    void OnCollisionEnter(Collision c)
    {
        GameObject hole=Instantiate (holePrefab,hit.point,Quaternion.identity) as GameObject;
        hole.transform.parent = hit.collider.transform;
        hole.transform.up = hit.normal;
        baozha = hole.transform.FindChild (&quot;baozha&quot;).gameObject;
        if (c.collider.tag == &quot;Zombie&quot;) {
            hole.transform.FindChild (&quot;Canvas&quot;).gameObject.SetActive (false);
        }
        Destroy (baozha,1.0f);
        Destroy (hole,5f);
        Destroy (gameObject);
    }
}
</code></pre><p><strong>为什么不使用Collider来检测碰撞呢？</strong></p>
<p>因为Collider的检测碰撞实际上是通过在间隔时间内检测是否碰撞到，如果才能返回碰撞结果的，如果物体运动速度很快，被撞物体很薄，如子弹射击木板，因为碰撞持续时间很短，很有可能检测不出碰撞来，这样就会出现一种bug：视觉上子弹穿过了僵尸，但是僵尸并没有死亡。</p>
<p>下面附上这一周完成情况的几张截图和视频链接：</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Share the video&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fwww.orzangleli.com%2F2016%2F08%2F07%2Funi
    
    </summary>
    
      <category term="未分类" scheme="http://www.orzangleli.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
</feed>
