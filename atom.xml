<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>orzangleli</title>
  <subtitle>活在梦里的程序员和设计师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.orzangleli.com/"/>
  <updated>2017-02-13T12:32:05.226Z</updated>
  <id>http://www.orzangleli.com/</id>
  
  <author>
    <name>orzangleli</name>
    <email>orzangleli@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第十一篇 Retrofit— 使用日志级别调试请求</title>
    <link href="http://www.orzangleli.com/2017/02/13/2017-02-13_%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%20Retrofit%E2%80%94%20%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E8%B0%83%E8%AF%95%E8%AF%B7%E6%B1%82/"/>
    <id>http://www.orzangleli.com/2017/02/13/2017-02-13_第十一篇 Retrofit— 使用日志级别调试请求/</id>
    <published>2017-02-12T16:00:00.000Z</published>
    <updated>2017-02-13T12:32:05.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-第十一篇-Retrofit—-使用日志级别调试请求"><a href="#11-第十一篇-Retrofit—-使用日志级别调试请求" class="headerlink" title="11. 第十一篇 Retrofit— 使用日志级别调试请求"></a>11. 第十一篇 Retrofit— 使用日志级别调试请求</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#一-、retrofit-2-中的日志功能">一 、Retrofit 2 中的日志功能</a></li>
<li><a href="#二、日志级别">二、日志级别</a><ul>
<li><a href="#21-none">2.1 None</a></li>
<li><a href="#22-basic">2.2 Basic</a></li>
<li><a href="#23-headers">2.3 Headers</a></li>
<li><a href="#24-body">2.4 Body</a></li>
</ul>
</li>
<li><a href="#三、总结">三、总结</a></li>
<li><a href="#四、在github中实战">四、在Github中实战</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>在深入挖掘Retrofit的网络请求艺术后，本文我们看看Retrofit的调试功能，顺便复习下之前学到的知识点。</p>
<h2 id="一-、Retrofit-2-中的日志功能"><a href="#一-、Retrofit-2-中的日志功能" class="headerlink" title="一 、Retrofit 2 中的日志功能"></a>一 、Retrofit 2 中的日志功能</h2><p>Retrofit2 在网络操作上完全依赖OkHttp.OkHttp的开发者已经发布了一个独立的继承OkHttp的日志拦截工程。你可以把它添加到你项目的<code>build.gradle</code>中：</p>
<pre><code>compile &apos;com.squareup.okhttp3:logging-interceptor:3.3.1&apos;  

在开发APP或者调试程序时，整合了日志功能，能显示请求和响应信息是非常不错的。因为Retrofit 2默认并没有整合日志功能，所以我们需要添加一个日志拦截器到OkHttp上。幸运的是，OkHttp已经为拦截器做好了准备，你需要做的就是激活它。

HttpLoggingInterceptor logging = new HttpLoggingInterceptor();  
// set your desired log level
logging.setLevel(Level.BODY);

OkHttpClient.Builder httpClient = new OkHttpClient.Builder();  
// add your other interceptors …

// add logging as last interceptor
httpClient.addInterceptor(logging);  // &lt;-- this is the important line!

Retrofit retrofit = new Retrofit.Builder()  
   .baseUrl(API_BASE_URL)
   .addConverterFactory(GsonConverterFactory.create())
   .client(httpClient.build())
   .build();
</code></pre><h2 id="二、日志级别"><a href="#二、日志级别" class="headerlink" title="二、日志级别"></a>二、日志级别</h2><p>打印过多信息会爆掉你的Android 监视器，这就是为什么OkHttp的日志拦截器有个日志级别： <code>NONE</code>, <code>BASIC</code>, <code>HEADERS</code>, <code>BODY</code>.现在带你一起看看每一种日志级别并描述它们的输出内容。</p>
<h3 id="2-1-None"><a href="#2-1-None" class="headerlink" title="2.1 None"></a>2.1 None</h3><p><strong>无日志</strong></p>
<p>使用这个日志级别配置开发环境会让你的app跳过所有的日志操作。</p>
<h3 id="2-2-Basic"><a href="#2-2-Basic" class="headerlink" title="2.2 Basic"></a>2.2 Basic</h3><p><strong>打印请求type,url,request body大小，响应状态和response  body的大小</strong></p>
<pre><code>D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1 (277-byte body)  
D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (543ms, -1-byte body) 
</code></pre><p>使用<code>Basic</code>级别会打印最少的请求信息。如果你只对equest body的大小，response  body的大小和响应状态感兴趣，这种日志级别最适合你。</p>
<h3 id="2-3-Headers"><a href="#2-3-Headers" class="headerlink" title="2.3 Headers"></a>2.3 Headers</h3><p><strong>记录请求和响应头，请求类型，url，响应状态</strong></p>
<p>使用<code>Headers</code>级别的日志辉记录请求和响应头。Retrofit或OkHttp默认会添加适当的请求头，但是不会在请求上显示出来，也因为它们是后来才在请求链中被添加上去的。如果你不在Android上截获真实的请求，你什么都看不到。如果你自己添加了请求头，请确保日志拦截器是你最后添加拦截器。如果你最先添加日志拦截器，那请求头上就不会有任何的请求头了。</p>
<p>假设你要自己定义请求头，我们使用<code>Accept</code>和<code>Content-Type</code>这两个字段来验证下输出内容。</p>
<pre><code>D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1  
D/HttpLoggingInterceptor$Logger: Accept: application/json  
D/HttpLoggingInterceptor$Logger: Content-Type: application/json  
D/HttpLoggingInterceptor$Logger: --&gt; END POST  
D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (1039ms)  
D/HttpLoggingInterceptor$Logger: content-type: text/html; charset=utf-8  
D/HttpLoggingInterceptor$Logger: cache-control: no-cache  
D/HttpLoggingInterceptor$Logger: vary: accept-encoding  
D/HttpLoggingInterceptor$Logger: Date: Wed, 28 Oct 2015 08:24:20 GMT  
D/HttpLoggingInterceptor$Logger: Connection: keep-alive  
D/HttpLoggingInterceptor$Logger: Transfer-Encoding: chunked  
D/HttpLoggingInterceptor$Logger: OkHttp-Selected-Protocol: http/1.1  
D/HttpLoggingInterceptor$Logger: OkHttp-Sent-Millis: 1446020610352  
D/HttpLoggingInterceptor$Logger: OkHttp-Received-Millis: 1446020610369  
D/HttpLoggingInterceptor$Logger: &lt;-- END HTTP
</code></pre><p>除了服务器的响应头，你还可以看到使用什么协议以及在各自的发送请求和接受响应所用的毫秒级时间。</p>
<h3 id="2-4-Body"><a href="#2-4-Body" class="headerlink" title="2.4 Body"></a>2.4 Body</h3><p><strong>记录日志请求和响应的请求头和请求体</strong></p>
<p>这是最完整的日志级别，会打印所有请求和响应相关的信息。</p>
<pre><code>D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1  
D/HttpLoggingInterceptor$Logger: --9df820bb-bc7e-4a93-bb67-5f28f4140795  
D/HttpLoggingInterceptor$Logger: Content-Disposition: form-data; name=&quot;description&quot;  
D/HttpLoggingInterceptor$Logger: Content-Transfer-Encoding: binary  
D/HttpLoggingInterceptor$Logger: Content-Type: application/json; charset=UTF-8  
D/HttpLoggingInterceptor$Logger: Content-Length: 37  
D/HttpLoggingInterceptor$Logger:  
D/HttpLoggingInterceptor$Logger: &quot;hello, this is description speaking&quot;  
D/HttpLoggingInterceptor$Logger: --9df820bb-bc7e-4a93-bb67-5f28f4140795--  
D/HttpLoggingInterceptor$Logger: --&gt; END POST (277-byte body)  
D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (1099ms)  
D/HttpLoggingInterceptor$Logger: content-type: text/html; charset=utf-8  
D/HttpLoggingInterceptor$Logger: cache-control: no-cache  
D/HttpLoggingInterceptor$Logger: vary: accept-encoding  
D/HttpLoggingInterceptor$Logger: Date: Wed, 28 Oct 2015 08:33:40 GMT  
D/HttpLoggingInterceptor$Logger: Connection: keep-alive  
D/HttpLoggingInterceptor$Logger: Transfer-Encoding: chunked  
D/HttpLoggingInterceptor$Logger: OkHttp-Selected-Protocol: http/1.1  
D/HttpLoggingInterceptor$Logger: OkHttp-Sent-Millis: 1446021170095  
D/HttpLoggingInterceptor$Logger: OkHttp-Received-Millis: 1446021170107  
D/HttpLoggingInterceptor$Logger: Perfect!  
D/HttpLoggingInterceptor$Logger: &lt;-- END HTTP (8-byte body) 
</code></pre><p>这是唯一一种可以获得响应主体的日志界别。当你和后端开发者有不同意见的时候，用这中日志级别可以显示所有接受到的数据。但是<code>Body</code>级别会在接受大量数据时让你的Android 监视器堵塞。只有在有必要的时候才使用这种日志级别。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>我们希望你能把日志用到你的项目开发中，日志级别的信息会帮助你选择正确的日志级别。尝试不同的日志级别，看看哪个最适合你。即使说<code>Body</code>级别可能会堵塞你的日志监视窗口，但是有可能你只有在显示所有请求细节的时候才能找到你想要的信息。</p>
<h2 id="四、在Github中实战"><a href="#四、在Github中实战" class="headerlink" title="四、在Github中实战"></a>四、在Github中实战</h2><p>要添加日志记录功能，不需要对已有的业务模块进行修改，只要把<code>ServiceGenerator</code>修改下就可以了，看我修改后的代码：</p>
<pre><code>public class ServiceGenerator {

    public static final String API_BASIC_URL = &quot;https://api.github.com/&quot;;
    private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder();

    private static Retrofit.Builder builder =new Retrofit.Builder()
            .baseUrl(API_BASIC_URL)
            .addConverterFactory(GsonConverterFactory.create());

    static HttpLoggingInterceptor logging = new HttpLoggingInterceptor();


    public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass){
        logging.setLevel(HttpLoggingInterceptor.Level.BODY);
        httpClient.addInterceptor(logging);

        Retrofit retrofit = builder.client(httpClient.build()).build();
        return retrofit.create(serviceClass);
    }
}
</code></pre><p>记住，在项目的<code>build.gradle</code>中添加对log拦截器的依赖：</p>
<pre><code>compile &apos;com.squareup.okhttp3:logging-interceptor:3.3.1&apos;
</code></pre><p>在控制台中可以看到很多请求和响应的日志，截图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-16_17_13_21_log.png" alt=""></p>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;11-第十一篇-Retrofit—-使用日志级别调试请求&quot;&gt;&lt;a href=&quot;#11-第十一篇-Retrofit—-使用日志级别调试请求&quot; class=&quot;headerlink&quot; title=&quot;11. 第十一篇 Retrofit— 使用日志级别调试请求&quot;&gt;&lt;/a&gt;1
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第十篇 Retrofit—可选的查询参数</title>
    <link href="http://www.orzangleli.com/2017/01/18/2017-01-18_%E7%AC%AC%E5%8D%81%E7%AF%87%20Retrofit%E2%80%94%E5%8F%AF%E9%80%89%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"/>
    <id>http://www.orzangleli.com/2017/01/18/2017-01-18_第十篇 Retrofit—可选的查询参数/</id>
    <published>2017-01-17T16:00:00.000Z</published>
    <updated>2017-01-18T13:50:30.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-可选的查询参数"><a href="#10-可选的查询参数" class="headerlink" title="10. 可选的查询参数"></a>10. 可选的查询参数</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#一、-retrofit查询参数">一、 Retrofit查询参数</a></li>
<li><a href="#二、-可选的查询参数">二、 可选的查询参数</a></li>
<li><a href="#三、-在github中实战">三、 在Github中实战</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>前几篇文章，带你领略了添加自定义请求头的技术方法。现在，我们来看看在Retofit中如何让参数可选。</p>
<h2 id="一、-Retrofit查询参数"><a href="#一、-Retrofit查询参数" class="headerlink" title="一、 Retrofit查询参数"></a>一、 Retrofit查询参数</h2><p>Retrofit使用注解定义查询参数。方法参数前面定义的注解，指定了要查询的参数的名字。在请求执行时，我们要查询的参数就会传递到URL中。现在我们来看个具体的例子。下面的代码讲的就是一个以<code>/tasks</code>作为API endpoint的请求，它提供了一个选项<code>sort</code>参数以达到排序的目的。</p>
<p>public interface TaskService {<br>    @GET(“/tasks”)<br>    Call<list<task>&gt; getTasks(@Query(“sort”) String order);<br>}</list<task></p>
<p>假设你的API的基本地址是：<code>https://your.api.com</code>,请求就使用上面的<code>TaskService</code>调用<code>getTasks</code>方法，最终形成的请求的URL是这样的：</p>
<pre><code>https://your.api.com/tasks?sort=value-of-order-parameter
</code></pre><h2 id="二、-可选的查询参数"><a href="#二、-可选的查询参数" class="headerlink" title="二、 可选的查询参数"></a>二、 可选的查询参数</h2><p>根据API的设计原则，<code>sort</code>参数应该是可选的。如果你不想在请求中传递这个参数，你可以在方法调用的时候直接传递<strong><code>null</code></strong>给<code>order</code>。</p>
<pre><code>service.getTasks(null);  
</code></pre><p>Retrofit会跳过<code>null</code>参数，并且在实现请求的时候忽略它们。记住，你不可以把<code>null</code>传递给这几种类型:<code>int</code>,<code>float</code>,<code>long</code>等。但是如果你使用的是<code>Integer</code>,<code>Float</code>,<code>Long</code>，那么就可以传递<code>null</code>了。</p>
<p>下面的例子描述的就是给之前提到的集中数据类型定义的请求客户端。</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks(
        @Query(&quot;sort&quot;) String order,
        @Query(&quot;page&quot;) Integer page);
}
</code></pre><p>现在，你可以给<code>order</code>或<code>page</code>中任何一个参数传递<code>null</code>了。</p>
<pre><code>service.getTasks(null, null); 
</code></pre><p>这样就是了，可选参数的查询，让我们总结下：实现可选参数的方法就是在定义客户端接口时，如果参数类型是<code>int</code>,’long’等基本数据类型，需要把这个参数的类型修改为其包装类，如<code>Integer</code>,<code>Long</code>等，如果本身就是封装的类，那在接口定义时就不需要处理。然后在调用客户端接口中的方法时，可以使用<code>null</code>传递给某些参数，这样在API请求时，就会自动忽略值为<code>null</code>的参数，从而达到参数可选的功能。</p>
<h2 id="三、-在Github中实战"><a href="#三、-在Github中实战" class="headerlink" title="三、 在Github中实战"></a>三、 在Github中实战</h2><p>我们以Github中<code>Search repositories</code>仓库搜索的API为例，展示下可选查询参数的demo.<br>从<a href="https://developer.github.com/v3/search/#search-repositories" target="_blank" rel="external">https://developer.github.com/v3/search/#search-repositories</a>中，我们可以找到搜索仓库的API使用方法。</p>
<pre><code>GET /search/repositories
</code></pre><table>
<thead>
<tr>
<th style="text-align:center">Name</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">q</td>
<td style="text-align:center">string</td>
<td style="text-align:center">搜索的关键字</td>
</tr>
<tr>
<td style="text-align:center">sort</td>
<td style="text-align:center">string</td>
<td style="text-align:center">排序依据参数，可以是 <code>stars</code>, <code>forks</code>, 或者 <code>updated</code>. 默认是按匹配的程度排序。</td>
</tr>
<tr>
<td style="text-align:center">order</td>
<td style="text-align:center">string</td>
<td style="text-align:center">决定搜索结果的排序是增序还是减序，可以是asc或 desc. 默认是: desc（减序）</td>
</tr>
</tbody>
</table>
<p>好，现在我们把GithubClient接口修改下，注意请求方式是<code>GET</code>：</p>
<pre><code>public interface GithubClient {
    @GET(&quot;/search/repositories&quot;)
    Call&lt;ResponseBody&gt; searchRepos(
            @Query(&quot;q&quot;) String keywords,
            @Query(&quot;sort&quot;) String sort,
            @Query(&quot;order&quot;) String order
    );
}
</code></pre><p>MainActivity中测试时，可以将<code>searchRepos(...)</code>方法中的第二个和第三个参数修改为<code>null</code>。</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private final static String TAG = &quot;ILearnRetrofit&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Utils.init(this);

        GithubClient client = ServiceGenerator.createService(GithubClient.class);
        Call&lt;ResponseBody&gt; call = client.searchRepos(&quot;Retrofit&quot;,&quot;updated&quot;,null);  // 搜索包含`Retrofit`关键字的仓库，按照更新时间排序，排序方式按照默认的减序
        call.enqueue(new Callback&lt;ResponseBody&gt;() {
            @Override
            public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) {
                try {
                    if (response.isSuccessful())
                        i(TAG, &quot;搜索成功：&quot; + response.body().string() );
                    else
                        i(TAG, &quot;搜索失败：&quot; + response.errorBody().string());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            @Override
            public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) {
                i(TAG, &quot;搜索失败：&quot; + t.getMessage());
            }
        });

    }
}
</code></pre><p>正常的返回数据在控制台中可以看到打印（因为logcat打印有4k长度限制,所以直接看到的json格式并不是完整的）：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-15_12_28_02_搜索仓库.png" alt=""></p>
<p>因为<code>sort</code>和<code>order</code>是可选参数，如果不填写，是有默认值可以继续正常使用的，这也就是为什么<code>q</code>参数不能传递<code>null</code>，虽然程序可以正常执行，但是API端返回数据有误，报错如下：</p>
<pre><code>搜索失败：
{
    &quot;message&quot;: &quot;Validation Failed&quot;,
    &quot;errors&quot;: [
        {
            &quot;resource&quot;: &quot;Search&quot;,
            &quot;field&quot;: &quot;q&quot;,
            &quot;code&quot;: &quot;missing&quot;
        }
    ],
    &quot;documentation_url&quot;: &quot;https://developer.github.com/v3/search&quot;
}
</code></pre><blockquote>
<p>本教程所有源码参见此网页：[留白]</p>
</blockquote>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;10-可选的查询参数&quot;&gt;&lt;a href=&quot;#10-可选的查询参数&quot; class=&quot;headerlink&quot; title=&quot;10. 可选的查询参数&quot;&gt;&lt;/a&gt;10. 可选的查询参数&lt;/h1&gt;&lt;!-- MarkdownTOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>9 第九篇 Retrofit—同一key多重value字段</title>
    <link href="http://www.orzangleli.com/2017/01/17/2017-01-17_9%20%E7%AC%AC%E4%B9%9D%E7%AF%87%20Retrofit%E2%80%94%E5%90%8C%E4%B8%80key%E5%A4%9A%E9%87%8Dvalue%E5%AD%97%E6%AE%B5/"/>
    <id>http://www.orzangleli.com/2017/01/17/2017-01-17_9 第九篇 Retrofit—同一key多重value字段/</id>
    <published>2017-01-16T16:00:00.000Z</published>
    <updated>2017-01-17T14:32:19.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-跟orzangleli一起学Retrofit2-第九篇-Retrofit—同一key多重value字段"><a href="#9-跟orzangleli一起学Retrofit2-第九篇-Retrofit—同一key多重value字段" class="headerlink" title="9. [跟orzangleli一起学Retrofit2]  第九篇 Retrofit—同一key多重value字段"></a>9. [跟orzangleli一起学Retrofit2]  第九篇 Retrofit—同一key多重value字段</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#一、-查询参数">一、 查询参数</a></li>
<li><a href="#二、-多重查询参数">二、 多重查询参数</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>本文描述如何使用Retrofit执行带有<code>同一个key对应单个value</code>的字段和<code>同一key对应多重value</code>的字段的请求。</p>
<h2 id="一、-查询参数"><a href="#一、-查询参数" class="headerlink" title="一、 查询参数"></a>一、 查询参数</h2><p>在客户端对服务器的访问中，查询参数是最常用的方法之一。现在来看一个例子，我们从<code>https://api.example.com/</code>中请求一个查询<code>id=123</code>的任务。</p>
<p><a href="https://api.example.com/tasks?id=123" target="_blank" rel="external">https://api.example.com/tasks?id=123</a>  </p>
<p>这个api是不存在，只是将URL写出来让你看看查询参数是怎么添加到URL中的。我们假设这个API是存在的，那么我们就能获取一个<code>id=123</code> 的单个任务。</p>
<p>在Retrofit中定义查询参数的方法如下:</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;Task&gt; getTask(@Query(&quot;id&quot;) long taskId);
}
</code></pre><p>上面的代码中<code>getTask(...)</code>方法需要<code>taskId</code>参数。这个参数会被Retrofit映射到<code>@Query</code>注解包围参数名上去，在本例中，这个被<code>@Query</code>包围的参数就是<code>id</code>，最终组成的url像下面这样：</p>
<pre><code>/tasks?id=&lt;taskId&gt;
</code></pre><h2 id="二、-多重查询参数"><a href="#二、-多重查询参数" class="headerlink" title="二、 多重查询参数"></a>二、 多重查询参数</h2><p>有些情况下，需要在请求中传递同一个参数名对应的多个值。就以刚刚查询任务的api为例，我们可以扩展参数得到一组不同id的任务列表。</p>
<p>我们要创建的请求url像这样：</p>
<pre><code>https://api.example.com/tasks?id=123&amp;id=124&amp;id=125  
</code></pre><p>理想的服务器返回数据应该是从url查询参数给定的<code>ids=[123, 124, 125]</code>对应的一组任务列表。具体代码如下：</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTask(@Query(&quot;id&quot;) List&lt;Long&gt; taskIds);
}
</code></pre><p>只要将方法的参数和返回值替换成List包围的就可以了。但前提是你的服务器或者API支持这种多值参数的查询，我在网上找了一些API测试发现，他们都不支持这种多值查询，会自动将查询结果变为最后一个参数的查询结果。所以，如果读者发现有可用的支持多值查询的API可以联系我，我将添加案例。</p>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;9-跟orzangleli一起学Retrofit2-第九篇-Retrofit—同一key多重value字段&quot;&gt;&lt;a href=&quot;#9-跟orzangleli一起学Retrofit2-第九篇-Retrofit—同一key多重value字段&quot; class=&quot;heade
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>8 第八篇_Retrofit 2— 用@HeaderMap实现动态请求头</title>
    <link href="http://www.orzangleli.com/2017/01/16/2017-01-16_8%20%E7%AC%AC%E5%85%AB%E7%AF%87_Retrofit%202%E2%80%94%20%E7%94%A8@HeaderMap%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4/"/>
    <id>http://www.orzangleli.com/2017/01/16/2017-01-16_8 第八篇_Retrofit 2— 用@HeaderMap实现动态请求头/</id>
    <published>2017-01-15T16:00:00.000Z</published>
    <updated>2017-01-17T14:32:19.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-Retrofit-2-—-用-HeaderMap实现动态请求头"><a href="#8-Retrofit-2-—-用-HeaderMap实现动态请求头" class="headerlink" title="8. Retrofit 2 — 用@HeaderMap实现动态请求头"></a>8. Retrofit 2 — 用@HeaderMap实现动态请求头</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#一、-动态的请求头">一、 动态的请求头</a></li>
<li><a href="#二、-展望">二、 展望</a></li>
<li><a href="#三、-在github中实战">三、 在Github中实战</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>之前，我们研究了如何用Retrofit添加请求头以及静态修改请求头。本篇文章，我们将深入研究如何给Retrofit的请求添加动态数量的请求头。</p>
<p>这是Retrofit 2.1的新特性，所以在咱们做实验之前，请确保你已经做了升级工作。</p>
<h2 id="一、-动态的请求头"><a href="#一、-动态的请求头" class="headerlink" title="一、 动态的请求头"></a>一、 动态的请求头</h2><p>我们在之前的教程中给你展示的都是静态的请求头。虽然你可以改变请求头的字段的值，但是你能动态地选择你想要发送的请求头。如果你需要在运行时决定要发送那些请求头到你的请求上的话，<code>@HeaderMap</code>是一种可行方案。</p>
<p>与<code>@Header</code>注解类似，你要在接口的一个参数上声明<code>@HeaderMap</code>。参数的类型必须得是Java Map 接口的实现：</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks(
        @HeaderMap Map&lt;String, String&gt; headers
    );
}
</code></pre><p>使用我们上面定义的这个接口很简单。你可以直接创建一个Map实例，并且把你需要的指添加进去即可。Retrofit会把<code>@HeaderMap</code>注解的Map中每一个非null元素添加到请求头中。</p>
<pre><code>TaskService taskService = ServiceGenerator.createService(TaskService.class);

Map&lt;String, String&gt; map = new HashMap&lt;&gt;();  
map.put(&quot;Page&quot;, String.valueOf(page));

if (BuildConfig.DEBUG) {  
    map.put(&quot;Accept&quot;, &quot;application/vnd.yourapi.v1.full+json&quot;);
    map.put(&quot;User-Agent&quot;, &quot;Future Studio Debug&quot;);
}
else {  
    map.put(&quot;Accept&quot;, &quot;application/json&quot;);
    map.put(&quot;Accept-Charset&quot;, &quot;utf-8&quot;);
    map.put(&quot;User-Agent&quot;, &quot;Future Studio Release&quot;);
}

Call&lt;List&lt;Task&gt;&gt; call = taskService.getTasks(map);  
// Use it like any other Retrofit call
</code></pre><h2 id="二、-展望"><a href="#二、-展望" class="headerlink" title="二、 展望"></a>二、 展望</h2><p>本文中，你已经学会了如何使用<code>@HeaderMap</code> 在运行时添加动态数量的请求头。这对之前的静态请求头功能是一个极为出色的扩展。爱死它了。</p>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
<h2 id="三、-在Github中实战"><a href="#三、-在Github中实战" class="headerlink" title="三、 在Github中实战"></a>三、 在Github中实战</h2><p>本节内容由于代码与之前变化并不大，而且我没有在Github中找到合适的API,所以暂时不提供实战代码。如果各位读者找到了，可以通知我，我将会补上实战案例。</p>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;8-Retrofit-2-—-用-HeaderMap实现动态请求头&quot;&gt;&lt;a href=&quot;#8-Retrofit-2-—-用-HeaderMap实现动态请求头&quot; class=&quot;headerlink&quot; title=&quot;8. Retrofit 2 — 用@HeaderMa
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头</title>
    <link href="http://www.orzangleli.com/2017/01/13/2017-01-13_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E4%B8%83%E7%AF%87%20Retrofit%202%E2%80%94%E2%80%94%E5%9C%A8OkHttp%20Interceptor%E4%B8%AD%E7%AE%A1%E7%90%86%E8%AF%B7%E6%B1%82%E5%A4%B4/"/>
    <id>http://www.orzangleli.com/2017/01/13/2017-01-13_[跟orzangleli一起学Retrofit2]  第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头/</id>
    <published>2017-01-13T04:30:00.000Z</published>
    <updated>2017-01-14T14:59:41.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-跟orzangleli一起学Retrofit2-第七篇-Retrofit-2——在OkHttp-Interceptor中管理请求头"><a href="#7-跟orzangleli一起学Retrofit2-第七篇-Retrofit-2——在OkHttp-Interceptor中管理请求头" class="headerlink" title="7. [跟orzangleli一起学Retrofit2]  第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头"></a>7. [跟orzangleli一起学Retrofit2]  第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头</h1><p><strong>目录</strong></p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#一、-添加请求头">一、 添加请求头</a><ul>
<li><a href="#11-如何覆盖请求头字段">1.1 如何覆盖请求头字段</a></li>
<li><a href="#12-如何不覆盖请求头字段">1.2 如何不覆盖请求头字段</a></li>
</ul>
</li>
<li><a href="#二、-小福利请带走">二、 小福利请带走</a></li>
<li><a href="#三、-在github中实战">三、 在Github中实战</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>前面的教程中你已经学了Retrofit中怎么添加请求头。本文就是专门揪出用Retrofit 2和OkHttp interceptor（拦截器） 添加请求头的细节的。<code>Interceptor拦截器</code>在静态地修改请求上，是一种非常好的的方法。什么意思，直白地说，就是拦截器可以修改请求，但是它的修改相当于是一次性的，不能动态修改。</p>
<h2 id="一、-添加请求头"><a href="#一、-添加请求头" class="headerlink" title="一、 添加请求头"></a>一、 添加请求头</h2><p>常用的添加请求头的例子就是用<code>Authorization</code>字段来认证。如果你需要在每一次请求都是用这个认证的请求头字段，你可以在<code>interceptor（拦截器）</code>中添加这些信息。这样你就不用给每个客户端的请求都添加<code>@Header</code>注解了。</p>
<p>OkHttp 的拦截器提供两种方式添加请求头中的字段及其对应的值。你可以直接覆盖已存在的字段，也可以不检查是否这个字段已经存在都直接添加。接下来，我们就来看看这两种情况。</p>
<h3 id="1-1-如何覆盖请求头字段"><a href="#1-1-如何覆盖请求头字段" class="headerlink" title="1.1 如何覆盖请求头字段"></a>1.1 如何覆盖请求头字段</h3><p>在OkHttp 拦截器的帮助下，你可以拦截HTTP的请求，对这个请求进行一些定制化处理并操作实际请求。请求的builder 对象有一个<code>.header(key, val)</code>方法，它可以把字段添加到请求中区，如果这个字段<code>key</code>已经存在，那就直接覆盖之前的值。</p>
<pre><code>OkHttpClient.Builder httpClient = new OkHttpClient.Builder();  
httpClient.addInterceptor(new Interceptor() {  
    @Override
    public Response intercept(Interceptor.Chain chain) throws IOException {
        Request original = chain.request();

        // Request customization: add request headers
        Request.Builder requestBuilder = original.newBuilder()
                .header(&quot;Authorization&quot;, &quot;auth-value&quot;); // &lt;-- this is the important line

        Request request = requestBuilder.build();
        return chain.proceed(request);
    }
});

OkHttpClient client = httpClient.build();  
</code></pre><p>Retrofit ，尤其是OkHttp允许你添加对同一个<code>key</code>字段添加多个值。<code>.header()</code>方法会替换掉所有已存在的相同<code>key</code>的字段。像上面的代码片段中，每个<code>Authorization</code>中请求字段都会被更新（如果之前已经定义多次的话），他们之前的字段的值就会变成<code>auth-value</code>。</p>
<h3 id="1-2-如何不覆盖请求头字段"><a href="#1-2-如何不覆盖请求头字段" class="headerlink" title="1.2 如何不覆盖请求头字段"></a>1.2 如何不覆盖请求头字段</h3><p>的确存在用同一个字段的key,但是value不相同的情况。比如，我们来看看这个字段<code>Cache-Control</code>,这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。Http 1.1协议规定，同一个key的多重value的字段是允许的，它们和逗号分隔的列表是一样的。</p>
<p>什么意思？</p>
<pre><code>Cache-Control: no-cache  
Cache-Control: no-store  
</code></pre><p>上面这段和下面这段作用一样：</p>
<pre><code>Cache-Control: no-cache, no-store  
</code></pre><p>使用Retrofit 2和OkHttp 的拦截器，你可以添加对同一个key添加多重value。用到的方法就是<code>.addHeader</code>。</p>
<p>下面的这个例子就是添加多个同一个key添加多重value的字段：</p>
<pre><code>OkHttpClient.Builder httpClient = new OkHttpClient.Builder();  
httpClient.addInterceptor(new Interceptor() {  
    @Override
    public Response intercept(Interceptor.Chain chain) throws IOException {
        Request original = chain.request();

        // Request customization: add request headers
        Request.Builder requestBuilder = original.newBuilder()
                    .addHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;)
                    .addHeader(&quot;Cache-Control&quot;, &quot;no-store&quot;);

        Request request = requestBuilder.build();
        return chain.proceed(request);
    }
});

OkHttpClient client = httpClient.build();  
</code></pre><h2 id="二、-小福利请带走"><a href="#二、-小福利请带走" class="headerlink" title="二、 小福利请带走"></a>二、 小福利请带走</h2><p><strong>注意</strong>这里的“见微知著”的差别：</p>
<ul>
<li><code>.header(key, val)</code>: 会覆盖之前已经存在的<code>key</code>字段的值</li>
<li><code>.addHeader(key, val)</code>: 不会覆盖，它会继续添加</li>
</ul>
<h2 id="三、-在Github中实战"><a href="#三、-在Github中实战" class="headerlink" title="三、 在Github中实战"></a>三、 在Github中实战</h2><p>本节内容由于要求能够在请求头中添加<code>同一个key添加多重value</code>的字段，但是我没有在Github中找到合适的API,如果各位读者找到了，可以通知我，我将会补上实战案例。</p>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;7-跟orzangleli一起学Retrofit2-第七篇-Retrofit-2——在OkHttp-Interceptor中管理请求头&quot;&gt;&lt;a href=&quot;#7-跟orzangleli一起学Retrofit2-第七篇-Retrofit-2——在OkHttp-Int
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第六篇 Retrofit中添加自定义请求头</title>
    <link href="http://www.orzangleli.com/2017/01/13/2017-01-13_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E5%85%AD%E7%AF%87%20Retrofit%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/"/>
    <id>http://www.orzangleli.com/2017/01/13/2017-01-13_[跟orzangleli一起学Retrofit2]  第六篇 Retrofit中添加自定义请求头/</id>
    <published>2017-01-13T04:00:00.000Z</published>
    <updated>2017-01-14T14:59:44.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-跟orzangleli一起学Retrofit2-第六篇-Retrofit中添加自定义请求头"><a href="#6-跟orzangleli一起学Retrofit2-第六篇-Retrofit中添加自定义请求头" class="headerlink" title="6. [跟orzangleli一起学Retrofit2]  第六篇 Retrofit中添加自定义请求头"></a>6. [跟orzangleli一起学Retrofit2]  第六篇 Retrofit中添加自定义请求头</h1><p><strong>目录</strong><br><!-- MarkdownTOC --></p>
<ul>
<li><a href="#一、-定义自定义请求头">一、 定义自定义请求头</a><ul>
<li><a href="#11-静态请求头">1.1 静态请求头</a></li>
<li><a href="#12-动态请求头">1.2 动态请求头</a></li>
<li><a href="#retrofit-2中覆盖已存在的请求头">Retrofit 2中覆盖已存在的请求头</a></li>
</ul>
</li>
<li><a href="#二、-在github中实战">二、 在Github中实战</a><ul>
<li><a href="#31-创建评论">3.1 创建评论</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<p>本文将为你展示如何在接口内部通过<code>@Header</code>注解添加自定义请求头，以及通过拦截请求添加自定义请求头。</p>
<h2 id="一、-定义自定义请求头"><a href="#一、-定义自定义请求头" class="headerlink" title="一、 定义自定义请求头"></a>一、 定义自定义请求头</h2><p>Retrofit提供两种方式定义HTTP请求头：静态和动态方式。静态请求头在发送不同请求时不能改变。请求头的键值对在接口方法上是固定不变的。</p>
<p>相反地，动态的请求头可以对每一个请求单独设置。</p>
<h3 id="1-1-静态请求头"><a href="#1-1-静态请求头" class="headerlink" title="1.1 静态请求头"></a>1.1 静态请求头</h3><p>添加静态请求头第一步要做的事是定义请求头，用注解的形式把请求头中的内容添加到你的API方法上。每次调用这个方法的请求都会自动的添加定义好的请求头。注解可以用键值的对构成的字符串的形式或者字符串数组的形式定义。现在来看看两个具体的请求头定义步骤：</p>
<pre><code>public interface UserService {  
    @Headers(&quot;Cache-Control: max-age=640000&quot;)
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks();
}
</code></pre><p>这个例子将键值对定义成静态请求头。当然，你也可以把很多组键值对包裹在花括号<code>{}</code>中作为请求头。就像下面这样：</p>
<pre><code>public interface UserService {  
    @Headers({
        &quot;Accept: application/vnd.yourapi.v1.full+json&quot;,
        &quot;User-Agent: Your-App-Name&quot;
    })
    @GET(&quot;/tasks/{task_id}&quot;)
    Call&lt;Task&gt; getTask(@Path(&quot;task_id&quot;) long taskId);
}
</code></pre><p>除此之外，你还可以通过Retrofit中<code>RequestInterceptor</code> 的<code>intercept</code>方法（需要自行实现<code>Interceptor</code>接口）定义静态请求头。</p>
<p>在Retrofit 2中，你需要拦截OkHttp提供的网络层请求。</p>
<pre><code>OkHttpClient.Builder httpClient = new OkHttpClient.Builder();  
httpClient.addInterceptor(new Interceptor() {  
    @Override
    public Response intercept(Interceptor.Chain chain) throws IOException {
        Request original = chain.request();

        Request request = original.newBuilder()
            .header(&quot;User-Agent&quot;, &quot;Your-App-Name&quot;)
            .header(&quot;Accept&quot;, &quot;application/vnd.yourapi.v1.full+json&quot;)
            .method(original.method(), original.body())
            .build();

        return chain.proceed(request);
    }
}

OkHttpClient client = httpClient.build();  
Retrofit retrofit = new Retrofit.Builder()  
    .baseUrl(API_BASE_URL)
    .addConverterFactory(GsonConverterFactory.create())
    .client(client)
    .build();
</code></pre><p>如你所见，上面的代码分别设置了<code>User-Agent</code>和<code>Accept</code>的内容。这些值会传递到Retrofit中所有使用这个<code>Interceptor</code> 发出的请求。</p>
<h3 id="1-2-动态请求头"><a href="#1-2-动态请求头" class="headerlink" title="1.2 动态请求头"></a>1.2 动态请求头</h3><p>想要定制化程度高点就需要使用动态请求头了。动态请求头像参数一样传递到方法中。给定的参数值将会在请求被执行钱被Retrofit映射到请求头中。看个小栗子吧：</p>
<pre><code>public interface UserService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks(@Header(&quot;Content-Range&quot;) String contentRange);
}
</code></pre><p>看到没，动态请求头中，你可以为不同的请求传递不同的参数。上面这段代码就是传递动态的<code>Content-Range</code> 到请求头中。</p>
<h3 id="Retrofit-2中覆盖已存在的请求头"><a href="#Retrofit-2中覆盖已存在的请求头" class="headerlink" title="Retrofit 2中覆盖已存在的请求头"></a>Retrofit 2中覆盖已存在的请求头</h3><p>与Retrofit v1版本不同，Retrofit 2中可以覆盖已存在的请求头字段（言下之意就是Retrofit不支持覆盖）。你可以在传递到OkHttp的client对象中的<code>Interceptor</code>的接口实现中完成对这些字段的覆盖。<code>Request.Builder</code>提供两种添加请求头的方法：</p>
<ol>
<li><code>.header(key, value)</code>： 如果请求头中已经存在这个字段的话就覆盖</li>
<li><code>.addHeader(key, value)</code>: 即使请求头中已经存在这个字段，也是照样添加，这样请求头中某个字段可能有多个值</li>
</ol>
<h2 id="二、-在Github中实战"><a href="#二、-在Github中实战" class="headerlink" title="二、 在Github中实战"></a>二、 在Github中实战</h2><p>在<a href="http://www.orzangleli.com/">5. [跟orzangleli一起学Retrofit2]  第五篇 在Retrofit的请求主体中发送对象</a>的Github实战中，我们在请求主体中发送评论，之前采用的认证方式是添加查询参数token,其实除了这种认证方式，我们还可以在请求头中添加token信息,下面我们就使用这种方法来发表评论。</p>
<h3 id="3-1-创建评论"><a href="#3-1-创建评论" class="headerlink" title="3.1 创建评论"></a>3.1 创建评论</h3><p>为了与第五篇文章的实验不冲突，我新建了一个<a href="https://gist.github.com/hust201010701/6582fb0808c585fddb5808b547bfbebf" target="_blank" rel="external">Gist片段</a>。</p>
<p>这里简单说明下，在请求中添加token的格式是：</p>
<pre><code>Authorization: token OAUTH-TOKEN
</code></pre><p>这样，我们简单修改下GithubClient接口：</p>
<pre><code>public interface GithubClient {
    @POST(&quot;/gists/{gist_id}/comments&quot;)
    Call&lt;ResponseBody&gt; commentGist(
      @Path(&quot;gist_id&quot;) String gist_id,
      @Body GistComment comment,
      @Header(&quot;Authorization&quot;) String token
    );

    class GistComment{
        String body;
        public GistComment(String body) {
            this.body = body;
        }
    }
}
</code></pre><p>然后把MainActivity.java中的Gist_id修改成<code>6582fb0808c585fddb5808b547bfbebf</code>,并且修改下<code>commentGist</code>中的参数：</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private final static String TAG = &quot;ILearnRetrofit&quot;;
    private final String Gist_id = &quot;6582fb0808c585fddb5808b547bfbebf&quot;;
    private final String Github_Token = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Utils.init(this);

        GithubClient client = ServiceGenerator.createService(GithubClient.class);
        GithubClient.GistComment comment = new GithubClient.GistComment(&quot;这是Retrofit 2在请求头中使用token认证发出来的评论，发送人是orzangleli&quot;); // 可以把我的id orzangleli 修改成你自己的
        Call&lt;ResponseBody&gt; call = client.commentGist(Gist_id, comment, &quot; token &quot;+Github_Token);
        call.enqueue(new Callback&lt;ResponseBody&gt;() {
            @Override
            public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) {
                if (response.isSuccessful())
                    i(TAG, &quot;评论成功：&quot; + response.raw());
                else
                    i(TAG, &quot;评论失败：&quot; + response.errorBody());
            }

            @Override
            public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) {
                i(TAG, &quot;评论失败：&quot; + t.getMessage());
            }
        });

    }
}
</code></pre><p>代码中的Github_Token 需要换成你自己的，可以看这篇教程<strong>[Retrofit 2 番外篇]将Github作为Retrofit的测试对象</strong>,因为它只显示一次，所以记住将这个token保存在本地，以后的教程会经常用到这个token。</p>
<p>最后，你可以到<a href="https://gist.github.com/hust201010701/6582fb0808c585fddb5808b547bfbebf" target="_blank" rel="external">https://gist.github.com/hust201010701/6582fb0808c585fddb5808b547bfbebf</a>中看看，你的评论是否正常的发出了。</p>
<p>我的已经成功了：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-13_13_56_05_请求头中token认证.png" alt=""></p>
<blockquote>
<p>本教程所有源码参见此网页：[留白]</p>
</blockquote>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;6-跟orzangleli一起学Retrofit2-第六篇-Retrofit中添加自定义请求头&quot;&gt;&lt;a href=&quot;#6-跟orzangleli一起学Retrofit2-第六篇-Retrofit中添加自定义请求头&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第五篇 在Retrofit的请求主体中发送对象</title>
    <link href="http://www.orzangleli.com/2017/01/12/2017-01-12_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E4%BA%94%E7%AF%87%20%E5%9C%A8Retrofit%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%BB%E4%BD%93%E4%B8%AD%E5%8F%91%E9%80%81%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.orzangleli.com/2017/01/12/2017-01-12_[跟orzangleli一起学Retrofit2]  第五篇 在Retrofit的请求主体中发送对象/</id>
    <published>2017-01-12T04:30:00.000Z</published>
    <updated>2017-01-14T14:59:31.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-跟orzangleli一起学Retrofit2-第五篇-在Retrofit的请求主体中发送对象"><a href="#5-跟orzangleli一起学Retrofit2-第五篇-在Retrofit的请求主体中发送对象" class="headerlink" title="5. [跟orzangleli一起学Retrofit2]  第五篇 在Retrofit的请求主体中发送对象"></a>5. [跟orzangleli一起学Retrofit2]  第五篇 在Retrofit的请求主体中发送对象</h1><p><strong>目录</strong><br><!-- MarkdownTOC --></p>
<ul>
<li><a href="#一、-在请求主体中发送对象">一、 在请求主体中发送对象</a></li>
<li><a href="#二、-举个栗子">二、 举个栗子</a></li>
<li><a href="#三、-在github中实战">三、 在Github中实战</a><ul>
<li><a href="#31-创建评论">3.1 创建评论</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<h2 id="一、-在请求主体中发送对象"><a href="#一、-在请求主体中发送对象" class="headerlink" title="一、 在请求主体中发送对象"></a>一、 在请求主体中发送对象</h2><p>Retrofit能够在请求主体中发送对象，通过使用<code>@Body</code>注解将这些对象指定为HTTP请求主体的内容。相对于之前的版本来说，Retrofit 2中 <code>@Body</code>功能并没有发生变化。</p>
<pre><code>public interface TaskService {  
    @POST(&quot;/tasks&quot;)
    Call&lt;Task&gt; createTask(@Body Task task);
}
</code></pre><p>事先定义好的<code>Retrofit</code>的转换器（如Gson）将会把传入的对象<code>task</code>映射成JSON格式，最终以请求主体的名义发送到你的服务器上。</p>
<h2 id="二、-举个栗子"><a href="#二、-举个栗子" class="headerlink" title="二、 举个栗子"></a>二、 举个栗子</h2><p>看个具体的例子吧。</p>
<pre><code>public class Task {  
    private long id;
    private String text;

    public Task(long id, String text) {
        this.id = id;
        this.text = text;
    }
}
</code></pre><p>初始化一个<code>Task</code>对象，然后对它的<code>id</code>和<code>text</code>赋值。这样，当你把这个<code>Task</code>对象传给service类的时候，对象的变量名和值会被转化为JSON格式。</p>
<pre><code>Task task = new Task(1, &quot;my task title&quot;);  
Call&lt;Task&gt; call = taskService.createTask(task);  
call.enqueue(new Callback&lt;Task&gt;() {});  
</code></pre><p>调用service中<code>createTask</code>方法，将会把<code>task</code>中的属性转化为JSON格式。<code>task</code>转化后的JSON格式内容像下面这样：</p>
<pre><code>{
    &quot;id&quot;: 1,
    &quot;text&quot;: &quot;my task title&quot;
}
</code></pre><h2 id="三、-在Github中实战"><a href="#三、-在Github中实战" class="headerlink" title="三、 在Github中实战"></a>三、 在Github中实战</h2><p>本次我们选用Github中的gist作为操作对象，关于gist是什么，可以参考<a href="http://group.jobbole.com/9655/" target="_blank" rel="external">http://group.jobbole.com/9655/</a>,Github的gist官网是<a href="https://gist.github.com/" target="_blank" rel="external">https://gist.github.com/</a>。</p>
<p>当然，gist并不是私有的，别人也是可以访问的，所以你们没有必要再自己创建一个gist片段，可以直接使用我的<a href="https://gist.github.com/hust201010701/04793d3d5b53e43d2f6a71b7c3103ea4" target="_blank" rel="external">https://gist.github.com/hust201010701/04793d3d5b53e43d2f6a71b7c3103ea4</a>。其中<code>04793d3d5b53e43d2f6a71b7c3103ea4</code>为gist的id.</p>
<p>因为本节我们我要实战的是<code>在Retrofit的请求主体中发送对象</code>，所以HTTP的请求方式很明显应该为<code>POST</code>,从Github中关于Gist的API<a href="https://developer.github.com/v3/gists/comments/" target="_blank" rel="external">https://developer.github.com/v3/gists/comments/</a>中，选取 <code>Create a comment</code> 创建一个评论作为我们的目标。</p>
<h3 id="3-1-创建评论"><a href="#3-1-创建评论" class="headerlink" title="3.1 创建评论"></a>3.1 创建评论</h3><p>API是这样： <code>POST /gists/:gist_id/comments</code><br>参数表：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>名称</strong></th>
<th style="text-align:center"><strong>类型</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">body</td>
<td style="text-align:center">string</td>
<td style="text-align:center">必需，评论内容</td>
</tr>
</tbody>
</table>
<p>这里这说明下，涉及到Github的API，所有请求的基本地址都是： <code>https://api.github.com</code>。地址中的:gist_id就是我们想要访问的gist的id，对本例就是<code>04793d3d5b53e43d2f6a71b7c3103ea4</code>。 下面我们来试试牛刀吧~</p>
<p>首先是Github请求客户端接口，<code>GistComment</code>为封装好的评论类，发出评论的方法<code>commentGist</code>使用POST方式，url中<code>{gist_id}</code>是动态的可以修改的Gist片段的id,<code>@Query(&quot;access_token&quot;)</code>则表示发表评论时所需要的token参数：</p>
<pre><code>public interface GithubClient {
    @POST(&quot;/gists/{gist_id}/comments&quot;)
    Call&lt;ResponseBody&gt; commentGist(
      @Path(&quot;gist_id&quot;) String gist_id,
      @Body GistComment comment,
      @Query(&quot;access_token&quot;) String token
    );

    class GistComment{
        String body;

        public GistComment(String body) {
            this.body = body;
        }
    }
}
</code></pre><p>在MainActivity中调用的代码如下所示：</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private final static String TAG = &quot;ILearnRetrofit&quot;;
    private final String Gist_id = &quot;04793d3d5b53e43d2f6a71b7c3103ea4&quot;;
    private final String Github_Token = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Utils.init(this);

        GithubClient client = ServiceGenerator.createService(GithubClient.class);
        GithubClient.GistComment comment = new GithubClient.GistComment(&quot;这是Retrofit 2程序发出来的，发送人是orzangleli&quot;); // 可以把我的id orzangleli 修改成你自己的
        Call&lt;ResponseBody&gt; call = client.commentGist(Gist_id, comment, Github_Token);
        call.enqueue(new Callback&lt;ResponseBody&gt;() {
            @Override
            public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) {
                if (response.isSuccessful())
                    i(TAG, &quot;评论成功：&quot; + response.raw());
                else
                    i(TAG, &quot;评论失败：&quot; + response.errorBody());
            }

            @Override
            public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) {
                i(TAG, &quot;评论失败：&quot; + t.getMessage());
            }
        });

    }
}
</code></pre><p>代码中的Github_Token 需要换成你自己的，可以看这篇教程<strong>[Retrofit 2 番外篇]将Github作为Retrofit的测试对象</strong>,因为它只显示一次，所以记住将这个token保存在本地，以后的教程会经常用到这个token。</p>
<p>最后，你可以到<a href="https://gist.github.com/hust201010701/04793d3d5b53e43d2f6a71b7c3103ea4" target="_blank" rel="external">https://gist.github.com/hust201010701/04793d3d5b53e43d2f6a71b7c3103ea4</a>中看看，你的评论是否正常的发出了。</p>
<p>我的已经成功了：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-13_13_56_05_请求主体中发送对象.png" alt=""></p>
<blockquote>
<p>本教程所有源码参见此网页：[留白]</p>
</blockquote>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;5-跟orzangleli一起学Retrofit2-第五篇-在Retrofit的请求主体中发送对象&quot;&gt;&lt;a href=&quot;#5-跟orzangleli一起学Retrofit2-第五篇-在Retrofit的请求主体中发送对象&quot; class=&quot;headerlink&quot; t
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第四篇__同步和异步请求</title>
    <link href="http://www.orzangleli.com/2017/01/12/2017-01-12_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E5%9B%9B%E7%AF%87__%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"/>
    <id>http://www.orzangleli.com/2017/01/12/2017-01-12_[跟orzangleli一起学Retrofit2]  第四篇__同步和异步请求/</id>
    <published>2017-01-12T04:00:00.000Z</published>
    <updated>2017-01-14T14:59:44.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-Retrofit-2的同步和异步请求"><a href="#4-Retrofit-2的同步和异步请求" class="headerlink" title="4. Retrofit 2的同步和异步请求"></a>4. Retrofit 2的同步和异步请求</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#同步请求">同步请求</a></li>
<li><a href="#同步请求获取数据">同步请求获取数据</a></li>
<li><a href="#异步请求">异步请求</a></li>
<li><a href="#异步请求获取数据">异步请求获取数据</a></li>
<li><a href="#获取原始http响应数据">获取原始HTTP响应数据</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>之前的文章，我们带你学习了在web服务或者API请求中Retrofit要设置的东西。本文将给你展示如何通过同步或异步的方式完成真实的请求。</p>
<p>Retrofit支持同步和异步的方式执行请求。从使用者的观点来看，这两种方式的不同之处在于：</p>
<ul>
<li>同步——使用者通过单个线程调用服务；该线程发送请求，在服务运行时阻塞，并且等待响应。</li>
<li>异步——使用者通过两个线程调用服务；一个线程发送请求，而另一个单独的线程接收响应。</li>
</ul>
<h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><p>同步请求和异步请求在Retrofit 2中，在声明客户端（Client）的时候并没有区别，这与Retrofit 1.9不同，Retrofit 1.9是通过修改返回类型和方法参数来声明同步请求。</p>
<p>下面这个例子，当执行<code>getTasks</code> 时期望获取一组Task类型的链表。</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks();
}
</code></pre><p>在Retrofit 2中，每个请求都被一个<code>Call</code>对象包裹。实际上，同步或者异步请求是用后面创建的<code>call</code>对象使用特定的方法用不同方式执行的。但是，在定义接口上，Retrofit 2的同步请求和异步请求没有区别。</p>
<p>同步请求是执行在主线程上的。这就意味着UI线程会在请求执行的时候阻塞，在此期间，用户的交互操作无法响应。</p>
<blockquote>
<p>警告： 同步请求可能会导致Android 4.0+的系统的APP 的崩溃。将会产生<code>NetworkOnMainThreadException</code>错误。</p>
</blockquote>
<p>同步方法能够直接返回数据，因为网络请求操作阻塞了所有其他的操作。<br>对于非UI线程，你需要在自己建的单独线程中执行请求。这就意味着，你可以在等待网络响应的过程中继续与APP进行交互。</p>
<h2 id="同步请求获取数据"><a href="#同步请求获取数据" class="headerlink" title="同步请求获取数据"></a>同步请求获取数据</h2><p>现在来看看同步请求的实战操作。我们就假设你已经对前面几篇文章介绍的<code>ServiceGenerator</code>很熟悉了，下面的代码片段就阐述了同步请求的做法。</p>
<pre><code>TaskService taskService = ServiceGenerator.createService(TaskService.class);  
Call&lt;List&lt;Task&gt;&gt; call = taskService.getTasks();  
List&lt;Task&gt;&gt; tasks = call.execute().body(); 
</code></pre><p>Retrofit 2中通过<code>call</code>对象调用<code>.execute()</code>方法，将在执行同步请求。可以通过在响应对象上执行<code>.body()</code>方法获取反序列化的响应内容。</p>
<h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>除了同步请求，Retrofit对异步请求的支持也属于开箱即用（直白点就是用起来很简单）。Retrofit 2在定义接口上，同步和异步是没有区别的，这一点之前说过了。</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks();
}
</code></pre><p>异步请求中Retrofit 是在单独的线程中执行和处理网络请求的。一般来说使用<code>Callback</code>类，用它来映射你定义好的返回类型。我们的例子就是返回一组<code>Task</code>类型的链表，这一点在<code>Callback</code>内部就会自动映射好的。</p>
<h2 id="异步请求获取数据"><a href="#异步请求获取数据" class="headerlink" title="异步请求获取数据"></a>异步请求获取数据</h2><p>使用异步请求，你需要实现<code>Callback</code>的两个回调方法：<code>onResponse</code>和<code>onFailure</code>。当从服务类中调用异步请求<code>getTask()</code>方法时，你需要实现一个新的<code>Callback</code>接口，并且定义你需要在请求完成时要做的处理。下面的代码片段就简要说明了一个典型的实现方法。</p>
<pre><code>TaskService taskService = ServiceGenerator.createService(TaskService.class);  
Call&lt;List&lt;Task&gt;&gt; call = taskService.getTasks();  
call.enqueue(new Callback&lt;List&lt;Task&gt;&gt;() {  
    @Override
    public void onResponse(Call&lt;List&lt;Task&gt;&gt; call, Response&lt;List&lt;Task&gt;&gt; response) {
        if (response.isSuccessful()) {
            // 执行成功
        } else {
            // 响应错误，没有权限访问？
        }
    }

    @Override
    public void onFailure(Call&lt;List&lt;Task&gt;&gt; call, Throwable t) {
        // 出错了（如网络没有连接）
        Log.d(&quot;Error&quot;, t.getMessage());
    }
}
</code></pre><h2 id="获取原始HTTP响应数据"><a href="#获取原始HTTP响应数据" class="headerlink" title="获取原始HTTP响应数据"></a>获取原始HTTP响应数据</h2><p>在Retrofit 2中，获取原始响应数据的方式可以在异步的请求中获取。异步请求的回调方法<code>onResponse()</code>中可以获取<code>Response</code>类型的原始响应对象。具体看代码：</p>
<pre><code>call.enqueue(new Callback&lt;List&lt;Task&gt;&gt;() {  
    @Override
    public void onResponse(Call&lt;List&lt;Task&gt;&gt; call, Response&lt;List&lt;Task&gt;&gt; response) {
        // 获取原始响应对象
        Response raw = response.raw();
    }

    @Override
    public void onFailure(Call&lt;List&lt;Task&gt;&gt; call, Throwable t) {}
}
</code></pre><p>Happy coding! 如果你在阅读本教程中有任何困难或者需要帮助，随时可以在微博上联系我，我的微博是<a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzangleli</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;4-Retrofit-2的同步和异步请求&quot;&gt;&lt;a href=&quot;#4-Retrofit-2的同步和异步请求&quot; class=&quot;headerlink&quot; title=&quot;4. Retrofit 2的同步和异步请求&quot;&gt;&lt;/a&gt;4. Retrofit 2的同步和异步请求&lt;/h1
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第二篇__API描述的基础知识</title>
    <link href="http://www.orzangleli.com/2017/01/11/2017-01-11_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E4%BA%8C%E7%AF%87__API%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.orzangleli.com/2017/01/11/2017-01-11_[跟orzangleli一起学Retrofit2]  第二篇__API描述的基础知识/</id>
    <published>2017-01-11T04:30:00.000Z</published>
    <updated>2017-01-14T14:59:17.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-Retrofit-2-—API描述基础知识"><a href="#2-Retrofit-2-—API描述基础知识" class="headerlink" title="2. Retrofit 2 —API描述基础知识"></a>2. Retrofit 2 —API描述基础知识</h1><p><strong>目录</strong></p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#如何描述api">如何描述API</a><ul>
<li><a href="#http-请求方式">HTTP 请求方式</a></li>
<li><a href="#http资源位置">HTTP资源位置</a></li>
<li><a href="#方法名和返回类型">方法名和返回类型</a></li>
<li><a href="#路径参数">路径参数</a></li>
<li><a href="#查询参数">查询参数</a></li>
</ul>
</li>
<li><a href="#下节预告">下节预告</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>在上一节Retrofit入门教程中，你已经完成对Github网站的第一次请求了。希望你对Retrofit更多功能的试验仍保持热情。本节教程中你将学会Retrofit中描述API的更多细节。</p>
<h2 id="如何描述API"><a href="#如何描述API" class="headerlink" title="如何描述API"></a>如何描述API</h2><p>正如你第一节学到的，我们描述Retrofit所有的请求都是通过接口完成的。在第一个案例中，我们就展示一点点的功能，如下：</p>
<pre><code>public interface GitHubClient {  
    @GET(&quot;/users/{user}/repos&quot;)
    Call&lt;List&lt;GitHubRepo&gt;&gt; reposForUser(
        @Path(&quot;user&quot;) String user
    );
}
</code></pre><p>现在我们来具体看看这些配置项：</p>
<h3 id="HTTP-请求方式"><a href="#HTTP-请求方式" class="headerlink" title="HTTP 请求方式"></a>HTTP 请求方式</h3><p>看来你已经知道，我们在java接口的方法上使用注解来描述API.首先你要定义的是HTTP请求方式，如<code>GET</code> ,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>等。Retrofit为每一种标准的请求方式提供了一个注解。你可以想下面这样简单的方式使用Retrofit注解描述HTTP请求方式：</p>
<pre><code>@GET, @POST, @PUT, @DELETE, @PATCH, @HEAD.
</code></pre><p>你必须明确的支出这个API请求使用什么方式进行请求。如果你从来没有听过HTTP请求方式，，你可以看看这个网址 <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods" target="_blank" rel="external">HTTP维基百科</a> ，要是打不开就看看国内的吧:<a href="http://www.runoob.com/http/http-methods.html" target="_blank" rel="external">http://www.runoob.com/http/http-methods.html</a>。</p>
<p><code>@GET</code>, <code>@PUT</code> 和 <code>@DELETE</code>的使用简单例子：</p>
<pre><code>public interface FutureStudioClient {  
    @GET(&quot;/user/info&quot;)
    Call&lt;UserInfo&gt; getUserInfo();

    @PUT(&quot;/user/info&quot;)
    Call&lt;UserInfo&gt; updateUserInfo(
        @Body UserInfo userInfo
    );

    @DELETE(&quot;/user&quot;)
    Call&lt;Void&gt; deleteUser();
}
</code></pre><h3 id="HTTP资源位置"><a href="#HTTP资源位置" class="headerlink" title="HTTP资源位置"></a>HTTP资源位置</h3><p>你要把API中的相对地址作为String类型的参数传递给注解，例如<code>@GET(&quot;/user/info&quot;)</code>。<br>大部分情况，你只需要传递相对地址，而不是完整的地址（如<code>http://futurestud.io/api/user/info</code>）。这样做有一个优点，Retrofit只需要请求基本地址 （<code>http://futurestud.io</code>）一次就可以。如果你改变API的基本地址，你也只需要修改一次即可。除此之外，它还让实现一些高级的功能，如动态基本地址，变得更加容易。如果你想继续学些URL处理和怎么将基本地址和相对地址连接到一起的话，欢迎阅读我们的教程  <a href="https://futurestud.io/tutorials/retrofit-2-url-handling-resolution-and-parsing" target="_blank" rel="external">URL handling, resolution and parsing</a>.</p>
<p>我们再看个简单的例子：</p>
<pre><code>public interface FutureStudioClient {  
    @GET(&quot;/user/info&quot;)
    Call&lt;UserInfo&gt; getUserInfo();

    @PUT(&quot;/user/info&quot;)
    Call&lt;UserInfo&gt; updateUserInfo(
        @Body UserInfo userInfo
    );

    @DELETE(&quot;/user&quot;)
    Call&lt;Void&gt; deleteUser();

    // example for passing a full URL
    @GET(&quot;https://futurestud.io/tutorials/rss/&quot;)
    Call&lt;FutureStudioRssFeed&gt; getRssFeed();
}
</code></pre><h3 id="方法名和返回类型"><a href="#方法名和返回类型" class="headerlink" title="方法名和返回类型"></a>方法名和返回类型</h3><p>现在你应该知道HTTP请求方式注解是干什么用的了。可是，我们还没有提及Java方法声明：<code>Call&lt;UserInfo&gt; getUserInfo();</code> . 这里面涉及三个部分：</p>
<ol>
<li>方法名</li>
<li>方法返回类型</li>
<li>方法参数</li>
</ol>
<p>先从最简单的开始：方法名。你可以随意定义方法名，Retrofit并不在意，而且它对功能也不会产生影响。不过，你还是应该取一个能够帮助其他开发者理解你这个API是干嘛的名字。</p>
<p>方法的返回类型则颇为严格。你需要定义你想要从服务器获取什么样的数据。例如，当你请求用户信息的时候，你可能会把返回类型写成<code>Call&lt;UserInfo&gt;</code>。 <code>UserInfo</code> 这个类包含一些 带有用户数据的 变量。Retrofit会自动把服务器返回数据映射到UserInfo类的对象中，不需要手动解析。如果你想要原始响应数据，你可以在返回类型中使用<code>ResponseBody</code> 替代 <code>UserInfo</code> 。如果你不关心服务器的响应，你也可以直接使用<code>Void</code>。以上所有情形，都需要包裹在Retrofit的<code>Call&lt;&gt;</code>类中。</p>
<p>最后，也是主要决定API网址末端部分，你可以传递参数到方法中。这些参数有很多种，这里我们就列出一些出来：</p>
<ul>
<li><code>@Body</code>:把java对象当做请求主体发送出去</li>
<li><code>@Url</code>：使用动态地址</li>
<li><code>@Field</code>:以form-urlencoded格式发送数据</li>
</ul>
<p>再看看使用案例：</p>
<pre><code>public interface FutureStudioClient {  
    @GET(&quot;/user/info&quot;)
    Call&lt;UserInfo&gt; getUserInfo();

    @PUT(&quot;/user/info&quot;)
    Call&lt;Void&gt; updateUserInfo(
        @Body UserInfo userInfo
    );

    @GET
    Call&lt;ResponseBody&gt; getUserProfilePhoto(
        @Url String profilePhotoUrl
    );
}
</code></pre><p>因为路径和查询参数很普遍，所以我们会在接下来的两段中讲述它们。</p>
<h3 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h3><p>REST APIs 是建议在动态URL的基础上的（关于REST可进入<a href="http://kb.cnblogs.com/page/132129/" target="_blank" rel="external">http://kb.cnblogs.com/page/132129/</a>了解）。你可以通过替换部分URL地址访问资源，如，想要获得hust201010701的CouponView仓库的所有贡献者，可以访问<a href="https://api.github.com/repos/hust201010701/CouponView/contributors" target="_blank" rel="external">https://api.github.com/repos/hust201010701/CouponView/contributors</a>,其中<code>hust201010701/CouponView</code>就是明确你要访问谁的哪个仓库。Retrofit提供了一种简单的方式替换这些路径参数。你应该在入门指南的教程中看到过了吧。</p>
<pre><code>public interface GitHubClient {  
    @GET(&quot;/users/{user}/repos&quot;)
    Call&lt;List&lt;GitHubRepo&gt;&gt; reposForUser(
        @Path(&quot;user&quot;) String user
    );
}
</code></pre><p>这里<code>{user}</code>告诉Retrofit，这个值是动态的，当请求发出时会被设置进去。如果你要把一个路径参数放到URL中，你需要给方法的参数添加<code>@Path()</code>标记，<code>@Path</code>标记的值就会替换掉URL的占位符（本例中就是@Path(“user”)）。如果有必要，你可以使用多个占位符。只需要保证你匹配参数的总量。你还可以使用[optional path parameters]（<a href="https://futurestud.io/tutorials/retrofit-optional-path-parameters）。" target="_blank" rel="external">https://futurestud.io/tutorials/retrofit-optional-path-parameters）。</a></p>
<h3 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h3><p>动态URL另一大类就是查询参数。如果你之前使用过过滤器，你应该看过这个网站：<code>https://www.baidu.com/s?wd=123</code> . <code>?wd=123</code>就是一个查询参数，它表明你要搜索的内容,又例如<code>https://futurestud.io/tutorials?filter=video</code>中的<code>?filter=video</code>描述了请求的资源。。和路径参数不同，你不要把它们添加到注解的URL中。你可以很简单的使用<code>@Qurey</code>来添加一个方法的参数和名字。Retrofit会自动把它加到请求中去。如果你传递了<code>null</code>作为查询参数，Retrofit就会忽略这个参数。你可以添加 <a href="https://futurestud.io/tutorials/retrofit-2-add-multiple-query-parameter-with-querymap" target="_blank" rel="external">multiple query parameters</a>。</p>
<pre><code>public interface FutureStudioClient {  
    @GET(&quot;/tutorials&quot;)
    Call&lt;List&lt;Tutorial&gt;&gt; getTutorials(
        @Query(&quot;page&quot;) Integer page
    );

    @GET(&quot;/tutorials&quot;)
    Call&lt;List&lt;Tutorial&gt;&gt; getTutorials(
            @Query(&quot;page&quot;) Integer page,
            @Query(&quot;order&quot;) String order,
            @Query(&quot;author&quot;) String author,
            @Query(&quot;published_at&quot;) Date date
    );
}   
</code></pre><p>上面这个例子，使用第二个方法，后面三个参数的值都传递<code>null</code>，这样，你就可以移除第一个<code>getTutorials()</code>方法了。</p>
<h2 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h2><p>这只是一个描述API末端的介绍而已。目前你应该学会了怎么添加新的请求地址到你的接口上去了吧。你可以调整资源的位置，HTTP请求方式，返回类型，路径参数和查询参数。</p>
<p>Retrofit提供了很多选项去进一步修改请求。例如，我们还没有说到的headers(请求头)。接下来还有很多需要学，所以继续学习教程吧！</p>
<p>欢迎大家关注我的<a href="https://github.com/hust201010701" target="_blank" rel="external">Github</a> 和微博 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzangleli</a> 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2-Retrofit-2-—API描述基础知识&quot;&gt;&lt;a href=&quot;#2-Retrofit-2-—API描述基础知识&quot; class=&quot;headerlink&quot; title=&quot;2. Retrofit 2 —API描述基础知识&quot;&gt;&lt;/a&gt;2. Retrofit 2 —A
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第一篇_Retrofit入门指南及创建一个Android客户端</title>
    <link href="http://www.orzangleli.com/2017/01/11/2017-01-11_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E4%B8%80%E7%AF%87_Retrofit%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E5%8F%8A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAAndroid%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>http://www.orzangleli.com/2017/01/11/2017-01-11_[跟orzangleli一起学Retrofit2]  第一篇_Retrofit入门指南及创建一个Android客户端/</id>
    <published>2017-01-11T04:00:00.000Z</published>
    <updated>2017-01-14T14:59:44.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-跟orzangleli一起学Retrofit2-第一篇-Retrofit入门指南及创建一个Android客户端"><a href="#1-跟orzangleli一起学Retrofit2-第一篇-Retrofit入门指南及创建一个Android客户端" class="headerlink" title="1. [跟orzangleli一起学Retrofit2]  第一篇  Retrofit入门指南及创建一个Android客户端"></a>1. [跟orzangleli一起学Retrofit2]  第一篇  Retrofit入门指南及创建一个Android客户端</h1><blockquote>
<p>本系列文章是作者orzangleli基于<a href="https://futurestud.io/tutorials/retrofit-getting-started-and-android-client" target="_blank" rel="external">FutureStudio</a>中的教程经过亲自试验和修改，删除文章中关于1.9版本Retrofit的介绍，让初学者更加方便和清晰地学习Retrofit2.0，并对原文章中部分代码及API作了修改和补充，以达到正常试验效果。<br>本系列文章所有权归orzangleli.com所有，任何人有权转载，但需要标明出处。</p>
</blockquote>
<p>本文是Retrofit教程系列的第一篇。本系列通过使用一些案例深入了解Retrofit，并从功能和可扩展性的方面来测试Retrofit.</p>
<h2 id="跟orzangleli一起学Retrofit2-系列总览"><a href="#跟orzangleli一起学Retrofit2-系列总览" class="headerlink" title="[跟orzangleli一起学Retrofit2]系列总览"></a>[跟orzangleli一起学Retrofit2]系列总览</h2><ol>
<li>将Github作为Retrofit的测试对象</li>
<li>入门指南及创建一个Android客户端</li>
<li>API 基础</li>
<li>创建一个持久化的Android客户端</li>
<li>同步和异步请求</li>
<li>在Request Body中发送对象</li>
<li>添加自定义请求头</li>
<li>Retrofit 2——在OkHttp Interceptor中管理请求头</li>
</ol>
<p>本篇文章我们将一起学习Retrofit的基础知识，以及对API或者HTTP请求创建一个Android 客户端。</p>
<p>但是，这篇文章并没有涉及很多入门信息和也没有解释Retrofit究竟是什么。对于这些内容，请访问<a href="http://square.github.io/retrofit/" target="_blank" rel="external">projects homepage</a></p>
<h2 id="Retrofit是什么"><a href="#Retrofit是什么" class="headerlink" title="Retrofit是什么"></a>Retrofit是什么</h2><p>Retrofit官方主页这样描述它：</p>
<blockquote>
<p>A type-safe REST client for Android and Java.(Android和Java的类型安全的REST客户端)</p>
</blockquote>
<p>本系列中你将学会使用注解描述HTTP请求，URL参数的替换和查询参数。另外，Retrofit还提供对multipart请求主体和文件的上传功能。</p>
<h2 id="如何申明（API）请求"><a href="#如何申明（API）请求" class="headerlink" title="如何申明（API）请求"></a>如何申明（API）请求</h2><p>请访问阅读<a href="http://square.github.io/retrofit/#api-declaration" target="_blank" rel="external">Retrofit homepage</a>中API申明部分，好好理解如何构造请求。你将会找到所有重要的信息，而且他们都有着很详细的代码描述。</p>
<h2 id="Android项目的准备工作"><a href="#Android项目的准备工作" class="headerlink" title="Android项目的准备工作"></a>Android项目的准备工作</h2><p>现在我们言归正传，如果你已经创建了你的Android项目，直接从下一段开始吧。如果没有，请先在你最新最喜欢的IDE中创建一个项目。我们喜欢使用Gradle作为构建系统，但是你也可以使用Maven.</p>
<h3 id="申明依赖项：Gradle或者Maven"><a href="#申明依赖项：Gradle或者Maven" class="headerlink" title="申明依赖项：Gradle或者Maven"></a>申明依赖项：Gradle或者Maven</h3><p>现在我们把Retrofit添加到你项目的依赖项中。选择你使用的构建系统，在pom.xml或build.gradle中定义Retrofit及其依赖项。当运行命令构建你的代码时，构建系统则会为你的项目自动下载Retrofit库。我们建议将OkHttp配合Retrofit使用，OkHttp还对Okio有依赖性，所以Okio也需要声明依赖性。</p>
<h4 id="Retrofit-1-9"><a href="#Retrofit-1-9" class="headerlink" title="Retrofit 1.9"></a><strong>Retrofit 1.9</strong></h4><p>本系列译文仅讲述Retrofit2.0,若需要了解之前的版本，请查看<a href="https://futurestud.io/tutorials/retrofit-getting-started-and-android-client" target="_blank" rel="external">英文原版</a>文章。</p>
<h4 id="Retrofit-2"><a href="#Retrofit-2" class="headerlink" title="Retrofit 2"></a><strong>Retrofit 2</strong></h4><p><strong>pom.xml</strong></p>
<pre><code>&lt;dependency&gt;  
    &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt;
    &lt;artifactId&gt;retrofit&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;  
&lt;dependency&gt;  
    &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt;
    &lt;artifactId&gt;converter-gson&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p><strong>build.gradle</strong></p>
<pre><code>dependencies {  
    // Retrofit &amp; OkHttp
    compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos;
    compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos;
}
</code></pre><p>Retrofit 2默认使用OkHttp作为网络层，而且OkHttp也内置到Retrofit2中了，所以你是用OkHttp时不需要在项目中再次声明依赖项了，除非你对OkHttp的版本有特殊要求。（译者注：Retrofit，OkHttp,Okio都是Square公司出品的）</p>
<p>现在，你的项目已经准备好整合Retrofit了，我们一起来创建一个持久的Android API/HTTP 客户端吧~</p>
<h2 id="持久的Android-客户端"><a href="#持久的Android-客户端" class="headerlink" title="持久的Android 客户端"></a>持久的Android 客户端</h2><p>在对已经存在的Retrofit客户端的研究中，发现了<a href="https://github.com/bkiers/retrofit-oauth/tree/master/src/main/java/nl/bigo/retrofitoauth" target="_blank" rel="external">example repository of Bart Kiers</a>.实际上，这是个使用Retrofit进行OAuth认证的案例。但是，它提供一个可持久化Android客户端的所有必需的基本知识。这就是为什么我们以后会把它作为坚实基础，并且在以后需要使用认证的文章中拿它来扩展。</p>
<p>下面的类定义了我们的android 客户端的基本信息：<strong>ServiceGenerator</strong></p>
<h3 id="ServiceGenerator"><a href="#ServiceGenerator" class="headerlink" title="ServiceGenerator"></a>ServiceGenerator</h3><p><strong>ServiceGenerator</strong>就是我们的API/HTTP客户端的核心，目前来说，它只是定义了一个为给定类和接口创建REST适配器的方法。代码如下：</p>
<pre><code>public class ServiceGenerator {

    public static final String API_BASE_URL = &quot;http://your.api-base.url&quot;;

    private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder();

    private static Retrofit.Builder builder =
            new Retrofit.Builder()
                    .baseUrl(API_BASE_URL)
                    .addConverterFactory(GsonConverterFactory.create());

    public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass) {
        Retrofit retrofit = builder.client(httpClient.build()).build();
        return retrofit.create(serviceClass);
    }
}
</code></pre><p>这个 <code>ServiceGenerator</code> 类使用Retrofit的<code>RestAdapter</code>来创建一个新的带有基本API地址（base URL）的REST客户端.例如，Github的API基本地址是：<code>https://api.github.com/</code>。<code>serviceClass</code>指的是对API请求有注解的类或者接口。以下部分展示Retrofit的具体使用以及如何定义一个典型的客户端。</p>
<h2 id="JSON-映射"><a href="#JSON-映射" class="headerlink" title="JSON 映射"></a>JSON 映射</h2><p>Retrofit 1.9 默认使用的是Google的Gson库。你所需要做的事就是定义你的响应对象的类，响应数据会自动被映射的。</p>
<p>使用Retrofit2时，你需要明确地为Retrofit指定一个解析器。例如前面，我们已经添加了下面这行代码到<code>build.gradle</code>文件，导入Gson 解析器到Retrofit2中。</p>
<pre><code>compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos;  
</code></pre><p>现在你需要添加你的解析器到Retrofit对象中。在Retrofit的builder中调用<code>.addConverterFactory(GsonConverterFactory.create())</code>整合Gson作为默认Json解析器。</p>
<h2 id="使用Retrofit"><a href="#使用Retrofit" class="headerlink" title="使用Retrofit"></a>使用Retrofit</h2><p>好，我们器来看一个例子，定义一个REST客户端，从Github上请求数据。首先，我们得创建一个接口，定义一些需要的方法。</p>
<h3 id="Github客户端"><a href="#Github客户端" class="headerlink" title="Github客户端"></a>Github客户端</h3><p>下面的代码定义了<code>GithubClient</code>接口，里面有一个方法请求获取某一个repository（仓库）的所有contributors（贡献者）。它还举例说明了Retrofit的参数替换功能的使用，当请求方法<code>contributors</code>时，会把GET注解参数中{owner} 和 {repo} 替换成给定的变量。</p>
<pre><code>public interface GitHubClient {  
    @GET(&quot;/repos/{owner}/{repo}/contributors&quot;)
    Call&lt;List&lt;Contributor&gt;&gt; contributors(
        @Path(&quot;owner&quot;) String owner,
        @Path(&quot;repo&quot;) String repo
    );
}
</code></pre><p>这里有一个<code>Contributor</code>类，这个类包含一些需要的，对应响应数据中的属性。</p>
<pre><code>static class Contributor {  
    String login;
    int contributions;
}
</code></pre><p>完整代码如下：</p>
<pre><code>public interface GitHubClient {  
    @GET(&quot;/repos/{owner}/{repo}/contributors&quot;)
    Call&lt;List&lt;Contributor&gt;&gt; contributors(
        @Path(&quot;owner&quot;) String owner,
        @Path(&quot;repo&quot;) String repo
    );
    static class Contributor {  
        String login;
        int contributions;
    }
}
</code></pre><p>关于前面提到的JSON映射：<code>GitHubClient</code>中定义了一个叫<code>contributors</code>的方法，返回值类型是<code>Call&lt;List&lt;Contributor&gt;&gt;</code>。Retrofit确保服务响应映射正确。</p>
<p><strong>译者注：</strong><code>Contributor</code>中定义的字段并不能随意命名，需要根据服务器返回的json格式的数据做出对应的调整。因为基本地址是：<a href="https://api.github.com/" target="_blank" rel="external">https://api.github.com/</a>，我们手动补全获取所有贡献者的API地址，以我的<a href="https://github.com/hust201010701/CouponView/" target="_blank" rel="external">CouponView</a>为例，完整的请求地址是 <a href="https://api.github.com/repos/hust201010701/CouponView/contributors" target="_blank" rel="external">https://api.github.com/repos/hust201010701/CouponView/contributors</a>.我们通过观察返回数据（如下图所示），选取其中的login和contributions作为我们想提取的数据，当然你可以自己再添加其他的关键字。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-11_22_00_28_github_contributors.png" alt=""></p>
<h2 id="API请求案例"><a href="#API请求案例" class="headerlink" title="API请求案例"></a>API请求案例</h2><p>下面这一段举例说明了使用<code>ServiceGenerator</code>初始化你的客户端，具体指的就是Github客户端，用创建的这个客户端获取仓库的贡献者。这个片段修改自<a href="https://github.com/square/retrofit/tree/master/samples/src/main/java/com/example/retrofit" target="_blank" rel="external">Retrofit github-client example</a>。</p>
<p>你需要手动在<code>ServiceGenerator</code>中定义基本地址为<code>https://api.github.com/</code>，你还可以在<code>ServiceGenerator</code>中再创建一个包含两个参数的<code>createService()</code>，这两个参数分别是客户端类和基本地址。</p>
<p>首先你需要在AndroidManifest.xml中声明权限（有些权限是以后会用到的）：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;
&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;&gt;&lt;/uses-permission&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;
</code></pre><p>如果你是android 6.0以上系统，还需要在java代码中申请权限，相关代码请自行搜索：<code>Android6.0 申请读写权限</code></p>
<p>在MainActivity中增加以下代码：</p>
<pre><code>new Thread(new Runnable(){
            @Override
            public void run() {

                GithubClient client = ServiceGenerator.createService(GithubClient.class);
                Call&lt;List&lt;GithubClient.Contributor&gt;&gt; call= client.contributors(&quot;square&quot;,&quot;retrofit&quot;);

                contributors = new ArrayList&lt;GithubClient.Contributor&gt;();

                try {
                    contributors = call.execute().body();
                } catch (IOException e) {
                    e.printStackTrace();
                }

                for(GithubClient.Contributor contributor : contributors)
                {
                    i(contributor.login+&quot;(&quot;+contributor.contributions+&quot;)&quot;);
                }

            }
        }).start();
</code></pre><h2 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h2><p>下一篇文章我们将学习如何使用Retrofit实现基本的认证。我们将给出程序案例，实现带有用户名、邮箱、密码等的web服务或API的认证。进一步地，后面的文章会介绍带token的API认证（包括OAuth）。</p>
<p>希望你能喜欢这个系列的文章。</p>
<p>本文是由orzangleli翻译，原文地址：<a href="https://futurestud.io/tutorials/retrofit-getting-started-and-android-client" target="_blank" rel="external">Getting Started and Creating an Android Client</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-跟orzangleli一起学Retrofit2-第一篇-Retrofit入门指南及创建一个Android客户端&quot;&gt;&lt;a href=&quot;#1-跟orzangleli一起学Retrofit2-第一篇-Retrofit入门指南及创建一个Android客户端&quot; clas
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第零篇_将Github作为Retrofit的测试对象</title>
    <link href="http://www.orzangleli.com/2017/01/10/2017-01-10_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E9%9B%B6%E7%AF%87_%E5%B0%86Github%E4%BD%9C%E4%B8%BARetrofit%E7%9A%84%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.orzangleli.com/2017/01/10/2017-01-10_[跟orzangleli一起学Retrofit2]  第零篇_将Github作为Retrofit的测试对象/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2017-01-14T14:56:59.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Retrofit-2-番外篇-将Github作为Retrofit的测试对象"><a href="#Retrofit-2-番外篇-将Github作为Retrofit的测试对象" class="headerlink" title="[Retrofit 2 番外篇]将Github作为Retrofit的测试对象"></a>[Retrofit 2 番外篇]将Github作为Retrofit的测试对象</h1><p><strong>目录</strong><br><!-- MarkdownTOC --></p>
<ul>
<li><a href="#一、-申请认证token">一、 申请认证token</a></li>
<li><a href="#二、-准备原始数据">二、 准备原始数据</a><ul>
<li><a href="#21-创建你的第一个仓库">2.1 创建你的第一个仓库</a></li>
<li><a href="#22-关注一些人">2.2 关注一些人</a></li>
<li><a href="#23-创建issues">2.3 创建Issues</a></li>
<li><a href="#24-star-自己的仓库">2.4 Star 自己的仓库</a></li>
</ul>
</li>
<li><a href="#三、-github-api大全">三、 Github API大全</a></li>
<li><a href="#四、-善后工作">四、 善后工作</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>本文将阐述，将Github作为Retrofit 2学习时的测试对象要做的准备工作。因为在<strong>[跟orzangleli一起学Retrofit2]</strong>这个教程中，译者将全部使用Github中的API进行测试实验。</p>
<h2 id="一、-申请认证token"><a href="#一、-申请认证token" class="headerlink" title="一、 申请认证token"></a>一、 申请认证token</h2><p>因为Github中的部分API是需要认证的，Github中认证有多种方式，但是token认证较为方便，所以选择token认证。我们到<a href="https://github.com/settings/tokens" target="_blank" rel="external">这个网页</a>获取token,我建议你新建一个全新的token,命名为RetrofitTest,然后勾上所有的权限，最后点击生成,然后你可以看到一串字符串，这个字符串就是token,将它保存在一个你可以随时找到的位置，<strong>因为这个token只会显示一次，以后在找就找不到了。</strong></p>
<h2 id="二、-准备原始数据"><a href="#二、-准备原始数据" class="headerlink" title="二、 准备原始数据"></a>二、 准备原始数据</h2><h3 id="2-1-创建你的第一个仓库"><a href="#2-1-创建你的第一个仓库" class="headerlink" title="2.1 创建你的第一个仓库"></a>2.1 创建你的第一个仓库</h3><p>如果你之前创建过仓库可以不用再看这一段。</p>
<p>如图所示，新建一个仓库，命名为RetrofitTest。<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-13_10_59_43_创建仓库.png" alt=""></p>
<h3 id="2-2-关注一些人"><a href="#2-2-关注一些人" class="headerlink" title="2.2 关注一些人"></a>2.2 关注一些人</h3><p>因为后面的教程中，会有关于Following API的测试，我们建议你关注一些人。当然我希望你能够关注我的Github:<a href="https://github.com/hust201010701" target="_blank" rel="external">@hust201010701</a>,这里我还推荐一些大牛的Github:</p>
<ul>
<li><a href="https://github.com/hust201010701" target="_blank" rel="external">@hust201010701</a> : 本教程译者（非大牛，正在朝大牛方向努力）</li>
<li><a href="https://github.com/JakeWharton" target="_blank" rel="external">JakeWharton</a>: Square Inc.的大牛</li>
<li><a href="https://github.com/hongyangAndroid" target="_blank" rel="external">hongyangAndroid</a>: 鸿洋</li>
<li><a href="https://github.com/kymjs" target="_blank" rel="external">kymjs</a>: 张涛-开源实验室</li>
</ul>
<h3 id="2-3-创建Issues"><a href="#2-3-创建Issues" class="headerlink" title="2.3 创建Issues"></a>2.3 创建Issues</h3><p>找到自己刚刚创建的RetrofitTest仓库，然后如图所示，创建一个Issue,Issue的标题可以和图中一样，方便标识，Issue的内容可以自由发挥，随意填写。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-13_11_24_03_创建Issue.png" alt=""></p>
<h3 id="2-4-Star-自己的仓库"><a href="#2-4-Star-自己的仓库" class="headerlink" title="2.4 Star 自己的仓库"></a>2.4 Star 自己的仓库</h3><p>在进入RetrofitTest仓库详情页时，右上方的Star按钮，可以自己点一下，这样就相当于自己粉了自己的项目。这样我们以后通过API获取关注者时就不会返回空数据了。</p>
<h2 id="三、-Github-API大全"><a href="#三、-Github-API大全" class="headerlink" title="三、 Github API大全"></a>三、 Github API大全</h2><p>Github的所有API可以从<a href="https://api.github.com/" target="_blank" rel="external">https://api.github.com/</a>获取到。</p>
<p>另外，<a href="https://developer.github.com/v3/" target="_blank" rel="external">Github开发者页</a>也对Github的API有详细的描述，有兴趣的可以自己深入研究。</p>
<h2 id="四、-善后工作"><a href="#四、-善后工作" class="headerlink" title="四、 善后工作"></a>四、 善后工作</h2><p>本教程如果学习完了，你又不想让Github中的仓库有任何风险，你可以自行进入<a href="https://github.com/settings/tokens" target="_blank" rel="external">https://github.com/settings/tokens</a>删除之前创建的RetrofitTest token。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Retrofit-2-番外篇-将Github作为Retrofit的测试对象&quot;&gt;&lt;a href=&quot;#Retrofit-2-番外篇-将Github作为Retrofit的测试对象&quot; class=&quot;headerlink&quot; title=&quot;[Retrofit 2 番外篇]将G
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Python节日倒计时软件</title>
    <link href="http://www.orzangleli.com/2017/01/07/2017-01-07_Python%E8%8A%82%E6%97%A5%E5%80%92%E8%AE%A1%E6%97%B6%E8%BD%AF%E4%BB%B6/"/>
    <id>http://www.orzangleli.com/2017/01/07/2017-01-07_Python节日倒计时软件/</id>
    <published>2017-01-06T16:00:00.000Z</published>
    <updated>2017-01-10T14:12:03.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-节日倒计时软件制作"><a href="#Python-节日倒计时软件制作" class="headerlink" title="Python 节日倒计时软件制作"></a>Python 节日倒计时软件制作</h1><h2 id="一-项目描述"><a href="#一-项目描述" class="headerlink" title="一. 项目描述"></a>一. 项目描述</h2><p>本次项目以Python3 作为编程语言，制作一款能够倒计时节日的图形化软件。</p>
<h3 id="1-1-项目动机"><a href="#1-1-项目动机" class="headerlink" title="1.1 项目动机"></a>1.1 项目动机</h3><p>本次项目的开发动机是：</p>
<blockquote>
<p>我想做一个类似于微博上 <a href="http://weibo.com/p/1005052493180882/home?profile_ftype=1&amp;is_all=1#_0" target="_blank" rel="external">@古城钟楼</a> 的报时程序，只是我报的时间是节日的倒计时，还想加上 “历史上的今天” 的功能。我关注的一个博主 <a href="http://weibo.com/xinlangwx?refer_flag=1001030101_" target="_blank" rel="external">@新浪无锡</a> 这位小编也会做一个倒计时的话题的微博，我问他是怎么做的，他跟我说他是数出来的，然后我就想帮帮他并且自己也练习练习，于是就想着开发一款这样的软件。<br>同时，也欢迎大家关注我的微博 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzangleli</a></p>
</blockquote>
<h3 id="1-2-知识点"><a href="#1-2-知识点" class="headerlink" title="1.2 知识点"></a>1.2 知识点</h3><ol>
<li>PyQt5库</li>
<li>requests库</li>
<li>datetime库</li>
<li>BeautifulSoup库</li>
</ol>
<h3 id="1-3-效果截图"><a href="#1-3-效果截图" class="headerlink" title="1.3 效果截图"></a>1.3 效果截图</h3><p>默认选中最近一个月的所有传统节日和24节气。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-07_17_26_01_daojishi.png" alt=""></p>
<h2 id="二、附加依赖安装"><a href="#二、附加依赖安装" class="headerlink" title="二、附加依赖安装"></a>二、附加依赖安装</h2><h3 id="2-1-PyQt安装"><a href="#2-1-PyQt安装" class="headerlink" title="2.1 PyQt安装"></a>2.1 PyQt安装</h3><p>Qt 是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱。也可用于开发非GUI程序，比如控制台工具和服务器。</p>
<p>参考：<a href="https://zh.wikipedia.org/wiki/Qt" target="_blank" rel="external">wiki–Qt</a></p>
<h4 id="2-1-1-Windows平台"><a href="#2-1-1-Windows平台" class="headerlink" title="2.1.1 Windows平台"></a>2.1.1 Windows平台</h4><p>首先下载PyQt5,注意不要下载最新版v5.7.1，最新版目前只有源码，没有可执行(exe)安装包，推荐安装和我相同的版本。进入<a href="https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/" target="_blank" rel="external">https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/</a> 下载 PyQt GPL v5.4.1 for Pythonv3.4(x64) 。注意到底是下载x86还是x64请根据自己系统的位数决定，这里需要注意的是：<strong>Python版本的位数需要跟系统保持一致，也就是如果你是64位系统，请一定要安装64位的Python</strong></p>
<p>关于Python版本：</p>
<p>我之前使用的是Python3.5，然后知道引用pyqt库时会一直出错，最后发现Python3.5和PyQt5好像是不兼容的，因为从上面的链接<a href="https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/" target="_blank" rel="external">https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/</a>，打开网址就可以看到，人家只适配了Python 3.4版本的，所以乖乖的降级使用吧~</p>
<h4 id="2-1-2-Linux平台"><a href="#2-1-2-Linux平台" class="headerlink" title="2.1.2 Linux平台"></a>2.1.2 Linux平台</h4><p>如果 Linux 中默认的 python 3 为 3.5 版本，可以通过以下指令切换到 3.4 。</p>
<pre><code>$ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.4 70 --slave /usr/bin/python3m python3m /usr/bin/python3.4m
</code></pre><p>安装 PyQt5 。</p>
<pre><code>$ sudo apt-get install python3-pyqt5
</code></pre><p>安装完成之后，立马进入 Python 命令行交互界面测试是否正确安装。</p>
<pre><code>&gt;&gt;&gt; import PyQt5
</code></pre><p>如果执行以上的命令没有任何提示，说明成功安装。</p>
<h3 id="2-2-requests库安装"><a href="#2-2-requests库安装" class="headerlink" title="2.2 requests库安装"></a>2.2 requests库安装</h3><p>在cmd命令行中输入 <code>pip install requests</code></p>
<h3 id="2-3-datetime库"><a href="#2-3-datetime库" class="headerlink" title="2.3 datetime库"></a>2.3 datetime库</h3><p>datetime库不用安装，是Python自带的</p>
<h3 id="2-4-BeautifulSoup库"><a href="#2-4-BeautifulSoup库" class="headerlink" title="2.4 BeautifulSoup库"></a>2.4 BeautifulSoup库</h3><pre><code>pip install bs4
</code></pre><h2 id="三、编程实现"><a href="#三、编程实现" class="headerlink" title="三、编程实现"></a>三、编程实现</h2><h3 id="3-1-datetime使用"><a href="#3-1-datetime使用" class="headerlink" title="3.1 datetime使用"></a>3.1 datetime使用</h3><p>因为要计算倒计时，所以需要知道今天的日期，而且要计算两个日期之前有多少天。</p>
<p><strong>获取当前时间</strong></p>
<pre><code>from datetime import date
now = date.today()
print(now.strftime(&quot;%Y-%m-%d&quot;))
</code></pre><p><strong>获取日期差</strong></p>
<pre><code>from datetime import date
now = date.today()
chunjie = date(2017,1,28)  #春节的日期
chazhi = chunjie - now     #相差时间
print(chazhi.days)         #只需要知道相差时间的天数
</code></pre><p>现在只要的datetime的这两个用法就够了，其他的如果有兴趣可以去 <a href="http://www.wklken.me/posts/2015/03/03/python-base-datetime.html#1-datetime" target="_blank" rel="external">这里</a> 查看。</p>
<h3 id="3-2-requests库"><a href="#3-2-requests库" class="headerlink" title="3.2 requests库"></a>3.2 requests库</h3><p>因为我们要计算节日倒计时必须要知道今年哪些天是节日，而且节日数目比较多，程序员总不能一个个地手动添加到程序中吧，所以我们选择一个可以看到全年节日的网站<a href="http://tools.2345.com/jieri.htm" target="_blank" rel="external">http://tools.2345.com/jieri.htm</a> ，别看2345流氓软件一大堆，2345实用查询还是有点用的。</p>
<p>首先准备一个节日的Entity 类</p>
<pre><code>from datetime import date


class DayEntity(object):
    def __init__(self,dateStr,festival,type):
        self.dateStr = &quot;2017/&quot;+dateStr
        self.year = int(self.dateStr.split(&quot;/&quot;)[0])
        self.month = int(self.dateStr.split(&quot;/&quot;)[1])
        self.day = int(self.dateStr.split(&quot;/&quot;)[2])
        self.festival = festival
        self.type = type

    def getDate(self):
        d = date(self.year,self.month,self.day)
        return d

    def getDateString(self):
        return str(self.year)+&quot;年&quot;+str(self.month)+&quot;月&quot;+str(self.day)+&quot;日&quot;

    def getFestival(self):
        return self.festival

    def getType(self):
        return self.type
</code></pre><p>添加所有的节日，包括最后添加高考和考研日期</p>
<pre><code>result = requests.get(&quot;http://tools.2345.com/jieri.htm&quot;)
html_data = result.content.decode(&quot;gb2312&quot;)
soup = BeautifulSoup(html_data,&quot;html5lib&quot;)
year = soup.find(&quot;div&quot;,class_ = &quot;jieri&quot;)
clearfix = year.find_all(&quot;dl&quot;,class_=&quot;clearfix&quot;)
allFestival = list()

for month in clearfix:
    days = month.find(&quot;dd&quot;).find(&quot;ul&quot;).find_all(&quot;li&quot;)
    for day in days:
        a_tag = day.find(&quot;a&quot;)
        type = &quot;中国传统节日&quot;
        if &quot;cRed&quot; in str(a_tag[&quot;class&quot;]):
            type = &quot;中国传统节日&quot;
        elif &quot;cGreen&quot; in str(a_tag[&quot;class&quot;]):
            type = &quot;公众 / 国际节日&quot;
        elif &quot;cBlue&quot; in str(a_tag[&quot;class&quot;]):
            type = &quot;24节气&quot;
        else:
            type = &quot;中国传统节日&quot;
        dayEntity = DayEntity(day.text.split(&quot;[&quot;)[1][:-1],day.text.split(&quot;[&quot;)[0],type)
        allFestival.append(dayEntity)

allFestival.append(DayEntity(&quot;6/7&quot;,&quot;2017高考&quot;,&quot;中国传统节日&quot;))
allFestival.append(DayEntity(&quot;12/24&quot;, &quot;2017考研&quot;, &quot;中国传统节日&quot;))
</code></pre><h3 id="3-3-Qt界面"><a href="#3-3-Qt界面" class="headerlink" title="3.3 Qt界面"></a>3.3 Qt界面</h3><p>最终要做出来的程序是需要有界面的，而不是终端中显示结果，所以需要使用Qt进行界面设计。</p>
<h4 id="3-3-1-Pycharm中PyQt5的配置"><a href="#3-3-1-Pycharm中PyQt5的配置" class="headerlink" title="3.3.1 Pycharm中PyQt5的配置"></a>3.3.1 Pycharm中PyQt5的配置</h4><p>主要是添加三个External Tool,具体添加教程可以参考 <a href="http://blog.csdn.net/a359680405/article/details/45074761" target="_blank" rel="external">http://blog.csdn.net/a359680405/article/details/45074761</a></p>
<h4 id="3-3-2-使用QtDesigner-设计界面"><a href="#3-3-2-使用QtDesigner-设计界面" class="headerlink" title="3.3.2 使用QtDesigner 设计界面"></a>3.3.2 使用QtDesigner 设计界面</h4><p>在项目名上右键选择external tool打开<code>qtdesiginer</code> .</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_14_55_39_qtdesigner.png" alt=""></p>
<p> 这是图形化设计界面的工具，可以直接在窗口中拖动控件，并会保存为.ui格式。如图所示，设计界面。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_14_58_33_jiemian.png" alt=""></p>
<p>对象结构如下所示：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_14_57_44_jiegou.png" alt=""></p>
<p>保存文件，生成的文件形如 <code>window.ui</code> .</p>
<h4 id="3-3-3-使用QtDesigner-设计界面"><a href="#3-3-3-使用QtDesigner-设计界面" class="headerlink" title="3.3.3 使用QtDesigner 设计界面"></a>3.3.3 使用QtDesigner 设计界面</h4><p>在生成的 <code>window.ui</code> 上右键，选择external tool中的PyUIC,然后会自动生成window.py文件，打开后可以看到，里面是UI的程序。</p>
<h4 id="3-3-4-打包资源"><a href="#3-3-4-打包资源" class="headerlink" title="3.3.4 打包资源"></a>3.3.4 打包资源</h4><p>需要注意的是，如果程序中使用到了图片资源，虽然可以直接引用图片的资源文件，如下面的代码：</p>
<pre><code>self.buttonList[i].setStyleSheet(&quot;background-image:url(checked.png)&quot;)
</code></pre><p><code>checked.png</code> 是放在项目根目录下的一个图片资源，直接运行是没有问题的，但是如果打包程序，在生成的dist文件夹中只有exe文件，并没有<code>checked.png</code>资源，运行就会没有效果甚至出错，当然你可以把图片复制到dist文件中，但是如果图片很多呢？而且也不便于传播，一个完整exe程序，双击打开就能用是最好的。</p>
<p>所以就需要使用qt的资源包，在qtdesigner中右下角的资源浏览器中，点击“铅笔”图标，添加资源文件。然后点击新建资源文件（弹出的对话框中有6个图标，第一个是新建资源文件），然后点击添加新前缀，取个名字如button,然后选中刚刚新建的button这个前缀，添加文件（倒数第二个图标），这样把需要用到的图标添加进去，可以自己根据需要调整分类。添加好之后的资源文件形如下图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_15_12_14_ziyuan.png" alt=""></p>
<h4 id="3-3-5-显示窗口"><a href="#3-3-5-显示窗口" class="headerlink" title="3.3.5 显示窗口"></a>3.3.5 显示窗口</h4><p>在主入口文件中 定义一个窗口类。</p>
<pre><code>class MainWindow(QMainWindow):
    def __init__(self,allFestival,parent = None):
        QMainWindow.__init__(self,parent)
        self.ui = Ui_mainWindow()
        self.ui.setupUi(self)
        self.ui.setFestivalList(allFestival)
        for festival in allFestival:
            text = festival.getFestival()+&quot;\n&quot;+festival.getDateString()
            left_date = festival.getDate() - now
            if left_date.days &gt; 0  and left_date.days &lt; 30 and festival.getType() != &quot;公众 / 国际节日&quot;:
                self.ui.addWidgetIntoGridLayout(text,True)
            else:
                self.ui.addWidgetIntoGridLayout(text, False)

app = QApplication(sys.argv)
mainWindow = MainWindow(allFestival)
mainWindow.show()
app.exec_()
</code></pre><p>其中addWidgetIntoGridLayout是我自己在Window.py中添加的一个函数，主要目的是动态添加一个按钮到GridLayout中</p>
<pre><code>def addWidgetIntoGridLayout(self,text,state):
    button = QtWidgets.QPushButton(text)

    if self.currentColumn &lt; self.maxColumn - 1:
        self.currentColumn = self.currentColumn + 1
    else:
        self.currentRow = self.currentRow + 1
        self.currentColumn = 0
    if state:
        button.setStyleSheet(&quot;background-image:url(:checkbox/checked.png)&quot;)
    else:
        button.setStyleSheet(&quot;background-image:none&quot;)
    button.setObjectName(str(self.currentRow*self.maxColumn + self.currentColumn))
    button.clicked.connect(lambda: self.changeState(int(button.objectName())))
    self.buttonList.append(button)
    self.gridLayout.addWidget(button, self.currentRow, self.currentColumn)
    self.stateList.append(state)
</code></pre><h4 id="3-3-6-统计倒计时结果"><a href="#3-3-6-统计倒计时结果" class="headerlink" title="3.3.6 统计倒计时结果"></a>3.3.6 统计倒计时结果</h4><p>程序中使用了一个list来保存GridLayout中所有的按钮的状态，点击一次按钮时为选中状态，再点击一次就会变成非选中状态。<br>还是用了一个festivalList保存所有的节日信息。<br>点击计算倒计时按钮的时候，就会遍历这个list,如果button为选中状态，那么根据按钮的下标在festivalList查询中查询节日信息，从而计算倒计时时间，具体代码：</p>
<pre><code>def calculate(self):
    now = date.today()
    flag = True
    resultStr = &quot;今天是&quot;+str(now.year)+&quot;年&quot;+str(now.month)+&quot;月&quot;+str(now.day)+&quot;日，星期&quot;+self.getChineseStr(now.weekday())+&quot;。今天&quot;
    for i in range(len(self.stateList)):
        if self.stateList[i]:
            festival = self.festivalList[i]
            resultStr += &quot;距%s还有%d天,&quot;%(festival.getFestival(),(festival.getDate() - now).days)
        if now == self.festivalList[i].getDate() and flag:
            resultStr = &quot;今天是&quot; + str(now.year) + &quot;年&quot; + str(now.month) + &quot;月&quot; + str(
                now.day) + &quot;日，星期&quot; + self.getChineseStr(now.weekday()) + &quot;。今天是&quot;+self.festivalList[i].getFestival()+&quot;。今天&quot;
            flag = False
    resultStr = resultStr[:-1]+&quot;。&quot;
    self.textEdit.clear()
    self.textEdit.append(resultStr)
</code></pre><h2 id="四-程序发布"><a href="#四-程序发布" class="headerlink" title="四. 程序发布"></a>四. 程序发布</h2><h3 id="4-1-安装PyInstaller"><a href="#4-1-安装PyInstaller" class="headerlink" title="4.1 安装PyInstaller"></a>4.1 安装PyInstaller</h3><p>使用 <code>pip install pyinstaller</code>安装 PyInstaller.</p>
<h3 id="4-2-打包程序"><a href="#4-2-打包程序" class="headerlink" title="4.2 打包程序"></a>4.2 打包程序</h3><p>首先注意打包过程可能出现各种错误，先做好心理准备。</p>
<p>按照网络上的一般教程，使用pyqt库时候，一般是在主入口文件中添加，无论这个文件是否使用到，都需要导入以下库：</p>
<pre><code>from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
</code></pre><p>但是这样，在我的机器上是无法成功打包程序的，经常之前大量的尝试和搜索，找到了解决方案，需要在上面的库之前再加上一行：</p>
<pre><code>from PyQt5 import *
</code></pre><p>告诉打包程序需要使用PyQt5.</p>
<p>打包命令使用  </p>
<pre><code>pyinstaller --hidden-import queue -F -w GetFestivalDate.py
</code></pre><p>其中<code>--hidden-import queue</code> 很重要，如果不加上，可以生成exe但是运行时会闪退。</p>
<ul>
<li>-F 代表生成一个整体exe文件.</li>
<li>-w 代表生成的是图形化程序，对应-c 代表控制台程序。</li>
</ul>
<p>然后在生成的dist文件夹下就能找到生成的exe文件了，赶紧双击打开试试吧。生成的exe是可以直接拷贝到其他电脑运行的，只是需要注意的是，如果运行的系统的位数需要和你打包程序时的系统一致。</p>
<h2 id="五-后记"><a href="#五-后记" class="headerlink" title="五.后记"></a>五.后记</h2><p>以上就是整个程序的开发过程，特记录下来，有两个目的，一个是希望后来的初学者不要步入这些坑了，另一个是帮助自己记录这些细节，方便以后查阅。</p>
<p>代码我上传到Github上了，欢迎大家Star her和 Follow me.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-节日倒计时软件制作&quot;&gt;&lt;a href=&quot;#Python-节日倒计时软件制作&quot; class=&quot;headerlink&quot; title=&quot;Python 节日倒计时软件制作&quot;&gt;&lt;/a&gt;Python 节日倒计时软件制作&lt;/h1&gt;&lt;h2 id=&quot;一-项目描述&quot;&gt;&lt;
    
    </summary>
    
      <category term="Python" scheme="http://www.orzangleli.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.orzangleli.com/tags/Python/"/>
    
      <category term="软件" scheme="http://www.orzangleli.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结</title>
    <link href="http://www.orzangleli.com/2016/12/29/2016-12-29_2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://www.orzangleli.com/2016/12/29/2016-12-29_2016年度总结/</id>
    <published>2016-12-28T16:00:00.000Z</published>
    <updated>2017-01-10T14:13:17.551Z</updated>
    
    <content type="html"><![CDATA[<p>今年做了四件事：</p>
<ol>
<li><p>找工作</p>
</li>
<li><p>Android </p>
</li>
<li><p>Unity</p>
</li>
<li><p>Python</p>
</li>
</ol>
<h2 id="1-找工作"><a href="#1-找工作" class="headerlink" title="1. 找工作"></a>1. 找工作</h2><p>今年9月份开始回的武汉找工作，到11月份回无锡，正好两个月时间。因为9月份就找到了比较合适的，所以找工作主要集中在9月份，10月份在武汉基本没怎么去面试，就在剩下的时间里开始了自学Python。</p>
<p>一共找到以下几家公司的Offer,在我所在的学院里，既不算多的，也不算好的。</p>
<ol>
<li>斗鱼TV      <em>一家总部在武汉的视频直播公司，以前一家独大</em></li>
<li>中兴   <em>面试的岗位是移动开发工程师，主要觉得没有发展前景</em></li>
<li>58同城  <em>在北京，远，岗位挺好的，转转里的Android开发</em></li>
<li>华信证券  <em>在上海，工资一般，但是android团队竟然只有4个人，感觉没有任何希望</em></li>
<li>善行医疗  <em>在深圳，做医疗VR的，但是工资低</em></li>
</ol>
<p>以上几家公司，我选择了58同城，因为相对来说，它是技术上能够拿得有进步的，而且前景也比较好，虽然公司前景跟个人没啥根本利益关系，但是在一家有互联网氛围的公司学习工作也是一种好的体验。</p>
<h2 id="2-Android"><a href="#2-Android" class="headerlink" title="2. Android"></a>2. Android</h2><p>今年基本上结束了前几年开发android的方式，前几年是利用老的技术不断去开发各种APP,然后上传到应用市场，拿去售卖，再获得广告收入。<br>改变的原因有两个：一方面，我认为加广告对用户体验有很大影响，不愿意使用广告；另一方面，这些广告的收入也是很微薄。所以我就没有必要去为了挣钱去做那些没有特殊意义，为了迎合别人的APP了，我要做我自己想做的APP，学自己想学的技术。</p>
<p>今年Android方面的热门技术都有一些大致的了解：</p>
<ul>
<li>图片加载库： UIL,Picasso,Glide,Fresco.</li>
<li>网络通信库： Volley,OkHttp,NoHttp</li>
<li>MultiDex与热修复: 阿里的AndFix，QQ空间的HotFix,微信的Tinker（还没了解） </li>
</ul>
<h3 id="1-开源控件"><a href="#1-开源控件" class="headerlink" title="1. 开源控件"></a>1. 开源控件</h3><p>自己也还写了几个开源控件，都上传都Github上了，Github上的图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_27_34_github_contributions.png" alt=""></p>
<p><strong>1.<a href="https://github.com/hust201010701/RoateIndicatorViewDemo" target="_blank" rel="external">RoateIndicatorViewDemo</a></strong></p>
<p>高仿转转APP中的轮播图片的指示器</p>
<p><img src="http://lxctest.qiniudn.com/2016-11-10_15:57:31_zhuanzhuan2.webp" alt=""></p>
<p><strong>2.<a href="https://github.com/hust201010701/Danmu" target="_blank" rel="external">Danmu</a></strong></p>
<p>弹幕控件，可以切换弹幕水平/竖直运动方向,可以控制弹幕正向/逆向运动</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_09_04_danmu.gif" alt=""></p>
<p><strong>3. <a href="https://github.com/hust201010701/CouponView" target="_blank" rel="external">CouponView</a></strong></p>
<p>卡券视图: CouponView 是一个继承自LinearLayout的布局View,边缘可以实现自动裁剪效果，所以用来做优惠券等视图效果很好。</p>
<p><img src="http://i.imgur.com/pj4XTxr.png" alt=""></p>
<h3 id="2-Android项目"><a href="#2-Android项目" class="headerlink" title="2. Android项目"></a>2. Android项目</h3><p><strong>1. Hust-Wuxi 考勤查询系统</strong></p>
<p>因为官方的APP中，没有给考勤查询的功能，要查看考勤只能登陆网页，这很不方便，所以我通过分析网络请求找到了查询的API，然后自己写了一个客户端，用颜色标识考勤结果。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_09_04_kaoqin1.png" alt=""><br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_09_04_kaoqin2.png" alt=""><br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_08_55_kaoqin3.png" alt=""></p>
<p><strong>2. 校招宝</strong></p>
<p>一款获取海投网上宣讲会数据的APP,自己利用Bmob增加了评论和收藏的功能。海投网API老是变，我这会写总结的时候，APP又挂了。</p>
<p><strong>3. LOL视频宝</strong></p>
<p>这款软件使用了Python爬虫获取多玩饭盒APP中LOL视频资源，然后存到LeanCloud云端数据库，android端再通过SDK获取云端数据库资源。还未发布，目前正在内测和修改中。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol1.png" alt=""></p>
<p>主页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol2.png" alt=""></p>
<p>关注页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol3.png" alt=""></p>
<p>详情页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol4.png" alt=""></p>
<p>下载页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol5.png" alt=""></p>
<p>首页菜单</p>
<h2 id="3-Unity3D"><a href="#3-Unity3D" class="headerlink" title="3. Unity3D"></a>3. Unity3D</h2><p>今年的主要任务也是Unity3D,本身是一款游戏引擎，我们拿来做工业VR应用也是可以的。<br>因为一直没有接到正式的项目，所以在探索与尝试加上导师的指示中做了以下几点工作：</p>
<p><strong>1. TQ的发动机装配生产线的监控系统</strong></p>
<p>因为没有传感器数据，自己根据动画生成了数据库，然后又根据这些数据来模拟车间机械结构动作，只是模型好像有点问题，播放起来有点卡。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_13_39_tq1.png" alt=""></p>
<p><strong>2. 某起重机的模拟</strong></p>
<p>这个做了两个项目，一个是在Oculus Rift Dk2下做的，因为oculus这款不带交互设备，只能通过目光中心选取物体，所以动画都是半自动的，点一个按钮，动画就会播放，不可以控制运动过程。</p>
<p>后面Htc Vive眼镜到货了，就开始使用这款眼镜，自带定位器和控制器，所以利用了这个做了一个可以控制运动过程的系统，而且还单独配了一套使用LeapMotion的系统，可以用手直接操作VR场景中的物体。</p>
<p><strong>3. 车床切削过程的VR模拟系统</strong></p>
<p>选取了一款简单的车床，模拟车削加工过程。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_13_39_chexie.png" alt=""></p>
<p><strong>4. 发动机侧护板装配VR系统</strong></p>
<p>在VR系统中操作吊机完成侧护板的装配，还可以监控车间的状态参数。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_13_39_cehuban.png" alt=""></p>
<h2 id="4-Python"><a href="#4-Python" class="headerlink" title="4. Python"></a>4. Python</h2><p>有人说，人生苦短，我用Python. 真的，自从11月份开始学习Python来，我越来越认同这个观点。Python的强大第三方库，让我渐渐见识到一个新的世界。</p>
<p><strong>1. 七牛文件上传器</strong></p>
<p>利用七牛云，可以把电脑上的文件上传到云空间中，对于图片还可以自动生成Markdown格式外链，方便写博客的时候插入链接，我这篇文章用的就是自己的软件上传的图片。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/8cb58cc2gw1faq1vvmv5gj20vh0ho0y3.jpg" alt=""></p>
<p><strong>2. 博客迁移爬虫</strong></p>
<p>之前的博客在主机公园上，真的差，打开首页都要10几秒，后来用了Hexo+Github Pages.<br>要是一份份的复制粘贴之前的博客文章也是效率低，于是写了一个爬虫将博客文章，按照日期保存到本地。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_30_49_blogqianyi.png" alt=""></p>
<p><strong>3. LOL视频宝的视频数据爬虫</strong></p>
<p> 之前本来想在年前做一款新闻阅读APP的，至于为什么要改成做LOL视频咨询客户端，原因如下：</p>
<blockquote>
<p>因为我认为一款新闻客户端是否优秀不在于它交互方式或者UI多么炫酷，而在于新闻的内在质量和推荐算法，就算我能够爬到很多新闻源，也不能将它们堆砌的提交给用户，这是对用户不负责任，所以筛选算法和推荐算法很重要，出于能力问题，这一块我决定放弃。</p>
<p>为什么我要做LOL视频合集，因为现在在PC上找不到完整的LOL分类，大都是零散的，混乱的，不便于用户使用；而目前APP上，我也只看到多玩饭盒做的还可以，有很详细的分类，但是仍然不够好，曾经因为一段时间主播跳槽，虎牙将主播封杀，该主播视频就没有，另一方面，它们这些APP永远在做加法，功能越来越臃肿，我作为LOL玩家，我只想关于LOL的新闻咨询或者视频，不想玩你的社区，不想看你的美女视频，我只想静静的看视频。</p>
</blockquote>
<p>所以宗旨是：给用户一个干净的，完整的LOL视频观看体验。</p>
<p>利用Packet Capture和浏览器的F12功能，推理+解析了很久，终于剥离出查询的API.然后赶紧写了一个python把服务器中的视频资源存到数据库中。视频资源挺丰富，数据量有20k.</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_30_49_shipinbao.png" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>2016年，我主要的我就是四件事情，很惭愧，就做了一点微小的工作，谢谢大家。2017年，继续加油。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年做了四件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;找工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unity&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-找工作&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="未分类" scheme="http://www.orzangleli.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="未分类" scheme="http://www.orzangleli.com/tags/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>侧护板装配VR系统技术细节</title>
    <link href="http://www.orzangleli.com/2016/12/14/2016-12-14_%E4%BE%A7%E6%8A%A4%E6%9D%BF%E8%A3%85%E9%85%8DVR%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    <id>http://www.orzangleli.com/2016/12/14/2016-12-14_侧护板装配VR系统技术细节/</id>
    <published>2016-12-13T16:00:00.000Z</published>
    <updated>2017-01-10T14:13:30.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li>模型格式转化和处理</li>
<li>装配流程设计</li>
<li>动画设计</li>
<li>第三方库（VRTK，DOTween）的使用</li>
<li>交互方式设计</li>
</ol>
<h2 id="一-模型格式转化和处理"><a href="#一-模型格式转化和处理" class="headerlink" title="一.模型格式转化和处理"></a>一.模型格式转化和处理</h2><p>在任意的VR系统都有大量的模型需求，我总结了以下两种模型获取方式：</p>
<h3 id="1-使用三维绘图软件绘制模型并转换格式"><a href="#1-使用三维绘图软件绘制模型并转换格式" class="headerlink" title="1. 使用三维绘图软件绘制模型并转换格式"></a>1. 使用三维绘图软件绘制模型并转换格式</h3><p>以我常用的Catia为例，先绘制出模型，然后将模型转为CGR格式，注意一定要这个格式，经过我的测试，如果不是这个格式再接下来转换格式时会失败。</p>
<h3 id="2-使用3Ds-Max绘制模型"><a href="#2-使用3Ds-Max绘制模型" class="headerlink" title="2. 使用3Ds Max绘制模型"></a>2. 使用3Ds Max绘制模型</h3><p>这需要会使用3Ds Max的人员来做，由于我们这边缺乏这样的人，所以一般使用3Ds Max的模型都是从网络上下载下来的。</p>
<h2 id="二-装配流程设计"><a href="#二-装配流程设计" class="headerlink" title="二. 装配流程设计"></a>二. 装配流程设计</h2><p>根据三维仿真视频，可以看出装配流程如下所示：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_10_37_34_流程图.png" alt="去"></p>
<p>为了增强交互性，动画中人模型所做的事，将在VR系统中以第一人称的视角完成所有装配。</p>
<h2 id="三-动画设计"><a href="#三-动画设计" class="headerlink" title="三. 动画设计"></a>三. 动画设计</h2><p>可以从动画中看出有几处机构的运动形式：</p>
<ol>
<li>吊机的控制</li>
<li>侧护板的移动</li>
<li>夹具的夹紧和松开动作</li>
</ol>
<p>这几种是比较典型的几种运动形式，针对不同的运动形式，需要进行不用的动画设计。</p>
<h3 id="1-吊机的控制"><a href="#1-吊机的控制" class="headerlink" title="1. 吊机的控制"></a>1. 吊机的控制</h3><p>吊机的示意图如下：<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_10_59_38_吊机结构.png" alt=""></p>
<p>吊机的控制，这个是最基本的，就是通Transform组件，对物体进行移动。只不过这些需要注意的是，不同方向的移动是针对不同物体的，例如，上下方向移动是挂钩的移动，而左右移动是电机的移动，前后的移动是横梁的移动。</p>
<p>在程序，我定义了一个枚举类型，表示吊机目前的状态：</p>
<pre><code>public enum State {UP,DOWN,FRONT,BACK,LEFT,RIGHT,IDLE};
</code></pre><p>其中<code>IDLE</code>表示吊机静止状态。</p>
<p><strong>需要注意的细节</strong></p>
<p>这里有一个技术细节：连接电机和挂钩的『绳子』，它的长度是变化的，需要和挂钩保持同步。在VR系统中它并不是真正的绳子，而是一个圆柱体，绳子长度变化的时候，实际上是圆柱体沿竖直方向的scale值变化。另外，因为绳子总是从电机出发出，所以需要将圆柱体的锚点设置在电机处，否则绳子在变长到一定程度时，会看到绳子已经穿过了电机。</p>
<h3 id="2-侧护板的移动"><a href="#2-侧护板的移动" class="headerlink" title="2. 侧护板的移动"></a>2. 侧护板的移动</h3><p>相对来说，侧护板的移动不是一种『自主运动』，它是被吊机吊起来的，所以这种运动是不同于上述方法的处理。对于侧护板需要事先添加碰撞器，并添加脚本，碰撞器添加在挂带的中心位置，这样当挂钩碰到中心位置时，就能检测到。<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_11_26_52_侧护板碰撞器.png" alt=""><br>在检测到碰撞后，判断如果碰撞器如果是来自侧护板，就代表现在用户想使用挂钩将侧护板吊起来。在<code>OnTriggerEnter</code>中，将侧护板的parent设置为挂钩，这样侧护板就能够跟着挂钩移动了。</p>
<pre><code>collider.transform.parent = this.transform;
collider.transform.position = bornPlace.position;
</code></pre><h3 id="3-夹具的夹紧和松开动作"><a href="#3-夹具的夹紧和松开动作" class="headerlink" title="3. 夹具的夹紧和松开动作"></a>3. 夹具的夹紧和松开动作</h3><p>夹具的动作包括张开和闭合，动画如图所示：<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_13_47_43_夹具.gif" alt=""><br>夹具的动作很复杂，基本上无法通过脚本控制实现，所以，最好使用Unity中的Animation完成动画，而且夹具的动作张开和闭合是对称的，所以只需要完成闭合的动作就可以了，张开的动作可以将动画的播放速度调整为-1即可倒着播放。另外，在夹具闭合的时候，要把护板添加到夹具的两侧中，以达到夹具加紧侧护板的视觉效果。下面就是夹具闭合的代码：</p>
<pre><code>public void bihe()
{
    AnimatorStateInfo info = animator.GetCurrentAnimatorStateInfo(0);
    if ((info.IsName(&quot;jiaju_zhangkai&quot;) &amp;&amp; info.normalizedTime &gt;= 1) || info.IsName(&quot;idle&quot;))
    {

        //将左右护板添加到夹具中
        Transform yeyazhijia = this.transform.parent;
        Transform left_huban = yeyazhijia.FindChild(&quot;huban_guadai_left(Clone)&quot;);
        Transform right_huban = yeyazhijia.FindChild(&quot;huban_guadai_right(Clone)&quot;);
        Transform zuodangban = this.transform.FindChild(&quot;jiajuzhengti_copy/jiaju/zuodangban&quot;);
        Transform youdangban = this.transform.FindChild(&quot;jiajuzhengti_copy/jiaju/youdangban&quot;);

        if (Vector3.Distance(left_huban.position, zuodangban.position) &gt; Vector3.Distance(left_huban.position, youdangban.position))
        {
            normal = false;
            if (left_huban != null)
                left_huban.parent = youdangban;
            if (right_huban != null)
                right_huban.parent = zuodangban;
        }
        else
        {
            normal = true;
            if (left_huban != null)
                left_huban.parent = zuodangban;
            if (right_huban != null)
                right_huban.parent = youdangban;
        }

        animator.Play(&quot;jiaju_bihe&quot;);
        biheButton.interactable = false;
        zhangkaiButton.interactable = true;

        //同时使碰撞器失效，防止在未松开之前拉上去
        this.GetComponent&lt;Collider&gt;().enabled = false;
        stepHint.text = &quot;夹紧操作完成，请点击菜单中的『夹具张开』按钮&quot;;
    }
}
</code></pre><h2 id="四-第三方库（VRTK，DOTween）的使用"><a href="#四-第三方库（VRTK，DOTween）的使用" class="headerlink" title="四. 第三方库（VRTK，DOTween）的使用"></a>四. 第三方库（VRTK，DOTween）的使用</h2><p>本VR系统中主要使用了两个第三方库：</p>
<ul>
<li><p><strong>VRTK</strong>    <em>这个工具包提供了很多Unity3d里的常用VR功能，如下（但并不局限于此）：</em></p>
<ul>
<li>带有通用别名的控制器按钮事件</li>
<li>控制器世界指针（如激光指针）</li>
<li>玩家传送</li>
<li>用控制器抓取对象</li>
<li>用控制器和对象交互</li>
</ul>
</li>
<li><p><strong>DOTween</strong>  <em>DOTween是Unity中具有强大功能的动画插件</em></p>
</li>
</ul>
<h3 id="1-VRTK的使用"><a href="#1-VRTK的使用" class="headerlink" title="1. VRTK的使用"></a>1. VRTK的使用</h3><h4 id="1）-VRTK的安装"><a href="#1）-VRTK的安装" class="headerlink" title="1）. VRTK的安装"></a>1）. VRTK的安装</h4><p>VRTK从Assets Store中下载，下载完成后导入即可。</p>
<h4 id="2）-VRTK-射线的使用"><a href="#2）-VRTK-射线的使用" class="headerlink" title="2）. VRTK 射线的使用"></a>2）. VRTK 射线的使用</h4><p>在SteamVR包中[CameraRig]的Controller(right)上添加脚本VRTK_UI_Pointer,这是射线基本脚本，可以设置射线何时显示，比如按住按钮或者切换按钮或者一直显示等。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_35_51_VRTK_UI_Pointer.png" alt=""></p>
<p>还需要添加<code>VRTK_Simple_Pointer</code>脚本，这是直线射线发射脚本，除此之外还可以使用 <code>VRTK_Bezier_Pointer</code><br>它是贝泽尔曲线脚本。要指定按钮按住之后发射射线，还需要添加<code>VRTK_Controller Events</code>脚本，可以设置按下哪个按钮后发出射线。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_37_27_VRTK_ControllerEvents.png" alt=""></p>
<h4 id="3）-VRTK-中UI的使用"><a href="#3）-VRTK-中UI的使用" class="headerlink" title="3）. VRTK 中UI的使用"></a>3）. VRTK 中UI的使用</h4><p>VRTK中UI使用非常简单，只需要在普通的UGUI的Canvas上添加<code>VRTK_UI Canvas</code>脚本即可。</p>
<h3 id="2-DOTween的使用"><a href="#2-DOTween的使用" class="headerlink" title="2. DOTween的使用"></a>2. DOTween的使用</h3><p>DOTween十分强大，但是我在本系统中也只是使用到了其中的一部分功能。</p>
<h4 id="1-物体的移动"><a href="#1-物体的移动" class="headerlink" title="1). 物体的移动"></a>1). 物体的移动</h4><p>比如场景中，装配完成后，让生产线移动，实际上就是使用DOTween中的DOMove方法</p>
<pre><code>go.transform.DOLocalMoveZ(go.transform.localPosition.z - 1200f, 60).SetEase(Ease.Linear);
</code></pre><p>DOLocalMoveZ指的是在局部坐标系的Z轴方向上移动到go.transform.localPosition.z - 1200f这个位置，实际上就是向Z轴反方向移动1200，所用的时间是60秒，动画插值器使用的是线性插值。</p>
<h4 id="2-物体的缩放"><a href="#2-物体的缩放" class="headerlink" title="2). 物体的缩放"></a>2). 物体的缩放</h4><p>在菜单显示和关闭的时候，增加一个缩放的动画可以增强用户体验</p>
<pre><code>toolbox.transform.DOScale(0.005f, 0.5f);
</code></pre><p>这句代码的意思就是将菜单的大小放大到0.005,使用的时间是0.5秒。</p>
<h4 id="3-滚动数码管显示器"><a href="#3-滚动数码管显示器" class="headerlink" title="3). 滚动数码管显示器"></a>3). 滚动数码管显示器</h4><p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_51_22_显示器.gif" alt=""></p>
<p>要实现以上效果，需要在Canvas下添加一个遮罩层(Image组件)，给遮罩层添加Mask脚本，并且给Image指定一个图片，这个图片就是指定的Mask的遮罩形状，这样在遮罩层以外的UI都不会显示了。</p>
<p>要实现文字连续滚动，事先添加两个Text，如图所示，由于有Mask层存在，第二个是看不到的。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_56_26_状态监测UI.png" alt=""></p>
<p>然后给这两个Text上添加脚本，让他们移动。</p>
<pre><code>this.transform.DOLocalMoveX(this.transform.localPosition.x -1000f,5).SetEase(Ease.Linear).SetLoops(-1,LoopType.Restart);
</code></pre><p>数码管的长度正好为1000，让两个文字一起在5秒中内向左移动1000，移动完成后重新启动动画(复位)，这样就实现了文字无限循环的滚动了。</p>
<h2 id="五-交互方式设计"><a href="#五-交互方式设计" class="headerlink" title="五. 交互方式设计"></a>五. 交互方式设计</h2><p>系统做出来是给人使用的，交互设计也是十分重要，虽然目前我对本系统的交互设计上也有点意见，但是目前尚未找到更好的方案，下面将详细说明。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_15_16_34_手柄按键说明.png" alt=""></p>
<h3 id="1-左手手柄"><a href="#1-左手手柄" class="headerlink" title="1. 左手手柄"></a>1. 左手手柄</h3><ul>
<li>左手手柄的触摸板，轻触时显示控制吊机移动的菜单，滑动可以选择菜单，按下时将执行动作。</li>
<li>左手手柄的Grip键(侧面的两个按钮)是旋转挂钩的方向的。</li>
<li>Application键用来显示和隐藏手柄上的提示文字</li>
</ul>
<h3 id="2-右手手柄"><a href="#2-右手手柄" class="headerlink" title="2. 右手手柄"></a>2. 右手手柄</h3><ul>
<li><p>触摸板按下时发出射线</p>
<ul>
<li>若发出的射线指向地面，松开触摸板即可瞬移到该位置</li>
<li>若发出的射线指向UI界面，配合Trigger(扳机键)可以实现点击按钮的操作。</li>
</ul>
</li>
<li><p>Grip键(侧面的两个按钮)是用于显示和关闭菜单的</p>
</li>
</ul>
<h3 id="3-目前方案存在的问题"><a href="#3-目前方案存在的问题" class="headerlink" title="3.目前方案存在的问题"></a>3.目前方案存在的问题</h3><p>之前说过这个方案是有不足的，主要在于吊机的控制。吊机需要6个按钮来控制，分别是上下东西南北，如果要将这6个按钮显示在一起，就是上面的方案，可以看到无论怎么分布，使用无法保证东西南北的四个方向与真实的场景中的方向一致，所以在操作吊机时，不熟悉的使用者需要一直看着手柄进行操作。</p>
<h3 id="4-潜在的解决方法"><a href="#4-潜在的解决方法" class="headerlink" title="4.潜在的解决方法"></a>4.潜在的解决方法</h3><h4 id="1-分解菜单"><a href="#1-分解菜单" class="headerlink" title="1). 分解菜单"></a>1). 分解菜单</h4><p>在展会的时候，有人就提出了这个问题，后来我问他有什么好的建议，他说可以把东西南北做到左手手柄上，将上下两个按钮做到右手手柄上，这样右手手柄上发射射线的按钮就需要修改下了，不过这也是一种方案。</p>
<h4 id="2-将6等分菜单变为8等分菜单"><a href="#2-将6等分菜单变为8等分菜单" class="headerlink" title="2). 将6等分菜单变为8等分菜单"></a>2). 将6等分菜单变为8等分菜单</h4><p>很简单的原理，示意图如下所示：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_15_51_08_按键方案2.png" alt=""></p>
<p>至于哪种方案好，我暂时也没有办法判断，所以只好先全部记录下来了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;模型格式转化和处理&lt;/li&gt;
&lt;li&gt;装配流程设计&lt;/li&gt;
&lt;li&gt;动画设计&lt;/li&gt;
&lt;li&gt;第三方库（VRTK，DOTwe
    
    </summary>
    
      <category term="unity3D" scheme="http://www.orzangleli.com/categories/unity3D/"/>
    
    
      <category term="unity3D" scheme="http://www.orzangleli.com/tags/unity3D/"/>
    
  </entry>
  
  <entry>
    <title>pyqt打包失败.md</title>
    <link href="http://www.orzangleli.com/2016/12/13/2016-12-13_pyqt%E6%89%93%E5%8C%85%E5%A4%B1%E8%B4%A5/"/>
    <id>http://www.orzangleli.com/2016/12/13/2016-12-13_pyqt打包失败/</id>
    <published>2016-12-12T16:00:00.000Z</published>
    <updated>2016-12-29T13:51:57.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题"><a href="#pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题" class="headerlink" title="pyqt 打包失败 出现pyi_rth_qt4plugins 找不到的问题"></a>pyqt 打包失败 出现pyi_rth_qt4plugins 找不到的问题</h1><ol>
<li><p>pyqt5的位数和系统位数要一致。</p>
</li>
<li><p>pyqt版本为：PyQt GPL v5.4.1 for Pythonv3.4(x64)</p>
</li>
</ol>
<p>环境截图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_09_59_32_python环境截图.png" alt=""></p>
<p>使用下面的语句进行打包：<br>pyinstaller –hidden-import queue -F -w MainWindow.py</p>
<p>后来由出现QtCore可以找到，但是QtWidgets找不到，但是不知道怎么回事，重新打包了n次后就自动好了，不知道是不是之前设置的环境变量要过一会才会生效，设置的环境变量就是QtCore,QtGui,QtWidgets三个dll文件。</p>
<p>在管理员模式下运行命令行，进行PyInstaller安装</p>
<p>加上这句话：<br>    from PyQt5 import *<br>这句话才是精髓，不加就不能运行，加了就可以。。。额！</p>
<p>C:\Users\Administrator\AppData\Roaming\pyinstaller\bincache00_py34_64bit\qt5gui.dll 可能是去这个目录找那个dll，然后没找到。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题&quot;&gt;&lt;a href=&quot;#pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题&quot; class=&quot;headerlink&quot; title=&quot;pyqt 打包失败 出现pyi_rt
    
    </summary>
    
      <category term="python" scheme="http://www.orzangleli.com/categories/python/"/>
    
    
      <category term="python" scheme="http://www.orzangleli.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用Python将Jpeg Png Gif 图片转换为 webp格式</title>
    <link href="http://www.orzangleli.com/2016/11/10/2016-11-10_Python%E5%B0%86Jpeg%20Png%20Gif%E8%BD%AC%E6%8D%A2%E4%B8%BAWebp%E6%A0%BC%E5%BC%8F/"/>
    <id>http://www.orzangleli.com/2016/11/10/2016-11-10_Python将Jpeg Png Gif转换为Webp格式/</id>
    <published>2016-11-09T16:00:00.000Z</published>
    <updated>2016-11-10T14:05:29.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Python将Jpeg-Png-Gif-图片转换为-webp格式"><a href="#使用Python将Jpeg-Png-Gif-图片转换为-webp格式" class="headerlink" title="使用Python将Jpeg Png Gif 图片转换为 webp格式"></a>使用Python将Jpeg Png Gif 图片转换为 webp格式</h1><h2 id="一-动机"><a href="#一-动机" class="headerlink" title="一.动机"></a>一.动机</h2><p>因为webp的优良特性：</p>
<ul>
<li><p>占空间小，节省带宽</p>
</li>
<li><p>总体加载速度快</p>
</li>
</ul>
<p>这里有详细的介绍： 摘自 <a href="https://zh.wikipedia.org/wiki/WebP" target="_blank" rel="external">维基百科-WebP词条</a></p>
<p>WebP（发音weppy）[6][7]，是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式[8]，派生自视频编码格式VP8[9]，被认为是WebM多媒体格式的姊妹项目，是由Google在购买On2 Technologies后发展出来[10]，以BSD授权条款发布。[11]<br>WebP最初在2010年发布，目标是减少文件大小，但达到和JPEG格式相同的图片质量，希望能够减少图片档在网络上的发送时间。 [12]2011年11月8日，Google开始让WebP支持无损压缩和透明色（alpha通道）的功能，而在2012年8月16日的参考实做libwebp 0.2.0中正式支持[13][14]。根据Google较早的测试，WebP的无损压缩比网络上找到的PNG档少了45％的文件大小，即使这些PNG档在使用pngcrush和PNGOUT处理过，WebP还是可以减少28％的文件大小[15]。<br>WebP支持的像素最大数量是16383x16383。有损压缩的WebP仅支持8-bit的YUV 4:2:0格式。而无损压缩（可逆压缩）的WebP支持VP8L编码与8-bit之ARGB色彩空间。又无论是有损或无损压缩皆支持Alpha透明通道、ICC色彩配置、XMP诠释数据。<br>WebP有静态与动态两种模式。动态WebP（Animated WebP）支持有损与无损压缩、ICC色彩配置、XMP诠释数据、Alpha透明通道。而无损压缩的动态WebP亦支持8-bit之ARGB色彩空间。</p>
<h2 id="二-方案实验"><a href="#二-方案实验" class="headerlink" title="二. 方案实验"></a>二. 方案实验</h2><h3 id="1-使用PIL-转换格式"><a href="#1-使用PIL-转换格式" class="headerlink" title="1. 使用PIL 转换格式"></a>1. 使用PIL 转换格式</h3><p>首先指出，PIL转换在大部分情况下都能起到很好的效果，比如讲jpeg转为webp，节省空间约90%。<br>首先安装PIL模块</p>
<pre><code>pip install pillow
</code></pre><p>然后在程序中 <code>localfile</code> 为图片路径</p>
<pre><code>im = Image.open(localfile)
f,ext = os.path.splitext(localfile.split(&quot;/&quot;)[-1])
webp_path = &quot;%s.webp&quot;%f
im.convert(&apos;RGB&apos;).save(webp_path, &quot;webp&quot;)
</code></pre><p>这里需要注意需要将图片先转化为RGB模式，否则报错</p>
<pre><code>cannot write mode P as WEBP
</code></pre><p>现在，是时候说下PIL「失效」的情况了。</p>
<ol>
<li>将动图转为gif时，转化过程没有报错，但是打开后，只保存了第一帧的图片，变成了静态图。</li>
<li>将 gif 转为 webp格式时，同样也只保存了第一帧。</li>
</ol>
<p>第一种情况我没有测试，但是在stackoverflow上可以看到有人提问过： <a href="http://stackoverflow.com/questions/24688802/saving-an-animated-gif-in-pillow" target="_blank" rel="external">Saving an animated GIF in Pillow</a> 。回答者是建议使用gifmaker 模块进行处理gif.</p>
<p>第二张情况，我遇到了，所以可以证实。</p>
<p>通过搜索，在官网上看到<a href="https://developers.google.com/speed/webp/docs/gif2webp" target="_blank" rel="external">gif2webp</a>,证明官网给出了gif转webp的解决方案，那我们就下载适合自己版本的库<a href="https://storage.googleapis.com/downloads.webmproject.org/releases/webp/index.html" target="_blank" rel="external"></a>.<br>解压后，将bin 目录下的 gif2webp.exe 复制到 工作目录下。接下来，我们使用它来转化格式。</p>
<h3 id="2-使用gif2webp-exe转化格式"><a href="#2-使用gif2webp-exe转化格式" class="headerlink" title="2. 使用gif2webp.exe转化格式"></a>2. 使用gif2webp.exe转化格式</h3><p>根据官网给的文档<a href="https://developers.google.com/speed/webp/docs/gif2webp" target="_blank" rel="external">gif2webp</a>，我们可以很方便的使用下面的语句来实现：</p>
<pre><code>f,ext = os.path.splitext(localfile.split(&quot;/&quot;)[-1])
webp_path = &quot;%s.webp&quot;%f
os.system(&quot;gif2webp.exe &quot;+ localfile + &quot; -quiet &quot; + &quot; -o &quot; + f + &quot;.webp&quot;)
</code></pre><p>这里可能会提示：</p>
<pre><code>GIF decode warning: invalid background color index. Assuming white background.
</code></pre><p>转换过程持续好几秒，请耐心等待，转化完成后，工作目录下多一个webp文件.</p>
<h2 id="三-效果比较"><a href="#三-效果比较" class="headerlink" title="三.效果比较"></a>三.效果比较</h2><center>左边是gif格式的               右边是webp格式</center>


<p><img src="http://i.imgur.com/aFTWeSK.gif" alt="">   <img src="http://lxctest.qiniudn.com/2016-11-10_15:57:31_zhuanzhuan2.webp" alt=""></p>
<p>你的肉眼能看出区别么？</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用Python将Jpeg-Png-Gif-图片转换为-webp格式&quot;&gt;&lt;a href=&quot;#使用Python将Jpeg-Png-Gif-图片转换为-webp格式&quot; class=&quot;headerlink&quot; title=&quot;使用Python将Jpeg Png Gif 图片
    
    </summary>
    
      <category term="python" scheme="http://www.orzangleli.com/categories/python/"/>
    
    
      <category term="python" scheme="http://www.orzangleli.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>自己动手造轮子系列———实现『转转APP』Indicator 效果</title>
    <link href="http://www.orzangleli.com/2016/11/10/2016-11-19_%E8%BD%AC%E8%BD%ACIndicator/"/>
    <id>http://www.orzangleli.com/2016/11/10/2016-11-19_转转Indicator/</id>
    <published>2016-11-09T16:00:00.000Z</published>
    <updated>2016-11-10T14:06:01.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自己动手造轮子系列———实现『转转APP』Indicator-效果"><a href="#自己动手造轮子系列———实现『转转APP』Indicator-效果" class="headerlink" title="自己动手造轮子系列———实现『转转APP』Indicator 效果"></a>自己动手造轮子系列———实现『转转APP』Indicator 效果</h1><h2 id="一-『转转APP』效果预览"><a href="#一-『转转APP』效果预览" class="headerlink" title="一.『转转APP』效果预览"></a>一.『转转APP』效果预览</h2><p>注意看Indicator指示器</p>
<p><img src="http://lxctest.qiniudn.com/2016-11-10_15:57:31_zhuanzhuan2.webp" alt=""></p>
<h2 id="二-动作分析"><a href="#二-动作分析" class="headerlink" title="二.动作分析"></a>二.动作分析</h2><ol>
<li>左边部分</li>
</ol>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-10_19_59_20.png?imageView2/0/w/800" alt=""></p>
<p>左边部分是一个白色的圆圈，圆圈中用红色字体显示当前页数，在ViewPager滑动时，白色圆圈绕Y轴旋转，在旋转180度时，即显示背面的时候，圆圈中字变成下一页的页码。</p>
<ol>
<li>右边部分</li>
</ol>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-10_20_00_01.png?imageView2/0/w/800" alt=""></p>
<p>右边部分比较简单，一个带缺口的椭圆，上面显示着总页数。</p>
<h2 id="三-各个击破难点"><a href="#三-各个击破难点" class="headerlink" title="三.各个击破难点"></a>三.各个击破难点</h2><h3 id="1-用canvas绘制绕Y轴旋转"><a href="#1-用canvas绘制绕Y轴旋转" class="headerlink" title="1. 用canvas绘制绕Y轴旋转"></a>1. 用canvas绘制绕Y轴旋转</h3><p>Canvas 绘制图片时，如果是在绕Z轴旋转是比较简单，使用Matrix矩阵：</p>
<pre><code>Matrix matrix = new Matrix();
matrix.setRotate(angle);
Bimtap newBitmap = Bitmap.createBitmap(oldBitmap,0,0,oldBitmap.getWidth(),
    oldBitmap.getHeight(),matrix,true);
</code></pre><p>但是这只能在绘制图片时进行旋转，如果要对一个整体旋转则无法做到，比如，上面转转的指示器坐标的圆圈，圆圈是一个圆，上面还有数字，要实现圆和数字一起旋转，所以无法通过上述方法完成。</p>
<p>而且这个问题我在谷歌上搜索，也不太好表述，刚开始搜索「android canvas 3D旋转」，结果也不太相符，后来搜索「android canvas绕y轴 旋转」，才找到符合的。</p>
<p>使用 Android.graphics.Camera 的 rotateY 接口实现绕 Y 轴旋转时矩阵的运算。</p>
<p>首先声明camera </p>
<pre><code>camera = new Camera();
</code></pre><p>在Ondraw方法中，首先对canvas状态进行保存，使用的是<code>canvas.save()</code>,然后将camera状态保存，将camera旋转一个角度rotateAngle，在获取camera的矩阵赋值到matrix中，最后将camera状态恢复至旋转之前的状态。然后将matrix追加到当前canvas的矩阵中，使用的是concat方法，这时候整个画布相当于旋转了rotateAngle角度，画完圆之后再恢复至原来的状态。</p>
<pre><code>canvas.save();
Matrix matrix = new Matrix(); 
camera.save();
camera.rotateY(rotateAngle);
camera.getMatrix(matrix);
camera.restore();

mPaint.setColor(textBackgroundColor);
int centerX = diameter / 2;
int centerY = diameter / 2;
matrix.preTranslate(-centerX, -centerY);
matrix.postTranslate(centerX, centerY);
canvas.concat(matrix);

canvas.drawCircle(diameter / 2, diameter / 2, diameter / 2, mPaint);

canvas.restore();
</code></pre><h3 id="2-canvas-drawText文字垂直居中"><a href="#2-canvas-drawText文字垂直居中" class="headerlink" title="2. canvas drawText文字垂直居中"></a>2. canvas drawText文字垂直居中</h3><p>这个问题，如果没有遇到还真不知道会出现这种问题，一般想象的，我设置画笔的gravity属性为Paint.Align.CENTER，在将文字的中点设置下不就ok了么，如下面的代码：</p>
<pre><code>textPaint.setTextAlign(Paint.Align.CENTER);
canvas.drawText(&quot;of &quot; + maxPage, rect.centerX(), rect.centerY(), textPaint);
</code></pre><p>出现的效果，如图所示，发现文字是偏上：</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-10_21_15_24.png?imageView2/0/w/800" alt=""></p>
<p>这是怎么回事呢？其实我们设置的文字爱中心点处绘制，实际上，文字是以基准线为锚点进行绘制的，英文叫做baseline.</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-10_21_17_07.png?imageView2/0/w/800" alt=""></p>
<p>在维基百科中可以看到<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E7%B7%9A" target="_blank" rel="external">基线</a>的解释：</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-10_21_24_40.png?imageView2/0/w/800" alt=""></p>
<p>所以我们如果想让文字居中，则需要将绘制点的Y坐标向下移动。</p>
<p>基线到字体顶端的距离为top,基线到字体底端距离为bottom,则有以下等式：</p>
<pre><code>(top + baseline)+ (bottom + baseline) / 2 = centenY() 
</code></pre><p>那么经过计算就可以算出baseline的值，通过Paint.FontMetrics获取top和bottom值，代码如下：</p>
<pre><code>//画文字
Rect rect = new Rect(diameter, 0, (int) (diameter * 3.4f), diameter);//右边的背景图片的Rect
Paint textPaint = new Paint();
textPaint.setColor(Color.WHITE);
textPaint.setTextSize((int) (diameter * 0.6f));
textPaint.setStyle(Paint.Style.FILL);
//该方法即为设置基线上那个点究竟是left,center,还是right  这里我设置为center
textPaint.setTextAlign(Paint.Align.CENTER);

Paint.FontMetrics fontMetrics = textPaint.getFontMetrics();
float top = fontMetrics.top;//为基线到字体上边框的距离,即上图中的top
float bottom = fontMetrics.bottom;//为基线到字体下边框的距离,即上图中的bottom
int baseLineY = (int) (rect.centerY() - top / 2 - bottom / 2);//基线中间点的y轴计算公式
canvas.drawText(&quot;of &quot; + maxPage, rect.centerX(), baseLineY, textPaint);
</code></pre><h3 id="3-自动轮播"><a href="#3-自动轮播" class="headerlink" title="3. 自动轮播"></a>3. 自动轮播</h3><p>自动轮播，通过Handler+Timer即可。</p>
<pre><code>//定时自动播放
timer = new Timer();
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        Message message = new Message();
        message.what = 1;
        if (mViewPager.getCurrentItem() == Integer.MAX_VALUE - 1) {
            currentIndex = -1;
        }
        currentIndex = mViewPager.getCurrentItem();
        message.arg1 = currentIndex + 1;
        mHandler.sendMessage(message);
    }
},1000,2000);
</code></pre><p>然后自定义Handler.</p>
<pre><code>//定时轮播图片，需要在主线程里面修改 UI
private Handler mHandler = new Handler() {
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case 1:
                mViewPager.setCurrentItem(msg.arg1,true);
        }
    }
};
</code></pre><h2 id="四-代码实现"><a href="#四-代码实现" class="headerlink" title="四.代码实现"></a>四.代码实现</h2><p>代码在Github上，请不要吝啬Star噢。</p>
<p><a href="https://github.com/hust201010701/RoateIndicatorViewDemo" target="_blank" rel="external">RotateIndicatorView</a></p>
<h2 id="联系方式和建议"><a href="#联系方式和建议" class="headerlink" title="联系方式和建议"></a>联系方式和建议</h2><p>微博：orzangleli</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;自己动手造轮子系列———实现『转转APP』Indicator-效果&quot;&gt;&lt;a href=&quot;#自己动手造轮子系列———实现『转转APP』Indicator-效果&quot; class=&quot;headerlink&quot; title=&quot;自己动手造轮子系列———实现『转转APP』Indic
    
    </summary>
    
      <category term="android" scheme="http://www.orzangleli.com/categories/android/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="自己动手造轮子系列" scheme="http://www.orzangleli.com/tags/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%80%A0%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Plugin is too old, please update to a more recent version解决方法</title>
    <link href="http://www.orzangleli.com/2016/11/04/2016-11-04_Plugin%20is%20too%20old,%20please%20update%20to%20a%20more%20recent%20version%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.orzangleli.com/2016/11/04/2016-11-04_Plugin is too old, please update to a more recent version解决方法/</id>
    <published>2016-11-03T16:00:00.000Z</published>
    <updated>2017-01-10T14:13:45.083Z</updated>
    
    <content type="html"><![CDATA[<p>#Plugin is too old, please update to a more recent version问题解决方法</p>
<p>Android Studio 报错：</p>
<p>Plugin is too old, please update to a more recent version, or set ANDROID_DAILY_OVERRIDE environment variable to…</p>
<p>网上众说纷纭，但是实际上没有几个能用。<br>首先当然你可以把gradle版本调低，运行没问题，但是就不能体验到Instant Run等新功能，为了体验新功能，按照以下步骤进行。</p>
<h2 id="1-查看最新的gradle插件"><a href="#1-查看最新的gradle插件" class="headerlink" title="1. 查看最新的gradle插件"></a>1. 查看最新的gradle插件</h2><p>修改Project的build.gradle中版本<br><a href="https://bintray.com/android/android-tools/com.android.tools.build.gradle" target="_blank" rel="external">查看最新版本gradle插件</a></p>
<p>打开build.gradle(Project:xxx),修改下面代码为</p>
<p>修改前</p>
<pre><code>classpath &apos;com.android.tools.build:gradle:1.3&apos;
</code></pre><p>修改后</p>
<pre><code>classpath &apos;com.android.tools.build:gradle:+&apos;
</code></pre><h2 id="2-查看最新版本的gradle"><a href="#2-查看最新版本的gradle" class="headerlink" title="2. 查看最新版本的gradle"></a>2. 查看最新版本的gradle</h2><p>进入gralde下载网站： <a href="https://services.gradle.org/distributions/" target="_blank" rel="external">Gradle Distributions</a> </p>
<p>如图所示：</p>
<p><img src="http://lxctest.qiniudn.com/2016-11-04_11:34:36_1.png?imageView2/0/w/800" alt=""></p>
<p>可以看到最新版是gradle-3.2-rc-2-all.zip</p>
<h2 id="3-修改gradle-wrapper-properties"><a href="#3-修改gradle-wrapper-properties" class="headerlink" title="3.修改gradle-wrapper.properties"></a>3.修改gradle-wrapper.properties</h2><p>将gradle-wrapper.properties 中<code>distributionUrl</code>指向的内容修改为：</p>
<pre><code>distributionUrl=https\://services.gradle.org/distributions/xxx
</code></pre><p><code>xxx</code> 为你在官网看到的最新版的文件名字</p>
<p>如：<br>    distributionUrl=https\://services.gradle.org/distributions/gradle-3.2-rc-2-all.zip</p>
<p>现在就可以使用新版功能了，而且之后也看不到烦人的更新提示了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Plugin is too old, please update to a more recent version问题解决方法&lt;/p&gt;
&lt;p&gt;Android Studio 报错：&lt;/p&gt;
&lt;p&gt;Plugin is too old, please update to a m
    
    </summary>
    
      <category term="android" scheme="http://www.orzangleli.com/categories/android/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Python 实用技巧————博客文档备份及格式转化</title>
    <link href="http://www.orzangleli.com/2016/11/03/Python%E5%AE%9E%E6%88%98_%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>http://www.orzangleli.com/2016/11/03/Python实战_博客备份及格式转换/</id>
    <published>2016-11-02T16:00:00.000Z</published>
    <updated>2017-01-10T14:15:05.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要备份博客文章？"><a href="#1-为什么要备份博客文章？" class="headerlink" title="1. 为什么要备份博客文章？"></a>1. 为什么要备份博客文章？</h2><p>备份博客文章原因有很多，其中很重要的一点就是担心服务器数据丢失。我购买的是主机公园的香港主机，当时图便宜，也图方便（不需要备案），因此购买此主机，购买之后发现使用很是不方便：</p>
<ol>
<li><p>一方面速度很慢，打开主页都需要几秒钟，而且有时候我的浏览器已经有缓存了，打开还是很慢；</p>
</li>
<li><p>二是服务器时不时的挂掉，服务商还做过几次空间迁移。</p>
</li>
</ol>
<p>正因为这些原因，让用户体验很差，网友们通过搜索引擎搜索到之后，打开网站等待时间过长，一般来说就会直接关闭网页了。另一方面，空间中的文章也处于一种不安全的状态，随时可能找不到备份文件。</p>
<h2 id="2-为什么要放弃wordpress？"><a href="#2-为什么要放弃wordpress？" class="headerlink" title="2. 为什么要放弃wordpress？"></a>2. 为什么要放弃wordpress？</h2><p>之前建博客的重点是有一个可以保存自己文章的位置，可以随时记录，随时查阅，但是作为一个极简主义者，实在受不了wp的臃肿设计，而且使用几个插件之后网页巨卡无比，让人无法接受。</p>
<p>在知乎和google上搜索“个人编程博客框架”时，很多推荐了Hexo，这是一个基于Node.js的博客框架，非常好用，对于日常博客类网站十分适合。</p>
<h2 id="3-Hexo的安装和配置教程"><a href="#3-Hexo的安装和配置教程" class="headerlink" title="3.Hexo的安装和配置教程"></a>3.Hexo的安装和配置教程</h2><p>参见这位大神的教程： <a href="http://blog.niices.com/Hexo-Blog-Github-Page-Coding-Page-Domain/" target="_blank" rel="external">niices</a></p>
<h2 id="4-博客备份原理及步骤"><a href="#4-博客备份原理及步骤" class="headerlink" title="4.博客备份原理及步骤"></a>4.博客备份原理及步骤</h2><p>下面进入正题。</p>
<h3 id="4-1-博客备份原理"><a href="#4-1-博客备份原理" class="headerlink" title="4.1 博客备份原理"></a>4.1 博客备份原理</h3><p>首先需要知道wp站点有大量的css和js，是动态网站，无法使用urllib直接获取网站源码。<br>这里使用selenium 中的webdriver 配合phantomjs.exe ，这是一个真实的浏览器访问网站，所以不需要添加任何UA标识等。<br>在wp的首页，使用浏览器访问主页，按F12或者右键审查元素，查看文章标题的class.(不同的主题可能略微有些不同)</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-03_14:24:52_1.jpg?imageView2/0/w/800" alt=""></p>
<p>可以知道文章的标题由 <code>&lt;h2 class=&quot;entry-title&quot;&gt;</code> 包含，再使用selenium获取网页源码之后，使用BeautifulSoup可以定位到这个标签：</p>
<pre><code>titles =soup.findAll(class_=&quot;entry-title&quot;)
</code></pre><p>因为主页中有很多文章，所以有很多类似的标题，我们需要将所有的都获取到。</p>
<pre><code>for title in titles:
        address = title.find(&quot;a&quot;)[&quot;href&quot;]
        self.articles.add(address)
</code></pre><p><code>self.articles</code> 是一个set集合。用于保存所有文章的url,通过上面的代码可以将每篇文章中的代码保存到<code>self.articles</code>中    </p>
<p>这是获取主页的第一页的所有文章，还有第2页等。所以定义一个函数，根据页码获取文章地址：</p>
<pre><code>def getArticlesByPageIndex(self,pageIndex):
    self.browser.get(&quot;http://www.orzangleli.com/page/%d/&quot;%pageIndex)
    time.sleep(6)
    soup = BeautifulSoup(self.browser.page_source,&quot;html5lib&quot;)
    titles =soup.findAll(class_=&quot;entry-title&quot;)
    for title in titles:
        address = title.find(&quot;a&quot;)[&quot;href&quot;]
        self.articles.add(address)
        print(address)
</code></pre><p>通过一个for循环完成所有页面的文章url添加，之所以是<code>i+1</code>,是因为range(3)表示{0，1，2}：</p>
<pre><code>def getAllArticles(self):
        for i in range(self.pages):
            self.getArticlesByPageIndex(i+1)
</code></pre><p>这样，所有文章的url都存在<code>self.articles</code>中了，在浏览器中访问一个文章，观察文章的中信息，同样通过bs4可以获取文章的标题，发表时间，分类目录，hexo中的md文档还需要指明tag，这里我用分类代替，而分类使用之前分类的第一个分类代替，这些信息还要以特定格式保存在md中，下面代码负责返回一个md文档中head：</p>
<pre><code>def mdheader(self,title,date,tags,category):
        head = &quot;&quot;&quot;---
title: %s
date: %s
tags:
%scategories: %s
---&quot;&quot;&quot;%(title,date,tags,category)
        return head
</code></pre><p>获取到文章的正文内容后，使用html2text将html语言转为markdown语言。html2text的文档在：<a href="https://pypi.python.org/pypi/html2text/2016.9.19" target="_blank" rel="external">html2text</a>，将head和html2text转化的内容连接，组成完整的md文档。</p>
<p>入口函数为：</p>
<pre><code>def saveBlog(self):
        self.getAllArticles()
        for url in self.articles:
            self.save2md(url)
</code></pre><p>在最外层使用下面代码初始化类：<br>    browser = webdriver.PhantomJS(executable_path =”phantomjs.exe”)<br>    blog = Blog(browser,5)<br>    blog.saveBlog()</p>
<p>完整代码：</p>
<pre><code>import requests
from selenium import webdriver
import time
import html2text
from bs4 import BeautifulSoup


class Blog():
    def __init__(self,browser,pages):
        self.browser = browser
        self.pages = pages
        self.articles = set()

    def getArticlesByPageIndex(self,pageIndex):
        self.browser.get(&quot;http://www.orzangleli.com/page/%d/&quot;%pageIndex)
        time.sleep(6)
        soup = BeautifulSoup(self.browser.page_source,&quot;html5lib&quot;)
        #print(self.browser.page_source)
        titles =soup.findAll(class_=&quot;entry-title&quot;)
        for title in titles:
            address = title.find(&quot;a&quot;)[&quot;href&quot;]
            self.articles.add(address)
            print(address)

    def getAllArticles(self):
        for i in range(self.pages):
            self.getArticlesByPageIndex(i+1)

    def save2md(self,page_address):
        self.browser.get(page_address)
        time.sleep(6)
        #需要事先在wp后台关闭禁用掉代码高亮显示插件

        soup = BeautifulSoup(self.browser.page_source,&quot;html5lib&quot;)
        title = soup.find(class_=&quot;entry-title&quot;).text
        date = soup.find(class_=&quot;updated&quot;)[&quot;datetime&quot;].split(&quot;T&quot;)[0]
        content = soup.find(class_=&quot;entry-content&quot;)
        #获取标签
        categorys = soup.findAll(&quot;a&quot;,{&quot;rel&quot;:&quot;category tag&quot;})
        tags = &quot;&quot;
        for category in categorys:
            if category.text.startswith(&quot;未分类&quot;):
                break
            tags = &quot;%s- %s\n&quot;%(tags,category.text)

        head = self.mdheader(title,date,tags,categorys[0].text)        
        #print(content)

        mdcontent = html2text.html2text(str(content))
        #给md文档加上头
        mdcontent = &quot;%s\n%s&quot;%(head,mdcontent)
        #删除作者署名信息
        mdcontent = mdcontent.split(&quot;![](http://2.gravatar.com/avatar/e9a1c2c77d47ac4dcfeb1fa2fc1c936a?s=42&amp;d=mm&amp;r=g)&quot;)[0]

        with open(&quot;%s_%s.md&quot;%(date,title),&quot;w+&quot;,encoding=&quot;utf-8&quot;) as file:
            file.write(mdcontent)
            file.close()

    def saveBlog(self):
        self.getAllArticles()
        for url in self.articles:
            self.save2md(url)


    def mdheader(self,title,date,tags,category):
        head = &quot;&quot;&quot;---
title: %s
date: %s
tags:
%scategories: %s
---&quot;&quot;&quot;%(title,date,tags,category)
        return head


browser = webdriver.PhantomJS(executable_path =&quot;phantomjs.exe&quot;)
blog = Blog(browser,5)
blog.saveBlog()
</code></pre><p>附上，我将博客上所有文章保存下来的截图，幸福感满满~，待会可以使用hexo提交到hust201010701.github.io上：</p>
<p><img src="http://7xrrni.com1.z0.glb.clouddn.com/2016-11-03_15:10:25_3.jpg?imageView2/0/w/1000" alt=""></p>
<p>源码地址：<a href="https://github.com/hust201010701/WpBlogToMarkdownFile.git" target="_blank" rel="external">WpBlogToMarkdownFile.git</a></p>
<h2 id="5-为什么Python这么强大？"><a href="#5-为什么Python这么强大？" class="headerlink" title="5. 为什么Python这么强大？"></a>5. 为什么Python这么强大？</h2><p>从上面的完整代码就可以看出，python代码使用了77行，实现了整个需求，真的是：<strong>人生苦短，我用python.</strong> </p>
<p>Pyhton的强大的内置库和第三方库，让轮子不再重复制造，完成一个网页源码的数据获取只需要两三行代码，请问除了python还有谁？</p>
<p>学习代码这么长时间，之间一直使用C++,java,android,C#，没有哪种语言能够真真切切地解决生活中的麻烦事，直到遇到了python，庆幸~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-为什么要备份博客文章？&quot;&gt;&lt;a href=&quot;#1-为什么要备份博客文章？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要备份博客文章？&quot;&gt;&lt;/a&gt;1. 为什么要备份博客文章？&lt;/h2&gt;&lt;p&gt;备份博客文章原因有很多，其中很重要的一点就是担心
    
    </summary>
    
      <category term="Python" scheme="http://www.orzangleli.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.orzangleli.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Windows 平台下的整站抓取工具  WinHTTrack Website Copier 使用</title>
    <link href="http://www.orzangleli.com/2016/10/30/Windows%20%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E6%95%B4%E7%AB%99%E6%8A%93%E5%8F%96%E5%B7%A5%E5%85%B7%20%20WinHTTrack%20Website%20Copier%20%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.orzangleli.com/2016/10/30/Windows 平台下的整站抓取工具  WinHTTrack Website Copier 使用/</id>
    <published>2016-10-29T16:00:00.000Z</published>
    <updated>2016-11-03T11:19:55.162Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上本来想看android文档，使用之前好久没用的Lantern，发现已经不能打开墙外网站了，于是就想着android官方文档很重要，而且可能随时会看，就想着自己做一个镜像网站。</p>
<p>本来想的是使用Python爬虫，将developer.android.com上的所有guide网站目录下的网站爬取下来，然后在解析html内容，将所有的链接地址指向本地的相对地址，然后再下载html中的图片，flash,js,css等文件。</p>
<p>但是当我爬取下来一个首页的html之后，发现图片可能还比较好分辨，css感觉规则很不明显，会有这种css格式出现：</p>
<p>&lt;link rel=”stylesheet”<br>href=”//fonts.googleapis.com/css?family=Roboto+Condensed”&gt;</p>
<p>一时间，感觉做一个python版的整站爬取工作，需要处理的细节还是很多，而我明天可能要回无锡，所以时间并不多，就在搜索引擎上找到一款软件：WinHTTracker.</p>
<p>下载地址：<a href="http://www.httrack.com/page/2/" target="_blank" rel="external">http://www.httrack.com/page/2/</a> 网站做的挺简陋的。。。</p>
<p>下载下来安装即可，进入软件可以设置语言，我选择的简体中文。</p>
<p>首先需要设置工程名字，比如我的：AndroidOfficalDocument,下面的那个叫做工程目录可以不填，总文件保存位置选择一个空间较大的目录(因为不知道待爬取的网站的源码有多少空间，所以大点总比小的好)。</p>
<p>然后就是等待镜像过程了~</p>
<p><img src="http://lxctest.qiniudn.com/2016-10-30_11:41:10_QQ截图20161030114047.jpg?imageView2/0/w/900" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天晚上本来想看android文档，使用之前好久没用的Lantern，发现已经不能打开墙外网站了，于是就想着android官方文档很重要，而且可能随时会看，就想着自己做一个镜像网站。&lt;/p&gt;
&lt;p&gt;本来想的是使用Python爬虫，将developer.android.com
    
    </summary>
    
      <category term="未分类" scheme="http://www.orzangleli.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
</feed>
