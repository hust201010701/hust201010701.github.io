<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>orzangleli</title>
  <subtitle>活在梦里的程序员和设计师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.orzangleli.com/"/>
  <updated>2017-04-03T14:24:38.583Z</updated>
  <id>http://www.orzangleli.com/</id>
  
  <author>
    <name>orzangleli</name>
    <email>orzangleli@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 用 Retrofit 2 实现多文件上传实战</title>
    <link href="http://www.orzangleli.com/2017/04/03/2017-04-03_Android%20%E7%94%A8%20Retrofit%202%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AE%9E%E6%88%98/"/>
    <id>http://www.orzangleli.com/2017/04/03/2017-04-03_Android 用 Retrofit 2 实现多文件上传实战/</id>
    <published>2017-04-02T16:00:00.000Z</published>
    <updated>2017-04-03T14:24:38.583Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间我翻译了Future Studio的Retrofit2教程，从中也学习到了一些Retrofit2的使用方法，如果你最近也打算入手学习，我博客上Retrofit教程，你也许可以参考下：<a href="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/">Retrofit教程</a> 。</p>
<p>本文作为阶段性小结，将使用结合Python中的Flask框架实现Android端多文件上传功能。如果读者没有使用过Python中的Flask也没有关系，可以只看Android客户端部分，毕竟客户端工程师只使用API也是可以的。</p>
<h2 id="1-实验效果"><a href="#1-实验效果" class="headerlink" title="1. 实验效果"></a>1. 实验效果</h2><ul>
<li><p>Android端操作截图<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-04-03_22_22_26_GIF.gif" alt=""></p>
</li>
<li><p>Server端接收到的图片<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-04-03_22_22_26_server_cap.jpg" alt=""></p>
</li>
</ul>
<h2 id="2-Server端实战"><a href="#2-Server端实战" class="headerlink" title="2. Server端实战"></a>2. Server端实战</h2><p>Server端负责接收保存客户端上传来的图片并提供访问图片的能力，Server有很多技术可以实现，Python作为一门具有强大的第三方库的语言，拥有很多web服务框架，如Flask,Django等。笔者采用Flask框架，Flask是微框架，实现小型功能十分方便，笔者实现的多文件上传功能，程序不超过30行。</p>
<p>下面具体来看看。</p>
<h3 id="2-1-环境安装"><a href="#2-1-环境安装" class="headerlink" title="2.1 环境安装"></a>2.1 环境安装</h3><p>笔者使用的Python版本为3.4，可以去 <a href="https://www.python.org/downloads/release/python-340/" target="_blank" rel="external">Python3.4下载</a> 选择下载适合自己系统的版本。完整安装Python教程请自行搜索。</p>
<p>Python安装完成后需要安装Server端程序依赖库。通过pip安装：</p>
<pre><code>pip install Flask
pip install werkzeug
</code></pre><h3 id="2-2-程序实现"><a href="#2-2-程序实现" class="headerlink" title="2.2 程序实现"></a>2.2 程序实现</h3><p>首先要引入依赖库：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request,send_from_directory,jsonify</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">from</span> werkzeug <span class="keyword">import</span> secure_filename</div></pre></td></tr></table></figure>
<p>本实验需要上传文件，需要将所上传文件的文件类型以及文件名做出限制，防止某些破坏服务器的程序运行，另外有些非法文件名如：<br><code>filename = &quot;../../../../home/username/.bashrc&quot;</code><br>如果黑客们能够操作这样的文件，对服务器系统来说，将是致命打击。所以<code>werkzeug</code>提供了<code>secure_filename</code>对上传文件的文件名进行合法校验。</p>
<p>判断文件后缀是否合法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ALLOWED_EXTENSIONS=set([<span class="string">'png'</span>,<span class="string">'jpg'</span>,<span class="string">'jpeg'</span>,<span class="string">'gif'</span>])</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">allowed_file</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'.'</span> <span class="keyword">in</span> filename <span class="keyword">and</span> filename.rsplit(<span class="string">'.'</span>,<span class="number">1</span>)[<span class="number">1</span>] <span class="keyword">in</span> ALLOWED_EXTENSIONS</div></pre></td></tr></table></figure></p>
<p>接收上传文件的函数代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@app.route('/upload',methods=['POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">if</span> request.method==<span class="string">'POST'</span>:</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> request.files:</div><div class="line">            file = request.files[k]</div><div class="line">            image_urls = []</div><div class="line">            <span class="keyword">if</span> file <span class="keyword">and</span> allowed_file(file.filename):</div><div class="line">                filename=secure_filename(file.filename)</div><div class="line">                file.save(os.path.join(app.config[<span class="string">'IMAGE_FOLDER'</span>],filename))</div><div class="line">                image_urls.append(<span class="string">"images/%s"</span>%filename)</div><div class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">"code"</span>:<span class="number">1</span>,<span class="string">"image_urls"</span>:image_urls&#125;)</div></pre></td></tr></table></figure></p>
<p>Flask支持GET,POST,PUT,DELETE等HTTP请求方式，使用装饰器进行修饰，类似于Java中的注解概念，<code>/upload</code>为客户端请求的相对地址，请求方式限制为<code>POST</code>.根据request内置对象，可以访问客户端发来的文件，将文件检查后保存在本地，其中<code>image_urls</code>为上传后的图片的相对地址数组。最后将图片的地址以json格式返回给客户端。</p>
<p>完整的Server端代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request,send_from_directory,jsonify</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">from</span> werkzeug <span class="keyword">import</span> secure_filename</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">app.config[<span class="string">'IMAGE_FOLDER'</span>] = os.path.abspath(<span class="string">'.'</span>)+<span class="string">'\\images\\'</span></div><div class="line">ALLOWED_EXTENSIONS=set([<span class="string">'png'</span>,<span class="string">'jpg'</span>,<span class="string">'jpeg'</span>,<span class="string">'gif'</span>])</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">allowed_file</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'.'</span> <span class="keyword">in</span> filename <span class="keyword">and</span> filename.rsplit(<span class="string">'.'</span>,<span class="number">1</span>)[<span class="number">1</span>] <span class="keyword">in</span> ALLOWED_EXTENSIONS</div><div class="line"></div><div class="line"><span class="meta">@app.route('/upload',methods=['POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">if</span> request.method==<span class="string">'POST'</span>:</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> request.files:</div><div class="line">            file = request.files[k]</div><div class="line">            print(file)</div><div class="line">            image_urls = []</div><div class="line">            <span class="keyword">if</span> file <span class="keyword">and</span> allowed_file(file.filename):</div><div class="line">                filename=secure_filename(file.filename)</div><div class="line">                file.save(os.path.join(app.config[<span class="string">'IMAGE_FOLDER'</span>],filename))</div><div class="line">                image_urls.append(<span class="string">"images/%s"</span>%filename)</div><div class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">"code"</span>:<span class="number">1</span>,<span class="string">"image_urls"</span>:image_urls&#125;)</div><div class="line"></div><div class="line"><span class="comment">#让文件映射访问，否则默认只能访问static文件夹中的文件</span></div><div class="line"><span class="meta">@app.route("/images/&lt;imgname&gt;",methods=['GET'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">images</span><span class="params">(imgname)</span>:</span></div><div class="line">    <span class="keyword">return</span> send_from_directory(app.config[<span class="string">'IMAGE_FOLDER'</span>],imgname)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># 检测 IMAGE_FOLDER 是否存在</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(app.config[<span class="string">'IMAGE_FOLDER'</span>]):</div><div class="line">        os.mkdir(app.config[<span class="string">'IMAGE_FOLDER'</span>])</div><div class="line">    app.run(<span class="string">"192.168.1.102"</span>,debug=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>这里有一个小技巧，写完Server端代码后可以使用Postman进行测试，测试成功后再进行客户端程序开发。<br><img src="https://dn-mhke0kuv.qbox.me/2e7473ae221f7cdb796b.jpg" alt=""></p>
<h2 id="3-客户端开发"><a href="#3-客户端开发" class="headerlink" title="3. 客户端开发"></a>3. 客户端开发</h2><p>因为涉及文件的上传，笔者这里以图片为例进行上传实验，图片上传除了重头戏Retrofit之外，还需要选择图片，笔者这里推荐一个模仿微信的图片选择库 <a href="https://github.com/jeasonlzy/ImagePicker" target="_blank" rel="external">ImagePicker</a> .</p>
<h3 id="3-1-添加依赖库"><a href="#3-1-添加依赖库" class="headerlink" title="3.1 添加依赖库"></a>3.1 添加依赖库</h3><p>图片加载库笔者喜欢使用Glide</p>
<pre><code>compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos;
compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos;
compile &apos;com.github.bumptech.glide:glide:3.7.0&apos;
compile &apos;com.lzy.widget:imagepicker:0.4.1&apos;
</code></pre><h3 id="3-2-程序实现"><a href="#3-2-程序实现" class="headerlink" title="3.2 程序实现"></a>3.2 程序实现</h3><p>如果没有接触过Retrofit 2，可以来我的博客<a href="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/">Retrofit教程</a> 了解。</p>
<p>Retrofit2 是一个支持RESTful API的请求库，实际上只是对API请求方式的封装，真正的网络请求由OkHttp发出。</p>
<p>Retrofit2一般会定义一个ServiceGenerator类，用于动态生成Retrofit对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceGenerator</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_BASE_URL = <span class="string">"http://192.168.1.102:5000/"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient.Builder httpClient = <span class="keyword">new</span> OkHttpClient.Builder();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Retrofit.Builder builder =</div><div class="line">            <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">                    .baseUrl(API_BASE_URL)</div><div class="line">                    .addConverterFactory(GsonConverterFactory.create());</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">S <span class="title">createService</span><span class="params">(Class&lt;S&gt; serviceClass)</span> </span>&#123;</div><div class="line">        Retrofit retrofit = builder.client(httpClient.build()).build();</div><div class="line">        <span class="keyword">return</span> retrofit.create(serviceClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的API操作由FlaskClient接口操作，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlaskClient</span> </span>&#123;</div><div class="line">    <span class="comment">//上传图片</span></div><div class="line">    <span class="meta">@Multipart</span></div><div class="line">    <span class="meta">@POST</span>(<span class="string">"/upload"</span>)</div><div class="line">    <span class="function">Call&lt;UploadResult&gt; <span class="title">uploadMultipleFiles</span><span class="params">(</span></span></div><div class="line">            @PartMap Map&lt;String,RequestBody&gt; files);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上传文件需要使用<code>@Multipart</code>关键字注解，<code>@POST</code>表明HTTP请求方式为POST,<code>/upload</code>为请求服务器的相对地址，<code>uploadMultipleFiles</code>是自定义的方法名，参数为<code>Map&lt;String,RequestBody&gt; files</code>即多个文件组成的Map对象，<code>@PartMap</code>表明这是多文件上传，如果单文件可以使用<code>@Part MultipartBody.Part file</code>,方法的返回类型默认为<code>Response</code>,由于我们已经开发了Server端，所以知道Server端的返回数据格式为Json，因此我们针对返回数据格式新建一个UploadResut类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadResult</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> code;    <span class="comment">// 1</span></div><div class="line">    <span class="keyword">public</span> List&lt;String&gt; image_urls;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>界面布局如图所示：<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-04-03_18_44_55_layout.jpg" alt=""></p>
<p>点击Upload按钮后执行上传操作，核心的方法：</p>
<pre><code>public void uploadFiles() {
    if(imagesList.size() == 0) {
        Toast.makeText(MainActivity.this, &quot;不能不选择图片&quot;, Toast.LENGTH_SHORT).show();
        return;
    }
    Map&lt;String, RequestBody&gt; files = new HashMap&lt;&gt;();
    final FlaskClient service = ServiceGenerator.createService(FlaskClient.class);
    for (int i = 0; i &lt; imagesList.size(); i++) {
        File file = new File(imagesList.get(i).path);
        files.put(&quot;file&quot; + i + &quot;\&quot;; filename=\&quot;&quot; + file.getName(), RequestBody.create(MediaType.parse(imagesList.get(i).mimeType), file));
    }
    Call&lt;UploadResult&gt; call = service.uploadMultipleFiles(files);
    call.enqueue(new Callback&lt;UploadResult&gt;() {
        @Override
        public void onResponse(Call&lt;UploadResult&gt; call, Response&lt;UploadResult&gt; response) {
            if (response.isSuccessful() &amp;&amp; response.body().code == 1) {
                Toast.makeText(MainActivity.this, &quot;上传成功&quot;, Toast.LENGTH_SHORT).show();
                Log.i(&quot;orzangleli&quot;, &quot;---------------------上传成功-----------------------&quot;);
                Log.i(&quot;orzangleli&quot;, &quot;基础地址为：&quot; + ServiceGenerator.API_BASE_URL);
                Log.i(&quot;orzangleli&quot;, &quot;图片相对地址为：&quot; + listToString(response.body().image_urls,&apos;,&apos;));
                Log.i(&quot;orzangleli&quot;, &quot;---------------------END-----------------------&quot;);
            }
        }
        @Override
        public void onFailure(Call&lt;UploadResult&gt; call, Throwable t) {
            Toast.makeText(MainActivity.this, &quot;上传失败&quot;, Toast.LENGTH_SHORT).show();
        }
    });
}
</code></pre><p>其中构建上传多文件的方法的参数较为关键，<code>MediaType.parse(imagesList.get(i).mimeType)</code>获取图片的mimeType，如果指定错误，可能会导致上传失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, RequestBody&gt; files = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="keyword">final</span> FlaskClient service = ServiceGenerator.createService(FlaskClient.class);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imagesList.size(); i++) &#123;</div><div class="line">    File file = <span class="keyword">new</span> File(imagesList.get(i).path);</div><div class="line">    files.put(<span class="string">"file"</span> + i + <span class="string">"\"; filename=\""</span> + file.getName(), RequestBody.create(MediaType.parse(imagesList.get(i).mimeType), file));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>集成<code>Callback</code>借口的匿名回调类的<code>onResponse</code>方法的第二个参数为服务器响应，通过访问<code>body()</code>方法返回<code>UploadResult</code>类型对象，接着就可以通过组合<code>ServiceGenerator.API_BASE_URL</code>和<code>response.body().image_urls</code>中每一项访问上传完成的图片。</p>
<h2 id="4-项目地址"><a href="#4-项目地址" class="headerlink" title="4. 项目地址"></a>4. 项目地址</h2><p>本项目Client端和Server端均以开源，欢迎各位老总们Star。<br>Client地址: <a href="https://github.com/hust201010701/RetrofitMultiFilesUploadClient/" target="_blank" rel="external">RetrofitMultiFilesUploadClient</a><br>Server地址: <a href="https://github.com/hust201010701/MultiFileUploadServer/" target="_blank" rel="external">MultiFileUploadServer</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间我翻译了Future Studio的Retrofit2教程，从中也学习到了一些Retrofit2的使用方法，如果你最近也打算入手学习，我博客上Retrofit教程，你也许可以参考下：&lt;a href=&quot;http://www.orzangleli.com/catego
    
    </summary>
    
      <category term="Android" scheme="http://www.orzangleli.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第十四篇 Retrofit2——如何上传多个文件到服务器</title>
    <link href="http://www.orzangleli.com/2017/02/22/2017-02-22_%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AF%87%20Retrofit2%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.orzangleli.com/2017/02/22/2017-02-22_第十四篇 Retrofit2——如何上传多个文件到服务器/</id>
    <published>2017-02-21T16:00:00.000Z</published>
    <updated>2017-02-23T00:40:25.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四篇-Retrofit2——如何上传多个文件到服务器"><a href="#第十四篇-Retrofit2——如何上传多个文件到服务器" class="headerlink" title="第十四篇 Retrofit2——如何上传多个文件到服务器"></a>第十四篇 Retrofit2——如何上传多个文件到服务器</h1><h2 id="一、用Retrofit-2上传多个文件"><a href="#一、用Retrofit-2上传多个文件" class="headerlink" title="一、用Retrofit 2上传多个文件"></a>一、用Retrofit 2上传多个文件</h2><p>在开始多文件上传的细节之前，请确保你已经理解了《如何上传文件到服务器》中的所有原理，这样，多文件上传的方式将是十分相似。</p>
<p>首先，我们得为多文件上传扩展<code>FileUploadService</code>接口。</p>
<pre><code>public interface FileUploadService {  
    // previous code for single file uploads
    @Multipart
    @POST(&quot;upload&quot;)
    Call&lt;ResponseBody&gt; uploadFile(
            @Part(&quot;description&quot;) RequestBody description,
            @Part MultipartBody.Part file);

    // new code for multiple files
    @Multipart
    @POST(&quot;upload&quot;)
    Call&lt;ResponseBody&gt; uploadMultipleFiles(
            @Part(&quot;description&quot;) RequestBody description,
            @Part MultipartBody.Part file1,
            @Part MultipartBody.Part file2);
}
</code></pre><p>对比上面接口中的<code>uploadFile()</code>方法和<code>uploadMultipleFiles()</code>方法，你可以很明显的发现区别。Retrofit 2中添加新的文件十分简单。在接口定义的方面，我们仅仅需要添加一个新的参数<code>@Part MultipartBody.Part file2</code>。<code>uploadMultipleFiles()</code>现在就只能支持两个文件了。你可以自己调整<code>MultipartBody.Part</code>的数量。后面的教程，我们会看看如何添加动态的数量的文件到你的请求中。</p>
<p>接口声明结束，已经完成了一半的工作。另一半就是在Activity或Fragment中实现了。因为我们现在在进行多文件上传，所以我们实现两个帮助方法，让代码更健壮：</p>
<pre><code>public static final String MULTIPART_FORM_DATA = &quot;multipart/form-data&quot;;

@NonNull
private RequestBody createPartFromString(String descriptionString) {  
    return RequestBody.create(
            MediaType.parse(MULTIPART_FORM_DATA), descriptionString);
}

@NonNull
private MultipartBody.Part prepareFilePart(String partName, Uri fileUri) {  
    // https://github.com/iPaulPro/aFileChooser/blob/master/aFileChooser/src/com/ipaulpro/afilechooser/utils/FileUtils.java
    // use the FileUtils to get the actual file by uri
    File file = FileUtils.getFile(this, fileUri);

    // create RequestBody instance from file
    RequestBody requestFile =
        RequestBody.create(MediaType.parse(MULTIPART_FORM_DATA), file);

    // MultipartBody.Part is used to send also the actual file name
    return MultipartBody.Part.createFormData(partName, file.getName(), requestFile);
}
</code></pre><p><code>createPartFromString()</code>方法在文件上传时发送描述。<code>prepareFilePart()</code>方法创建了一个<code>MultipartBody.Part</code>对象，可以包含一个文件。在Retrofit 2中上传文件都需要包裹在<code>MultipartBody.Part</code>中。</p>
<p>下面使用这两个帮助方法来发送两个文件：</p>
<pre><code>Uri file1Uri = ... // get it from a file chooser or a camera intent  
Uri file2Uri = ... // get it from a file chooser or a camera intent

// create upload service client
FileUploadService service =  
        ServiceGenerator.createService(FileUploadService.class);

// create part for file (photo, video, ...)
MultipartBody.Part body1 = prepareFilePart(&quot;video&quot;, file1Uri);  
MultipartBody.Part body2 = prepareFilePart(&quot;thumbnail&quot;, file2Uri);

// add another part within the multipart request
RequestBody description = createPartFromString(&quot;hello, this is description speaking&quot;);

// finally, execute the request
Call&lt;ResponseBody&gt; call = service.uploadMultipleFiles(description, body1, body2);  
call.enqueue(new Callback&lt;ResponseBody&gt;() {  
    @Override
    public void onResponse(Call&lt;ResponseBody&gt; call,
            Response&lt;ResponseBody&gt; response) {
        Log.v(&quot;Upload&quot;, &quot;success&quot;);
    }

    @Override
    public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) {
        Log.e(&quot;Upload error:&quot;, t.getMessage());
    }
});
</code></pre><p>现在你要做的就是在一个请求中发送两个文件，当然你也可以再添加一个或者多个文件到接口中，用这种方式，你可以想发送多少文件都可以。</p>
<h2 id="二、用图床实战"><a href="#二、用图床实战" class="headerlink" title="二、用图床实战"></a>二、用图床实战</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十四篇-Retrofit2——如何上传多个文件到服务器&quot;&gt;&lt;a href=&quot;#第十四篇-Retrofit2——如何上传多个文件到服务器&quot; class=&quot;headerlink&quot; title=&quot;第十四篇 Retrofit2——如何上传多个文件到服务器&quot;&gt;&lt;/a&gt;第十
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第十三篇 Retrofit—如何上传文件到服务器</title>
    <link href="http://www.orzangleli.com/2017/02/17/2017-02-17_%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%20Retrofit%E2%80%94%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.orzangleli.com/2017/02/17/2017-02-17_第十三篇 Retrofit—如何上传文件到服务器/</id>
    <published>2017-02-16T16:00:00.000Z</published>
    <updated>2017-02-17T01:33:00.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十三篇-Retrofit2——如何上传文件到服务器"><a href="#第十三篇-Retrofit2——如何上传文件到服务器" class="headerlink" title="第十三篇 Retrofit2——如何上传文件到服务器"></a>第十三篇 Retrofit2——如何上传文件到服务器</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#一、用retrofit-2上传文件">一、用Retrofit 2上传文件</a></li>
<li><a href="#二、android-客户端代码">二、Android 客户端代码</a></li>
<li><a href="#三、记住content-type">三、记住Content-Type</a></li>
<li><a href="#四、示例hapi文件上传服务器">四、示例Hapi文件上传服务器</a></li>
<li><a href="#五、文件上传实战">五、文件上传实战</a></li>
</ul>
<!-- /MarkdownTOC -->
<h2 id="一、用Retrofit-2上传文件"><a href="#一、用Retrofit-2上传文件" class="headerlink" title="一、用Retrofit 2上传文件"></a>一、用Retrofit 2上传文件</h2><p>Retrofit 2在处理文件上传的方式上与Retrofit v1有很大不同。在我们深入学习Retrofit 2中的文件上传的相关内容之前，简单回顾Retrofit v1中的使用的<code>TypedFile</code>类来上传文件。在Retrofit 2中这个类已经被移除了。而且Retrofit 2把OkHttp作为网络层，因此使用OkHttp的类来实现文件上传。</p>
<p>在Retrofit 2中，你需要使用OkHttp的<code>RequestBody</code>或<code>MultipartBody.Part</code>类，把你的文件封装到请求体中。下面来看看文件上传接口的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileUploadService</span> </span>&#123;  </div><div class="line">    <span class="meta">@Multipart</span></div><div class="line">    <span class="meta">@POST</span>(<span class="string">"upload"</span>)</div><div class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">upload</span><span class="params">(@Part(<span class="string">"description"</span>)</span> RequestBody description,</span></div><div class="line">                              @Part MultipartBody.Part file);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们逐个分析上面的定义，先从<code>description</code>开始。<code>description</code>就是一个包裹在<code>RequestBody</code>实例中的字符串的值。然后，请求中的<code>@Part</code>描述的是真实的<code>file</code>。我们使用<code>MultipartBody.Part</code>来允许我们除了发送二进制文件数据外还能发送真实的文件名。下面你将看到如何创建<code>file</code>对象。</p>
<h2 id="二、Android-客户端代码"><a href="#二、Android-客户端代码" class="headerlink" title="二、Android 客户端代码"></a>二、Android 客户端代码</h2><p>到现在，你使用Retrofit已经定义过必要的service接口了。现在你可以向文件上传上面探索了。我们使用<code>ServiceGenerator</code>类生成一个服务客户端。我们已经在本系列第一篇文章中介绍过了<code>ServiceGenerator</code>类。</p>
<p>下面的代码片段将展示把文件地址作为参数的<code>uploadFile(Uri fileUri)</code>方法。如果你用intent来选择文件，你可以在<code>onActivityResult()</code>方法中获得文件的地址，这个地址就是你要传递给<code>uploadFile(Uri fileUri)</code>方法的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">uploadFile</span><span class="params">(Uri fileUri)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 创建文件上传客户端</span></div><div class="line">    FileUploadService service =</div><div class="line">            ServiceGenerator.createService(FileUploadService.class);</div><div class="line"></div><div class="line">    <span class="comment">// https://github.com/iPaulPro/aFileChooser/blob/master/aFileChooser/src/com/ipaulpro/afilechooser/utils/FileUtils.java</span></div><div class="line">    <span class="comment">// use the FileUtils to get the actual file by uri</span></div><div class="line">    File file = FileUtils.getFile(<span class="keyword">this</span>, fileUri);</div><div class="line"></div><div class="line">    <span class="comment">// 根据文件创建请求体</span></div><div class="line">    RequestBody requestFile =</div><div class="line">            RequestBody.create(MediaType.parse(<span class="string">"multipart/form-data"</span>), file);</div><div class="line"></div><div class="line">    <span class="comment">// MultipartBody.Part 还可以上传文件名</span></div><div class="line">    MultipartBody.Part body =</div><div class="line">            MultipartBody.Part.createFormData(<span class="string">"picture"</span>, file.getName(), requestFile);</div><div class="line"></div><div class="line">    <span class="comment">// 在 multipart request中再添加一部分内容</span></div><div class="line">    String descriptionString = <span class="string">"hello, this is description speaking"</span>;</div><div class="line">    RequestBody description =</div><div class="line">            RequestBody.create(</div><div class="line">                    MediaType.parse(<span class="string">"multipart/form-data"</span>), descriptionString);</div><div class="line"></div><div class="line">    <span class="comment">// 最后执行请求</span></div><div class="line">    Call&lt;ResponseBody&gt; call = service.upload(description, body);</div><div class="line">    call.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;ResponseBody&gt; call,</span></span></div><div class="line">                               Response&lt;ResponseBody&gt; response) &#123;</div><div class="line">            Log.v(<span class="string">"Upload"</span>, <span class="string">"success"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call, Throwable t)</span> </span>&#123;</div><div class="line">            Log.e(<span class="string">"Upload error:"</span>, t.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码片段展示了如何初始化<code>body</code>和<code>description</code>,以及如何使用文件上传service.之前提到，<code>RequestBody</code>是OkHttp中的类。它的<code>.create()</code>方法需要两个参数：从<code>multipart/form-data</code>解析的媒体文件类型和真实的数据。</p>
<p>除了<code>description</code>，你还可以添加文件到<code>MultipartBody.Part</code>实例中。这个文件就是你从客户端上传文件时需要的文件。而且，你可以使用<code>createFormData()</code>把原始的文件名添加到请求中，服务器在后端接收后可以使用它。</p>
<h2 id="三、记住Content-Type"><a href="#三、记住Content-Type" class="headerlink" title="三、记住Content-Type"></a>三、记住Content-Type</h2><p>请注意Retrofit的<code>Content-Type</code>内容类型。如果你在OkHttp客户端中拦截请求，并把内容类型修改为<code>application/json</code>,你的服务器在反序列化过程可能出现问题。请确保你在请求头中没有声明你再发送JSON数据，而是在发送<code>multipart/form-data</code>.</p>
<h2 id="四、示例Hapi文件上传服务器"><a href="#四、示例Hapi文件上传服务器" class="headerlink" title="四、示例Hapi文件上传服务器"></a>四、示例Hapi文件上传服务器</h2><p>讲的是hapi服务器配合Retrofit使用，因为内容不涉及Android,有兴趣的自行查看：</p>
<p><a href="https://futurestud.io/tutorials/retrofit-2-how-to-upload-files-to-server#exemplaryhapiserverforfileuploads" target="_blank" rel="external">https://futurestud.io/tutorials/retrofit-2-how-to-upload-files-to-server#exemplaryhapiserverforfileuploads</a></p>
<h2 id="五、文件上传实战"><a href="#五、文件上传实战" class="headerlink" title="五、文件上传实战"></a>五、文件上传实战</h2><p>我们使用第三方文件上传API。为什么不使用Github的呢？我找了半天也没找到Github上传文件的API,如果各位找到，麻烦通知我一下。我们使用<a href="http://www.tietuku.com/" target="_blank" rel="external">http://www.tietuku.com/</a>这个图床，上传图片文件来试验文件上传功能，需要自行登录网站。</p>
<ol>
<li>注册登录网站，网站服务免费的。</li>
<li>进入<a href="http://www.tietuku.com/manager/createtoken" target="_blank" rel="external">http://www.tietuku.com/manager/createtoken</a>，选择目标相册，上传方式为本地上传，点击立即生成即可获得token.</li>
<li>进入<a href="http://www.tietuku.com/manager/album" target="_blank" rel="external">http://www.tietuku.com/manager/album</a>获得相册的ID.</li>
</ol>
<p>首先，我们要把<code>ServiceGenerator</code>中的基础API地址修改我们使用的图床的API地址：<a href="http://up.imgapi.com" target="_blank" rel="external">http://up.imgapi.com</a>。</p>
<p>然后，我们使用的客户端不再是之前一直使用的GithubClient了，我们新建一个接口<code>FileUploadService</code>。内容为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileUploadService</span> </span>&#123;</div><div class="line">    <span class="meta">@Multipart</span></div><div class="line">    <span class="meta">@POST</span>(<span class="string">"/"</span>)</div><div class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">upload</span><span class="params">(@Part(<span class="string">"Token"</span>)</span> RequestBody token,</span></div><div class="line">                              @Part MultipartBody.Part file,</div><div class="line">                              @<span class="title">Query</span><span class="params">(<span class="string">"deadline"</span>)</span> <span class="keyword">long</span> deadline,</div><div class="line">                              @<span class="title">Query</span><span class="params">(<span class="string">"aid"</span>)</span> <span class="keyword">int</span> aid,</div><div class="line">                              @<span class="title">Query</span><span class="params">(<span class="string">"from"</span>)</span> String from,</div><div class="line">                              @<span class="title">Query</span><span class="params">(<span class="string">"httptype"</span>)</span> <span class="keyword">int</span> httptype</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数均为<a href="http://www.tietuku.com/doc" target="_blank" rel="external">API文档</a>中规定的数据。</p>
<p>在MainActivity中调用文件上传接口时，如果是Android 6.0系统及其之上需要检查读写权限，所以代码比较长：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    List&lt;TaskService.Task&gt; tasks ;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TAG = <span class="string">"ILearnRetrofit"</span>;</div><div class="line">    TextView textView;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        Utils.init(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        textView = (TextView)<span class="keyword">this</span>.findViewById(R.id.textView);</div><div class="line"></div><div class="line">        initPermission();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPermission</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> permission = ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>, Manifest.permission.READ_EXTERNAL_STORAGE);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (permission != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">            <span class="comment">//需不需要解释的dialog</span></div><div class="line">            <span class="keyword">if</span> (shouldRequest()) <span class="keyword">return</span>;</div><div class="line">            <span class="comment">//请求权限</span></div><div class="line">            ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(isFileExists(Environment.getExternalStorageDirectory()+File.separator+<span class="string">"Download"</span>+File.separator+<span class="string">"qq2.png"</span>)) &#123;</div><div class="line">                ToastUtils.showLongToast(<span class="string">"存在"</span>);</div><div class="line">                uploadFile(Environment.getExternalStorageDirectory() + File.separator + <span class="string">"Download"</span> + File.separator + <span class="string">"qq2.png"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">shouldRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, Manifest.permission.READ_EXTERNAL_STORAGE)) &#123;</div><div class="line">            <span class="comment">//显示一个对话框，给用户解释</span></div><div class="line">            explainDialog();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">explainDialog</span><span class="params">()</span> </span>&#123;</div><div class="line">        AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>);</div><div class="line">        builder.setMessage(<span class="string">"应用需要获取您的文件权限,是否授权？"</span>)</div><div class="line">                .setPositiveButton(<span class="string">"确定"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</div><div class="line">                        <span class="comment">//请求权限</span></div><div class="line">                        ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, <span class="number">1</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;).setNegativeButton(<span class="string">"取消"</span>, <span class="keyword">null</span>)</div><div class="line">                .create().show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</div><div class="line">        <span class="keyword">if</span> (requestCode == <span class="number">1</span> &amp;&amp; grantResults.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">boolean</span> granted = grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED;<span class="comment">//是否授权，可以根据permission作为标记</span></div><div class="line">            <span class="keyword">if</span>(granted)&#123;</div><div class="line">                <span class="keyword">if</span>(isFileExists(Environment.getExternalStorageDirectory()+File.separator+<span class="string">"Download"</span>+File.separator+<span class="string">"qq2.png"</span>)) &#123;</div><div class="line">                    ToastUtils.showLongToast(<span class="string">"存在"</span>);</div><div class="line">                    uploadFile(Environment.getExternalStorageDirectory() + File.separator + <span class="string">"Download"</span> + File.separator + <span class="string">"qq2.png"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadFile</span><span class="params">(String fileUri)</span></span>&#123;</div><div class="line"></div><div class="line">        FileUploadService service = ServiceGenerator.createService(FileUploadService.class);</div><div class="line">        File file = FileUtils.getFileByPath(fileUri);</div><div class="line"></div><div class="line">        RequestBody requestFile = RequestBody.create(MediaType.parse(<span class="string">"image/png"</span>),file);</div><div class="line"></div><div class="line">        MultipartBody.Part body = MultipartBody.Part.createFormData(<span class="string">"file"</span>,file.getName(),requestFile);</div><div class="line"></div><div class="line">        String tokenString = <span class="string">"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</span>;</div><div class="line">        RequestBody token = RequestBody.create(MediaType.parse(<span class="string">"multipart-data"</span>),tokenString);</div><div class="line"></div><div class="line">        Call&lt;ResponseBody&gt; call = service.upload(token,</div><div class="line">                body,<span class="number">1420041660</span>,xxxxxx,<span class="string">"file"</span>,<span class="number">2</span></div><div class="line">                );</div><div class="line">        call.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)</span> </span>&#123;</div><div class="line">                d(TAG,<span class="string">"success:"</span>+response.raw());</div><div class="line">                textView.setText(<span class="string">"success:"</span>+response);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call, Throwable t)</span> </span>&#123;</div><div class="line">                d(TAG,<span class="string">"fail:"</span>+t.getMessage());</div><div class="line">                textView.setText(<span class="string">"fail:"</span>+t.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们在后台检查下是否上传成功了。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-18_17_15_52_upload_file.png" alt=""></p>
<p>的确，可以看到上传的文件了，证明上传成功了。</p>
<blockquote>
<p>本篇教程所有源码参见此网页：[留白]</p>
</blockquote>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十三篇-Retrofit2——如何上传文件到服务器&quot;&gt;&lt;a href=&quot;#第十三篇-Retrofit2——如何上传文件到服务器&quot; class=&quot;headerlink&quot; title=&quot;第十三篇 Retrofit2——如何上传文件到服务器&quot;&gt;&lt;/a&gt;第十三篇 Ret
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>ViewPager+Fragment+TabLayout爬坑</title>
    <link href="http://www.orzangleli.com/2017/02/17/2017-02-17_ViewPager+Fragment+TabLayout%E7%88%AC%E5%9D%91/"/>
    <id>http://www.orzangleli.com/2017/02/17/2017-02-17_ViewPager+Fragment+TabLayout爬坑/</id>
    <published>2017-02-16T16:00:00.000Z</published>
    <updated>2017-02-17T14:17:46.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ViewPager-Fragment-TabLayout爬坑"><a href="#ViewPager-Fragment-TabLayout爬坑" class="headerlink" title="ViewPager+Fragment+TabLayout爬坑"></a>ViewPager+Fragment+TabLayout爬坑</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#1-在xml布局中定义viewpager和tablayout">1. 在xml布局中定义ViewPager和TabLayout</a></li>
<li><a href="#2-禁止重复添加相同的fragment到viewpager中">2. 禁止重复添加相同的Fragment到Viewpager中</a></li>
<li><a href="#3-setupwithviewpager后tab不显示">3. setupWithViewPager后Tab不显示</a><ul>
<li><a href="#31-那么怎么来让tab显示文字和图标呢？">3.1 那么怎么来让Tab显示文字和图标呢？</a></li>
</ul>
</li>
<li><a href="#4-完整的java-代码">4. 完整的java 代码</a></li>
</ul>
<!-- /MarkdownTOC -->
<h2 id="1-在xml布局中定义ViewPager和TabLayout"><a href="#1-在xml布局中定义ViewPager和TabLayout" class="headerlink" title="1. 在xml布局中定义ViewPager和TabLayout"></a>1. 在xml布局中定义ViewPager和TabLayout</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/activity_main"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.orzangleli.xiaoxiannv.MainActivity"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/viewPager"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></div><div class="line">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></div><div class="line">            &gt;<span class="tag">&lt;/<span class="name">android.support.v4.view.ViewPager</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">android.support.design.widget.TabLayout</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/tabLayout"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"60dp"</span></div><div class="line">            <span class="attr">android:background</span>=<span class="string">"@color/titleBlue"</span></div><div class="line">            <span class="attr">app:tabIndicatorColor</span>=<span class="string">"@color/white"</span></div><div class="line">            <span class="attr">app:tabIndicatorHeight</span>=<span class="string">"2dp"</span></div><div class="line">            <span class="attr">app:tabMode</span>=<span class="string">"fixed"</span></div><div class="line">            <span class="attr">app:tabSelectedTextColor</span>=<span class="string">"@color/white"</span></div><div class="line">            <span class="attr">app:tabTextColor</span>=<span class="string">"@color/gray"</span> /&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="2-禁止重复添加相同的Fragment到Viewpager中"><a href="#2-禁止重复添加相同的Fragment到Viewpager中" class="headerlink" title="2. 禁止重复添加相同的Fragment到Viewpager中"></a>2. 禁止重复添加相同的Fragment到Viewpager中</h2><p>当时，我的tab有三个，但是另外两个Fragment还没有写好，就偷懒把FragmentPagerAdapter中数组重复添加了第一个fragment三次，结果就出错了：</p>
<p><code>Can&#39;t change tag of fragment SubscribedFragment{41157420 id=0x7f070005 android:switcher:2131165189:0}: was android:switcher:2131165189:0 now android:switcher:2131165189:1</code></p>
<p><strong> 解决方法 </strong></p>
<p>新建另外的两个Fragment，与FragmentPagerAdapter绑定。</p>
<h2 id="3-setupWithViewPager后Tab不显示"><a href="#3-setupWithViewPager后Tab不显示" class="headerlink" title="3. setupWithViewPager后Tab不显示"></a>3. setupWithViewPager后Tab不显示</h2><p>查看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">populateFromPagerAdapter</span><span class="params">()</span> </span>&#123;</div><div class="line">        removeAllTabs();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mPagerAdapter != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> adapterCount = mPagerAdapter.getCount();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adapterCount; i++) &#123;</div><div class="line">                addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), <span class="keyword">false</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Make sure we reflect the currently set ViewPager item</span></div><div class="line">            <span class="keyword">if</span> (mViewPager != <span class="keyword">null</span> &amp;&amp; adapterCount &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> curItem = mViewPager.getCurrentItem();</div><div class="line">                <span class="keyword">if</span> (curItem != getSelectedTabPosition() &amp;&amp; curItem &lt; getTabCount()) &#123;</div><div class="line">                    selectTab(getTabAt(curItem));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意<code>addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false);</code>,看到没，在setupWithViewPager后，会自动添加三个Tab,Tab上的文字是FragmentPagerAdapter中的PageTitle。</p>
<p>所以，我们不能自己给TabLayout添加tab，因为你只要绑定ViewPager,它会自动再添加一次。</p>
<h3 id="3-1-那么怎么来让Tab显示文字和图标呢？"><a href="#3-1-那么怎么来让Tab显示文字和图标呢？" class="headerlink" title="3.1 那么怎么来让Tab显示文字和图标呢？"></a>3.1 那么怎么来让Tab显示文字和图标呢？</h3><ul>
<li>只显示文字</li>
</ul>
<p>如果只显示文字可以直接在定义FragmentPagerAdapter时，添加一个方法就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">pageAdapter = <span class="keyword">new</span> FragmentPagerAdapter(<span class="keyword">this</span>.getSupportFragmentManager()) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> fragmentList.get(position);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> fragmentList.size();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> CharSequence <span class="title">getPageTitle</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> mTitles[position];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>显示文字和图标</li>
</ul>
<p>因为<code>FragmentPagerAdapter</code>中无法指定图标，所以，我们可以在执行完<code>setupWithViewPager</code>后，给已经添加上的tab重新设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tabLayout.setupWithViewPager(viewPager);</div><div class="line">tabLayout.getTabAt(<span class="number">0</span>).setText(mTitles[<span class="number">0</span>]).setIcon(R.drawable.home_xml);</div><div class="line">tabLayout.getTabAt(<span class="number">1</span>).setText(mTitles[<span class="number">1</span>]).setIcon(R.drawable.rank_xml);</div><div class="line">tabLayout.getTabAt(<span class="number">2</span>).setText(mTitles[<span class="number">2</span>]).setIcon(R.drawable.category_xml);</div></pre></td></tr></table></figure>
<p><strong> 注意 </strong></p>
<p>可以看到<code>setIcon</code>的参数为xml，这样就可以实现点击后图标变色了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/home2"</span> <span class="attr">android:state_selected</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/home"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>只显示图标</li>
</ul>
<p>这就很简单了,去掉<code>setText</code>就可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tabLayout.setupWithViewPager(viewPager);</div><div class="line">tabLayout.getTabAt(<span class="number">0</span>).setIcon(R.drawable.home_xml);</div><div class="line">tabLayout.getTabAt(<span class="number">1</span>).setIcon(R.drawable.rank_xml);</div><div class="line">tabLayout.getTabAt(<span class="number">2</span>).setIcon(R.drawable.category_xml);</div></pre></td></tr></table></figure>
<h2 id="4-完整的java-代码"><a href="#4-完整的java-代码" class="headerlink" title="4. 完整的java 代码"></a>4. 完整的java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String[] mTitles = <span class="keyword">new</span> String[]&#123;<span class="string">"首页"</span>, <span class="string">"排行"</span>,<span class="string">"分类"</span>&#125;;</div><div class="line">    TabLayout tabLayout;</div><div class="line">    ViewPager viewPager;</div><div class="line">    List&lt;Fragment&gt; fragmentList;</div><div class="line">    FragmentPagerAdapter pageAdapter;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        tabLayout = (TabLayout)<span class="keyword">this</span>.findViewById(R.id.tabLayout);</div><div class="line"></div><div class="line">        viewPager = (ViewPager)<span class="keyword">this</span>.findViewById(R.id.viewPager);</div><div class="line">        initFragment();</div><div class="line">        initAdapter();</div><div class="line"></div><div class="line">        tabLayout.setupWithViewPager(viewPager);</div><div class="line">        tabLayout.getTabAt(<span class="number">0</span>).setText(mTitles[<span class="number">0</span>]).setIcon(R.drawable.home_xml);</div><div class="line">        tabLayout.getTabAt(<span class="number">1</span>).setText(mTitles[<span class="number">1</span>]).setIcon(R.drawable.rank_xml);</div><div class="line">        tabLayout.getTabAt(<span class="number">2</span>).setText(mTitles[<span class="number">2</span>]).setIcon(R.drawable.category_xml);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAdapter</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        pageAdapter = <span class="keyword">new</span> FragmentPagerAdapter(<span class="keyword">this</span>.getSupportFragmentManager()) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> fragmentList.get(position);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> fragmentList.size();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> CharSequence <span class="title">getPageTitle</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> mTitles[position];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        viewPager.setAdapter(pageAdapter);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFragment</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        fragmentList = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</div><div class="line"></div><div class="line">        RecentPostsFragment recentPostsFragment = <span class="keyword">new</span> RecentPostsFragment();</div><div class="line">        RankFragment rankFragment = <span class="keyword">new</span> RankFragment();</div><div class="line">        CategoryFragment categoryFragment = <span class="keyword">new</span> CategoryFragment();</div><div class="line"></div><div class="line">        <span class="comment">//添加到数组中</span></div><div class="line">        fragmentList.add(recentPostsFragment);</div><div class="line">        fragmentList.add(rankFragment);</div><div class="line">        fragmentList.add(categoryFragment);</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Enjoy Coding! 如果在阅读本博客的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ViewPager-Fragment-TabLayout爬坑&quot;&gt;&lt;a href=&quot;#ViewPager-Fragment-TabLayout爬坑&quot; class=&quot;headerlink&quot; title=&quot;ViewPager+Fragment+TabLayout爬坑&quot;&gt;
    
    </summary>
    
      <category term="android" scheme="http://www.orzangleli.com/categories/android/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="TabLayout" scheme="http://www.orzangleli.com/tags/TabLayout/"/>
    
  </entry>
  
  <entry>
    <title>第十二篇 Retrofit— 仅对开发版本使用日志</title>
    <link href="http://www.orzangleli.com/2017/02/14/2017-02-14_%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87%20Retrofit%E2%80%94%20%E4%BB%85%E5%AF%B9%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97/"/>
    <id>http://www.orzangleli.com/2017/02/14/2017-02-14_第十二篇 Retrofit— 仅对开发版本使用日志/</id>
    <published>2017-02-13T16:00:00.000Z</published>
    <updated>2017-02-14T08:23:39.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12-第十二篇-Retrofit—-仅对开发版本使用日志"><a href="#12-第十二篇-Retrofit—-仅对开发版本使用日志" class="headerlink" title="12. 第十二篇 Retrofit— 仅对开发版本使用日志"></a>12. 第十二篇 Retrofit— 仅对开发版本使用日志</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#一、-开发版和发布版区别">一、 开发版和发布版区别</a></li>
<li><a href="#二、使用不同的日志级别">二、使用不同的日志级别</a></li>
<li><a href="#三、在github中实战">三、在Github中实战</a><ul>
<li><a href="#31-新建证书文件">3.1 新建证书文件</a></li>
<li><a href="#32-修改app中配置">3.2 修改app中配置</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<p>在前面的文章中，我们已经给你展示了用Retrofit2 启用请求和响应的日志功能。我们也说明了你应该只在开发版本中启用日志功能，推荐你发布版本应该禁用掉日志功能。本文我们就来介绍下如何自动完成这个功能。</p>
<h2 id="一、-开发版和发布版区别"><a href="#一、-开发版和发布版区别" class="headerlink" title="一、 开发版和发布版区别"></a>一、 开发版和发布版区别</h2><p>自动化是增长开发者的注意力和生产率的最好工具之一。手动启用和禁用Retrofit日志功能可能是乏味重复的工作。而且增加了发布版本仍然记录日志的风险几率。所以，我们来看看自动实现这个过程：在开发过程中，日志记录功能被启用；发布版本就会禁用掉日志功能。</p>
<p>解决方法如此简单：我们利用Android framework提供的<code>Build.DEBUG</code> boolean型变量。返回值为<code>true</code>代表开发版本，<code>false</code>代表发布版本。之前的文章中，我们的代码是这样的：</p>
<pre><code>HttpLoggingInterceptor logging = new HttpLoggingInterceptor();  
logging.setLevel(Level.BODY);

OkHttpClient.Builder httpClient = new OkHttpClient.Builder();  
httpClient.addInterceptor(logging);

Retrofit retrofit = new Retrofit.Builder()  
   .baseUrl(API_BASE_URL)
   .addConverterFactory(GsonConverterFactory.create())
   .client(httpClient.build())
   .build();
</code></pre><p>现在我们稍微改变下代码，实现仅在开发版本启用日志功能：</p>
<pre><code>OkHttpClient.Builder httpClient = new OkHttpClient.Builder();

if (BuildConfig.DEBUG) {  
    HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
    logging.setLevel(Level.BODY);

    httpClient.addInterceptor(logging);
}

Retrofit retrofit = new Retrofit.Builder()  
   .baseUrl(API_BASE_URL)
   .addConverterFactory(GsonConverterFactory.create())
   .client(httpClient.build())
   .build();
</code></pre><p>它会只在开发版本添加日志拦截器。我们真的强烈推荐你把这种技术或者类似技术应用于你的APP中，这不会花很长时间，反而会每天为你省一点时间。你的时间很重要！</p>
<h2 id="二、使用不同的日志级别"><a href="#二、使用不同的日志级别" class="headerlink" title="二、使用不同的日志级别"></a>二、使用不同的日志级别</h2><p>如果你在发布版本中仍然想看到一些日志信息，但是是使用另一种日志级别，你可以用下面这种方法。<br>我们再修改下代码：</p>
<pre><code>OkHttpClient.Builder httpClient = new OkHttpClient.Builder();

HttpLoggingInterceptor logging = new HttpLoggingInterceptor();

if (BuildConfig.DEBUG) {  
    // development build
    logging.setLevel(Level.BODY);
} else {
    // production build
    logging.setLevel(Level.BASIC);
}

httpClient.addInterceptor(logging);

Retrofit retrofit = new Retrofit.Builder()  
   .baseUrl(API_BASE_URL)
   .addConverterFactory(GsonConverterFactory.create())
   .client(httpClient.build())
   .build();
</code></pre><h2 id="三、在Github中实战"><a href="#三、在Github中实战" class="headerlink" title="三、在Github中实战"></a>三、在Github中实战</h2><h3 id="3-1-新建证书文件"><a href="#3-1-新建证书文件" class="headerlink" title="3.1 新建证书文件"></a>3.1 新建证书文件</h3><p>发布版本需要有用户的证书文件，调试版本使用的是默认的证书文件，所以需要建立自己的证书文件，如果之前已经建过的，可以跳过。</p>
<p>点击菜单中 Build–Generate Signed APK,在弹出的对话框中选择 Create new… ,选择证书的保存位置，填好相关信息点击OK后关闭，然后关闭弹出的Generate Signed APK对话框，证书建立完成。</p>
<h3 id="3-2-修改app中配置"><a href="#3-2-修改app中配置" class="headerlink" title="3.2 修改app中配置"></a>3.2 修改app中配置</h3><p>点击菜单File–Project Structure,选择Module app。</p>
<ol>
<li>点击Signing 选项卡，点击“+”号，填写刚刚的证书的路径和密码等内容。</li>
<li>点击Build Types选项卡，选择release,然后在Signing Config下拉列表中选择上一步新建的config .</li>
</ol>
<p>还需要打开Build Variants ,将app 对应的变量修改为 release .打开Build Variants的方式如图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-17_16_02_19_BuildVariants.png" alt=""></p>
<p>修改之前的教程中的ServiceGenerator：</p>
<pre><code>public class ServiceGenerator {

    public static final String API_BASIC_URL = &quot;https://api.github.com/&quot;;
    private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder();

    private static Retrofit.Builder builder =new Retrofit.Builder()
            .baseUrl(API_BASIC_URL)
            .addConverterFactory(GsonConverterFactory.create());

    static HttpLoggingInterceptor logging = new HttpLoggingInterceptor();


    public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass){
        if (BuildConfig.DEBUG) {
            logging.setLevel(HttpLoggingInterceptor.Level.BODY);
            httpClient.addInterceptor(logging);
        }
        Retrofit retrofit = builder.client(httpClient.build()).build();
        return retrofit.create(serviceClass);
    }

}
</code></pre><p>这样，如果版本不是调试版本，就不会有日志打印出来了。</p>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;12-第十二篇-Retrofit—-仅对开发版本使用日志&quot;&gt;&lt;a href=&quot;#12-第十二篇-Retrofit—-仅对开发版本使用日志&quot; class=&quot;headerlink&quot; title=&quot;12. 第十二篇 Retrofit— 仅对开发版本使用日志&quot;&gt;&lt;/a&gt;1
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第十一篇 Retrofit— 使用日志级别调试请求</title>
    <link href="http://www.orzangleli.com/2017/02/13/2017-02-13_%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%20Retrofit%E2%80%94%20%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E8%B0%83%E8%AF%95%E8%AF%B7%E6%B1%82/"/>
    <id>http://www.orzangleli.com/2017/02/13/2017-02-13_第十一篇 Retrofit— 使用日志级别调试请求/</id>
    <published>2017-02-12T16:00:00.000Z</published>
    <updated>2017-02-13T12:32:05.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-第十一篇-Retrofit—-使用日志级别调试请求"><a href="#11-第十一篇-Retrofit—-使用日志级别调试请求" class="headerlink" title="11. 第十一篇 Retrofit— 使用日志级别调试请求"></a>11. 第十一篇 Retrofit— 使用日志级别调试请求</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#一-、retrofit-2-中的日志功能">一 、Retrofit 2 中的日志功能</a></li>
<li><a href="#二、日志级别">二、日志级别</a><ul>
<li><a href="#21-none">2.1 None</a></li>
<li><a href="#22-basic">2.2 Basic</a></li>
<li><a href="#23-headers">2.3 Headers</a></li>
<li><a href="#24-body">2.4 Body</a></li>
</ul>
</li>
<li><a href="#三、总结">三、总结</a></li>
<li><a href="#四、在github中实战">四、在Github中实战</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>在深入挖掘Retrofit的网络请求艺术后，本文我们看看Retrofit的调试功能，顺便复习下之前学到的知识点。</p>
<h2 id="一-、Retrofit-2-中的日志功能"><a href="#一-、Retrofit-2-中的日志功能" class="headerlink" title="一 、Retrofit 2 中的日志功能"></a>一 、Retrofit 2 中的日志功能</h2><p>Retrofit2 在网络操作上完全依赖OkHttp.OkHttp的开发者已经发布了一个独立的继承OkHttp的日志拦截工程。你可以把它添加到你项目的<code>build.gradle</code>中：</p>
<pre><code>compile &apos;com.squareup.okhttp3:logging-interceptor:3.3.1&apos;  

在开发APP或者调试程序时，整合了日志功能，能显示请求和响应信息是非常不错的。因为Retrofit 2默认并没有整合日志功能，所以我们需要添加一个日志拦截器到OkHttp上。幸运的是，OkHttp已经为拦截器做好了准备，你需要做的就是激活它。

HttpLoggingInterceptor logging = new HttpLoggingInterceptor();  
// set your desired log level
logging.setLevel(Level.BODY);

OkHttpClient.Builder httpClient = new OkHttpClient.Builder();  
// add your other interceptors …

// add logging as last interceptor
httpClient.addInterceptor(logging);  // &lt;-- this is the important line!

Retrofit retrofit = new Retrofit.Builder()  
   .baseUrl(API_BASE_URL)
   .addConverterFactory(GsonConverterFactory.create())
   .client(httpClient.build())
   .build();
</code></pre><h2 id="二、日志级别"><a href="#二、日志级别" class="headerlink" title="二、日志级别"></a>二、日志级别</h2><p>打印过多信息会爆掉你的Android 监视器，这就是为什么OkHttp的日志拦截器有个日志级别： <code>NONE</code>, <code>BASIC</code>, <code>HEADERS</code>, <code>BODY</code>.现在带你一起看看每一种日志级别并描述它们的输出内容。</p>
<h3 id="2-1-None"><a href="#2-1-None" class="headerlink" title="2.1 None"></a>2.1 None</h3><p><strong>无日志</strong></p>
<p>使用这个日志级别配置开发环境会让你的app跳过所有的日志操作。</p>
<h3 id="2-2-Basic"><a href="#2-2-Basic" class="headerlink" title="2.2 Basic"></a>2.2 Basic</h3><p><strong>打印请求type,url,request body大小，响应状态和response  body的大小</strong></p>
<pre><code>D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1 (277-byte body)  
D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (543ms, -1-byte body) 
</code></pre><p>使用<code>Basic</code>级别会打印最少的请求信息。如果你只对equest body的大小，response  body的大小和响应状态感兴趣，这种日志级别最适合你。</p>
<h3 id="2-3-Headers"><a href="#2-3-Headers" class="headerlink" title="2.3 Headers"></a>2.3 Headers</h3><p><strong>记录请求和响应头，请求类型，url，响应状态</strong></p>
<p>使用<code>Headers</code>级别的日志辉记录请求和响应头。Retrofit或OkHttp默认会添加适当的请求头，但是不会在请求上显示出来，也因为它们是后来才在请求链中被添加上去的。如果你不在Android上截获真实的请求，你什么都看不到。如果你自己添加了请求头，请确保日志拦截器是你最后添加拦截器。如果你最先添加日志拦截器，那请求头上就不会有任何的请求头了。</p>
<p>假设你要自己定义请求头，我们使用<code>Accept</code>和<code>Content-Type</code>这两个字段来验证下输出内容。</p>
<pre><code>D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1  
D/HttpLoggingInterceptor$Logger: Accept: application/json  
D/HttpLoggingInterceptor$Logger: Content-Type: application/json  
D/HttpLoggingInterceptor$Logger: --&gt; END POST  
D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (1039ms)  
D/HttpLoggingInterceptor$Logger: content-type: text/html; charset=utf-8  
D/HttpLoggingInterceptor$Logger: cache-control: no-cache  
D/HttpLoggingInterceptor$Logger: vary: accept-encoding  
D/HttpLoggingInterceptor$Logger: Date: Wed, 28 Oct 2015 08:24:20 GMT  
D/HttpLoggingInterceptor$Logger: Connection: keep-alive  
D/HttpLoggingInterceptor$Logger: Transfer-Encoding: chunked  
D/HttpLoggingInterceptor$Logger: OkHttp-Selected-Protocol: http/1.1  
D/HttpLoggingInterceptor$Logger: OkHttp-Sent-Millis: 1446020610352  
D/HttpLoggingInterceptor$Logger: OkHttp-Received-Millis: 1446020610369  
D/HttpLoggingInterceptor$Logger: &lt;-- END HTTP
</code></pre><p>除了服务器的响应头，你还可以看到使用什么协议以及在各自的发送请求和接受响应所用的毫秒级时间。</p>
<h3 id="2-4-Body"><a href="#2-4-Body" class="headerlink" title="2.4 Body"></a>2.4 Body</h3><p><strong>记录日志请求和响应的请求头和请求体</strong></p>
<p>这是最完整的日志级别，会打印所有请求和响应相关的信息。</p>
<pre><code>D/HttpLoggingInterceptor$Logger: --&gt; POST /upload HTTP/1.1  
D/HttpLoggingInterceptor$Logger: --9df820bb-bc7e-4a93-bb67-5f28f4140795  
D/HttpLoggingInterceptor$Logger: Content-Disposition: form-data; name=&quot;description&quot;  
D/HttpLoggingInterceptor$Logger: Content-Transfer-Encoding: binary  
D/HttpLoggingInterceptor$Logger: Content-Type: application/json; charset=UTF-8  
D/HttpLoggingInterceptor$Logger: Content-Length: 37  
D/HttpLoggingInterceptor$Logger:  
D/HttpLoggingInterceptor$Logger: &quot;hello, this is description speaking&quot;  
D/HttpLoggingInterceptor$Logger: --9df820bb-bc7e-4a93-bb67-5f28f4140795--  
D/HttpLoggingInterceptor$Logger: --&gt; END POST (277-byte body)  
D/HttpLoggingInterceptor$Logger: &lt;-- HTTP/1.1 200 OK (1099ms)  
D/HttpLoggingInterceptor$Logger: content-type: text/html; charset=utf-8  
D/HttpLoggingInterceptor$Logger: cache-control: no-cache  
D/HttpLoggingInterceptor$Logger: vary: accept-encoding  
D/HttpLoggingInterceptor$Logger: Date: Wed, 28 Oct 2015 08:33:40 GMT  
D/HttpLoggingInterceptor$Logger: Connection: keep-alive  
D/HttpLoggingInterceptor$Logger: Transfer-Encoding: chunked  
D/HttpLoggingInterceptor$Logger: OkHttp-Selected-Protocol: http/1.1  
D/HttpLoggingInterceptor$Logger: OkHttp-Sent-Millis: 1446021170095  
D/HttpLoggingInterceptor$Logger: OkHttp-Received-Millis: 1446021170107  
D/HttpLoggingInterceptor$Logger: Perfect!  
D/HttpLoggingInterceptor$Logger: &lt;-- END HTTP (8-byte body) 
</code></pre><p>这是唯一一种可以获得响应主体的日志界别。当你和后端开发者有不同意见的时候，用这中日志级别可以显示所有接受到的数据。但是<code>Body</code>级别会在接受大量数据时让你的Android 监视器堵塞。只有在有必要的时候才使用这种日志级别。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>我们希望你能把日志用到你的项目开发中，日志级别的信息会帮助你选择正确的日志级别。尝试不同的日志级别，看看哪个最适合你。即使说<code>Body</code>级别可能会堵塞你的日志监视窗口，但是有可能你只有在显示所有请求细节的时候才能找到你想要的信息。</p>
<h2 id="四、在Github中实战"><a href="#四、在Github中实战" class="headerlink" title="四、在Github中实战"></a>四、在Github中实战</h2><p>要添加日志记录功能，不需要对已有的业务模块进行修改，只要把<code>ServiceGenerator</code>修改下就可以了，看我修改后的代码：</p>
<pre><code>public class ServiceGenerator {

    public static final String API_BASIC_URL = &quot;https://api.github.com/&quot;;
    private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder();

    private static Retrofit.Builder builder =new Retrofit.Builder()
            .baseUrl(API_BASIC_URL)
            .addConverterFactory(GsonConverterFactory.create());

    static HttpLoggingInterceptor logging = new HttpLoggingInterceptor();


    public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass){
        logging.setLevel(HttpLoggingInterceptor.Level.BODY);
        httpClient.addInterceptor(logging);

        Retrofit retrofit = builder.client(httpClient.build()).build();
        return retrofit.create(serviceClass);
    }
}
</code></pre><p>记住，在项目的<code>build.gradle</code>中添加对log拦截器的依赖：</p>
<pre><code>compile &apos;com.squareup.okhttp3:logging-interceptor:3.3.1&apos;
</code></pre><p>在控制台中可以看到很多请求和响应的日志，截图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-16_17_13_21_log.png" alt=""></p>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;11-第十一篇-Retrofit—-使用日志级别调试请求&quot;&gt;&lt;a href=&quot;#11-第十一篇-Retrofit—-使用日志级别调试请求&quot; class=&quot;headerlink&quot; title=&quot;11. 第十一篇 Retrofit— 使用日志级别调试请求&quot;&gt;&lt;/a&gt;1
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第十篇 Retrofit—可选的查询参数</title>
    <link href="http://www.orzangleli.com/2017/01/18/2017-01-18_%E7%AC%AC%E5%8D%81%E7%AF%87%20Retrofit%E2%80%94%E5%8F%AF%E9%80%89%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"/>
    <id>http://www.orzangleli.com/2017/01/18/2017-01-18_第十篇 Retrofit—可选的查询参数/</id>
    <published>2017-01-17T16:00:00.000Z</published>
    <updated>2017-01-18T13:50:30.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-可选的查询参数"><a href="#10-可选的查询参数" class="headerlink" title="10. 可选的查询参数"></a>10. 可选的查询参数</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#一、-retrofit查询参数">一、 Retrofit查询参数</a></li>
<li><a href="#二、-可选的查询参数">二、 可选的查询参数</a></li>
<li><a href="#三、-在github中实战">三、 在Github中实战</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>前几篇文章，带你领略了添加自定义请求头的技术方法。现在，我们来看看在Retofit中如何让参数可选。</p>
<h2 id="一、-Retrofit查询参数"><a href="#一、-Retrofit查询参数" class="headerlink" title="一、 Retrofit查询参数"></a>一、 Retrofit查询参数</h2><p>Retrofit使用注解定义查询参数。方法参数前面定义的注解，指定了要查询的参数的名字。在请求执行时，我们要查询的参数就会传递到URL中。现在我们来看个具体的例子。下面的代码讲的就是一个以<code>/tasks</code>作为API endpoint的请求，它提供了一个选项<code>sort</code>参数以达到排序的目的。</p>
<p>public interface TaskService {<br>    @GET(“/tasks”)<br>    Call<list<task>&gt; getTasks(@Query(“sort”) String order);<br>}</list<task></p>
<p>假设你的API的基本地址是：<code>https://your.api.com</code>,请求就使用上面的<code>TaskService</code>调用<code>getTasks</code>方法，最终形成的请求的URL是这样的：</p>
<pre><code>https://your.api.com/tasks?sort=value-of-order-parameter
</code></pre><h2 id="二、-可选的查询参数"><a href="#二、-可选的查询参数" class="headerlink" title="二、 可选的查询参数"></a>二、 可选的查询参数</h2><p>根据API的设计原则，<code>sort</code>参数应该是可选的。如果你不想在请求中传递这个参数，你可以在方法调用的时候直接传递<strong><code>null</code></strong>给<code>order</code>。</p>
<pre><code>service.getTasks(null);  
</code></pre><p>Retrofit会跳过<code>null</code>参数，并且在实现请求的时候忽略它们。记住，你不可以把<code>null</code>传递给这几种类型:<code>int</code>,<code>float</code>,<code>long</code>等。但是如果你使用的是<code>Integer</code>,<code>Float</code>,<code>Long</code>，那么就可以传递<code>null</code>了。</p>
<p>下面的例子描述的就是给之前提到的集中数据类型定义的请求客户端。</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks(
        @Query(&quot;sort&quot;) String order,
        @Query(&quot;page&quot;) Integer page);
}
</code></pre><p>现在，你可以给<code>order</code>或<code>page</code>中任何一个参数传递<code>null</code>了。</p>
<pre><code>service.getTasks(null, null); 
</code></pre><p>这样就是了，可选参数的查询，让我们总结下：实现可选参数的方法就是在定义客户端接口时，如果参数类型是<code>int</code>,’long’等基本数据类型，需要把这个参数的类型修改为其包装类，如<code>Integer</code>,<code>Long</code>等，如果本身就是封装的类，那在接口定义时就不需要处理。然后在调用客户端接口中的方法时，可以使用<code>null</code>传递给某些参数，这样在API请求时，就会自动忽略值为<code>null</code>的参数，从而达到参数可选的功能。</p>
<h2 id="三、-在Github中实战"><a href="#三、-在Github中实战" class="headerlink" title="三、 在Github中实战"></a>三、 在Github中实战</h2><p>我们以Github中<code>Search repositories</code>仓库搜索的API为例，展示下可选查询参数的demo.<br>从<a href="https://developer.github.com/v3/search/#search-repositories" target="_blank" rel="external">https://developer.github.com/v3/search/#search-repositories</a>中，我们可以找到搜索仓库的API使用方法。</p>
<pre><code>GET /search/repositories
</code></pre><table>
<thead>
<tr>
<th style="text-align:center">Name</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">q</td>
<td style="text-align:center">string</td>
<td style="text-align:center">搜索的关键字</td>
</tr>
<tr>
<td style="text-align:center">sort</td>
<td style="text-align:center">string</td>
<td style="text-align:center">排序依据参数，可以是 <code>stars</code>, <code>forks</code>, 或者 <code>updated</code>. 默认是按匹配的程度排序。</td>
</tr>
<tr>
<td style="text-align:center">order</td>
<td style="text-align:center">string</td>
<td style="text-align:center">决定搜索结果的排序是增序还是减序，可以是asc或 desc. 默认是: desc（减序）</td>
</tr>
</tbody>
</table>
<p>好，现在我们把GithubClient接口修改下，注意请求方式是<code>GET</code>：</p>
<pre><code>public interface GithubClient {
    @GET(&quot;/search/repositories&quot;)
    Call&lt;ResponseBody&gt; searchRepos(
            @Query(&quot;q&quot;) String keywords,
            @Query(&quot;sort&quot;) String sort,
            @Query(&quot;order&quot;) String order
    );
}
</code></pre><p>MainActivity中测试时，可以将<code>searchRepos(...)</code>方法中的第二个和第三个参数修改为<code>null</code>。</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private final static String TAG = &quot;ILearnRetrofit&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Utils.init(this);

        GithubClient client = ServiceGenerator.createService(GithubClient.class);
        Call&lt;ResponseBody&gt; call = client.searchRepos(&quot;Retrofit&quot;,&quot;updated&quot;,null);  // 搜索包含`Retrofit`关键字的仓库，按照更新时间排序，排序方式按照默认的减序
        call.enqueue(new Callback&lt;ResponseBody&gt;() {
            @Override
            public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) {
                try {
                    if (response.isSuccessful())
                        i(TAG, &quot;搜索成功：&quot; + response.body().string() );
                    else
                        i(TAG, &quot;搜索失败：&quot; + response.errorBody().string());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            @Override
            public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) {
                i(TAG, &quot;搜索失败：&quot; + t.getMessage());
            }
        });

    }
}
</code></pre><p>正常的返回数据在控制台中可以看到打印（因为logcat打印有4k长度限制,所以直接看到的json格式并不是完整的）：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-15_12_28_02_搜索仓库.png" alt=""></p>
<p>因为<code>sort</code>和<code>order</code>是可选参数，如果不填写，是有默认值可以继续正常使用的，这也就是为什么<code>q</code>参数不能传递<code>null</code>，虽然程序可以正常执行，但是API端返回数据有误，报错如下：</p>
<pre><code>搜索失败：
{
    &quot;message&quot;: &quot;Validation Failed&quot;,
    &quot;errors&quot;: [
        {
            &quot;resource&quot;: &quot;Search&quot;,
            &quot;field&quot;: &quot;q&quot;,
            &quot;code&quot;: &quot;missing&quot;
        }
    ],
    &quot;documentation_url&quot;: &quot;https://developer.github.com/v3/search&quot;
}
</code></pre><blockquote>
<p>本教程所有源码参见此网页：[留白]</p>
</blockquote>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;10-可选的查询参数&quot;&gt;&lt;a href=&quot;#10-可选的查询参数&quot; class=&quot;headerlink&quot; title=&quot;10. 可选的查询参数&quot;&gt;&lt;/a&gt;10. 可选的查询参数&lt;/h1&gt;&lt;!-- MarkdownTOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>9 第九篇 Retrofit—同一key多重value字段</title>
    <link href="http://www.orzangleli.com/2017/01/17/2017-01-17_9%20%E7%AC%AC%E4%B9%9D%E7%AF%87%20Retrofit%E2%80%94%E5%90%8C%E4%B8%80key%E5%A4%9A%E9%87%8Dvalue%E5%AD%97%E6%AE%B5/"/>
    <id>http://www.orzangleli.com/2017/01/17/2017-01-17_9 第九篇 Retrofit—同一key多重value字段/</id>
    <published>2017-01-16T16:00:00.000Z</published>
    <updated>2017-01-17T14:32:19.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-跟orzangleli一起学Retrofit2-第九篇-Retrofit—同一key多重value字段"><a href="#9-跟orzangleli一起学Retrofit2-第九篇-Retrofit—同一key多重value字段" class="headerlink" title="9. [跟orzangleli一起学Retrofit2]  第九篇 Retrofit—同一key多重value字段"></a>9. [跟orzangleli一起学Retrofit2]  第九篇 Retrofit—同一key多重value字段</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#一、-查询参数">一、 查询参数</a></li>
<li><a href="#二、-多重查询参数">二、 多重查询参数</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>本文描述如何使用Retrofit执行带有<code>同一个key对应单个value</code>的字段和<code>同一key对应多重value</code>的字段的请求。</p>
<h2 id="一、-查询参数"><a href="#一、-查询参数" class="headerlink" title="一、 查询参数"></a>一、 查询参数</h2><p>在客户端对服务器的访问中，查询参数是最常用的方法之一。现在来看一个例子，我们从<code>https://api.example.com/</code>中请求一个查询<code>id=123</code>的任务。</p>
<p><a href="https://api.example.com/tasks?id=123" target="_blank" rel="external">https://api.example.com/tasks?id=123</a>  </p>
<p>这个api是不存在，只是将URL写出来让你看看查询参数是怎么添加到URL中的。我们假设这个API是存在的，那么我们就能获取一个<code>id=123</code> 的单个任务。</p>
<p>在Retrofit中定义查询参数的方法如下:</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;Task&gt; getTask(@Query(&quot;id&quot;) long taskId);
}
</code></pre><p>上面的代码中<code>getTask(...)</code>方法需要<code>taskId</code>参数。这个参数会被Retrofit映射到<code>@Query</code>注解包围参数名上去，在本例中，这个被<code>@Query</code>包围的参数就是<code>id</code>，最终组成的url像下面这样：</p>
<pre><code>/tasks?id=&lt;taskId&gt;
</code></pre><h2 id="二、-多重查询参数"><a href="#二、-多重查询参数" class="headerlink" title="二、 多重查询参数"></a>二、 多重查询参数</h2><p>有些情况下，需要在请求中传递同一个参数名对应的多个值。就以刚刚查询任务的api为例，我们可以扩展参数得到一组不同id的任务列表。</p>
<p>我们要创建的请求url像这样：</p>
<pre><code>https://api.example.com/tasks?id=123&amp;id=124&amp;id=125  
</code></pre><p>理想的服务器返回数据应该是从url查询参数给定的<code>ids=[123, 124, 125]</code>对应的一组任务列表。具体代码如下：</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTask(@Query(&quot;id&quot;) List&lt;Long&gt; taskIds);
}
</code></pre><p>只要将方法的参数和返回值替换成List包围的就可以了。但前提是你的服务器或者API支持这种多值参数的查询，我在网上找了一些API测试发现，他们都不支持这种多值查询，会自动将查询结果变为最后一个参数的查询结果。所以，如果读者发现有可用的支持多值查询的API可以联系我，我将添加案例。</p>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;9-跟orzangleli一起学Retrofit2-第九篇-Retrofit—同一key多重value字段&quot;&gt;&lt;a href=&quot;#9-跟orzangleli一起学Retrofit2-第九篇-Retrofit—同一key多重value字段&quot; class=&quot;heade
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>8 第八篇_Retrofit 2— 用@HeaderMap实现动态请求头</title>
    <link href="http://www.orzangleli.com/2017/01/16/2017-01-16_8%20%E7%AC%AC%E5%85%AB%E7%AF%87_Retrofit%202%E2%80%94%20%E7%94%A8@HeaderMap%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4/"/>
    <id>http://www.orzangleli.com/2017/01/16/2017-01-16_8 第八篇_Retrofit 2— 用@HeaderMap实现动态请求头/</id>
    <published>2017-01-15T16:00:00.000Z</published>
    <updated>2017-01-17T14:32:19.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-Retrofit-2-—-用-HeaderMap实现动态请求头"><a href="#8-Retrofit-2-—-用-HeaderMap实现动态请求头" class="headerlink" title="8. Retrofit 2 — 用@HeaderMap实现动态请求头"></a>8. Retrofit 2 — 用@HeaderMap实现动态请求头</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#一、-动态的请求头">一、 动态的请求头</a></li>
<li><a href="#二、-展望">二、 展望</a></li>
<li><a href="#三、-在github中实战">三、 在Github中实战</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>之前，我们研究了如何用Retrofit添加请求头以及静态修改请求头。本篇文章，我们将深入研究如何给Retrofit的请求添加动态数量的请求头。</p>
<p>这是Retrofit 2.1的新特性，所以在咱们做实验之前，请确保你已经做了升级工作。</p>
<h2 id="一、-动态的请求头"><a href="#一、-动态的请求头" class="headerlink" title="一、 动态的请求头"></a>一、 动态的请求头</h2><p>我们在之前的教程中给你展示的都是静态的请求头。虽然你可以改变请求头的字段的值，但是你能动态地选择你想要发送的请求头。如果你需要在运行时决定要发送那些请求头到你的请求上的话，<code>@HeaderMap</code>是一种可行方案。</p>
<p>与<code>@Header</code>注解类似，你要在接口的一个参数上声明<code>@HeaderMap</code>。参数的类型必须得是Java Map 接口的实现：</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks(
        @HeaderMap Map&lt;String, String&gt; headers
    );
}
</code></pre><p>使用我们上面定义的这个接口很简单。你可以直接创建一个Map实例，并且把你需要的指添加进去即可。Retrofit会把<code>@HeaderMap</code>注解的Map中每一个非null元素添加到请求头中。</p>
<pre><code>TaskService taskService = ServiceGenerator.createService(TaskService.class);

Map&lt;String, String&gt; map = new HashMap&lt;&gt;();  
map.put(&quot;Page&quot;, String.valueOf(page));

if (BuildConfig.DEBUG) {  
    map.put(&quot;Accept&quot;, &quot;application/vnd.yourapi.v1.full+json&quot;);
    map.put(&quot;User-Agent&quot;, &quot;Future Studio Debug&quot;);
}
else {  
    map.put(&quot;Accept&quot;, &quot;application/json&quot;);
    map.put(&quot;Accept-Charset&quot;, &quot;utf-8&quot;);
    map.put(&quot;User-Agent&quot;, &quot;Future Studio Release&quot;);
}

Call&lt;List&lt;Task&gt;&gt; call = taskService.getTasks(map);  
// Use it like any other Retrofit call
</code></pre><h2 id="二、-展望"><a href="#二、-展望" class="headerlink" title="二、 展望"></a>二、 展望</h2><p>本文中，你已经学会了如何使用<code>@HeaderMap</code> 在运行时添加动态数量的请求头。这对之前的静态请求头功能是一个极为出色的扩展。爱死它了。</p>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
<h2 id="三、-在Github中实战"><a href="#三、-在Github中实战" class="headerlink" title="三、 在Github中实战"></a>三、 在Github中实战</h2><p>本节内容由于代码与之前变化并不大，而且我没有在Github中找到合适的API,所以暂时不提供实战代码。如果各位读者找到了，可以通知我，我将会补上实战案例。</p>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;8-Retrofit-2-—-用-HeaderMap实现动态请求头&quot;&gt;&lt;a href=&quot;#8-Retrofit-2-—-用-HeaderMap实现动态请求头&quot; class=&quot;headerlink&quot; title=&quot;8. Retrofit 2 — 用@HeaderMa
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头</title>
    <link href="http://www.orzangleli.com/2017/01/13/2017-01-13_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E4%B8%83%E7%AF%87%20Retrofit%202%E2%80%94%E2%80%94%E5%9C%A8OkHttp%20Interceptor%E4%B8%AD%E7%AE%A1%E7%90%86%E8%AF%B7%E6%B1%82%E5%A4%B4/"/>
    <id>http://www.orzangleli.com/2017/01/13/2017-01-13_[跟orzangleli一起学Retrofit2]  第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头/</id>
    <published>2017-01-13T04:30:00.000Z</published>
    <updated>2017-01-14T14:59:41.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-跟orzangleli一起学Retrofit2-第七篇-Retrofit-2——在OkHttp-Interceptor中管理请求头"><a href="#7-跟orzangleli一起学Retrofit2-第七篇-Retrofit-2——在OkHttp-Interceptor中管理请求头" class="headerlink" title="7. [跟orzangleli一起学Retrofit2]  第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头"></a>7. [跟orzangleli一起学Retrofit2]  第七篇 Retrofit 2——在OkHttp Interceptor中管理请求头</h1><p><strong>目录</strong></p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#一、-添加请求头">一、 添加请求头</a><ul>
<li><a href="#11-如何覆盖请求头字段">1.1 如何覆盖请求头字段</a></li>
<li><a href="#12-如何不覆盖请求头字段">1.2 如何不覆盖请求头字段</a></li>
</ul>
</li>
<li><a href="#二、-小福利请带走">二、 小福利请带走</a></li>
<li><a href="#三、-在github中实战">三、 在Github中实战</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>前面的教程中你已经学了Retrofit中怎么添加请求头。本文就是专门揪出用Retrofit 2和OkHttp interceptor（拦截器） 添加请求头的细节的。<code>Interceptor拦截器</code>在静态地修改请求上，是一种非常好的的方法。什么意思，直白地说，就是拦截器可以修改请求，但是它的修改相当于是一次性的，不能动态修改。</p>
<h2 id="一、-添加请求头"><a href="#一、-添加请求头" class="headerlink" title="一、 添加请求头"></a>一、 添加请求头</h2><p>常用的添加请求头的例子就是用<code>Authorization</code>字段来认证。如果你需要在每一次请求都是用这个认证的请求头字段，你可以在<code>interceptor（拦截器）</code>中添加这些信息。这样你就不用给每个客户端的请求都添加<code>@Header</code>注解了。</p>
<p>OkHttp 的拦截器提供两种方式添加请求头中的字段及其对应的值。你可以直接覆盖已存在的字段，也可以不检查是否这个字段已经存在都直接添加。接下来，我们就来看看这两种情况。</p>
<h3 id="1-1-如何覆盖请求头字段"><a href="#1-1-如何覆盖请求头字段" class="headerlink" title="1.1 如何覆盖请求头字段"></a>1.1 如何覆盖请求头字段</h3><p>在OkHttp 拦截器的帮助下，你可以拦截HTTP的请求，对这个请求进行一些定制化处理并操作实际请求。请求的builder 对象有一个<code>.header(key, val)</code>方法，它可以把字段添加到请求中区，如果这个字段<code>key</code>已经存在，那就直接覆盖之前的值。</p>
<pre><code>OkHttpClient.Builder httpClient = new OkHttpClient.Builder();  
httpClient.addInterceptor(new Interceptor() {  
    @Override
    public Response intercept(Interceptor.Chain chain) throws IOException {
        Request original = chain.request();

        // Request customization: add request headers
        Request.Builder requestBuilder = original.newBuilder()
                .header(&quot;Authorization&quot;, &quot;auth-value&quot;); // &lt;-- this is the important line

        Request request = requestBuilder.build();
        return chain.proceed(request);
    }
});

OkHttpClient client = httpClient.build();  
</code></pre><p>Retrofit ，尤其是OkHttp允许你添加对同一个<code>key</code>字段添加多个值。<code>.header()</code>方法会替换掉所有已存在的相同<code>key</code>的字段。像上面的代码片段中，每个<code>Authorization</code>中请求字段都会被更新（如果之前已经定义多次的话），他们之前的字段的值就会变成<code>auth-value</code>。</p>
<h3 id="1-2-如何不覆盖请求头字段"><a href="#1-2-如何不覆盖请求头字段" class="headerlink" title="1.2 如何不覆盖请求头字段"></a>1.2 如何不覆盖请求头字段</h3><p>的确存在用同一个字段的key,但是value不相同的情况。比如，我们来看看这个字段<code>Cache-Control</code>,这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。Http 1.1协议规定，同一个key的多重value的字段是允许的，它们和逗号分隔的列表是一样的。</p>
<p>什么意思？</p>
<pre><code>Cache-Control: no-cache  
Cache-Control: no-store  
</code></pre><p>上面这段和下面这段作用一样：</p>
<pre><code>Cache-Control: no-cache, no-store  
</code></pre><p>使用Retrofit 2和OkHttp 的拦截器，你可以添加对同一个key添加多重value。用到的方法就是<code>.addHeader</code>。</p>
<p>下面的这个例子就是添加多个同一个key添加多重value的字段：</p>
<pre><code>OkHttpClient.Builder httpClient = new OkHttpClient.Builder();  
httpClient.addInterceptor(new Interceptor() {  
    @Override
    public Response intercept(Interceptor.Chain chain) throws IOException {
        Request original = chain.request();

        // Request customization: add request headers
        Request.Builder requestBuilder = original.newBuilder()
                    .addHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;)
                    .addHeader(&quot;Cache-Control&quot;, &quot;no-store&quot;);

        Request request = requestBuilder.build();
        return chain.proceed(request);
    }
});

OkHttpClient client = httpClient.build();  
</code></pre><h2 id="二、-小福利请带走"><a href="#二、-小福利请带走" class="headerlink" title="二、 小福利请带走"></a>二、 小福利请带走</h2><p><strong>注意</strong>这里的“见微知著”的差别：</p>
<ul>
<li><code>.header(key, val)</code>: 会覆盖之前已经存在的<code>key</code>字段的值</li>
<li><code>.addHeader(key, val)</code>: 不会覆盖，它会继续添加</li>
</ul>
<h2 id="三、-在Github中实战"><a href="#三、-在Github中实战" class="headerlink" title="三、 在Github中实战"></a>三、 在Github中实战</h2><p>本节内容由于要求能够在请求头中添加<code>同一个key添加多重value</code>的字段，但是我没有在Github中找到合适的API,如果各位读者找到了，可以通知我，我将会补上实战案例。</p>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;7-跟orzangleli一起学Retrofit2-第七篇-Retrofit-2——在OkHttp-Interceptor中管理请求头&quot;&gt;&lt;a href=&quot;#7-跟orzangleli一起学Retrofit2-第七篇-Retrofit-2——在OkHttp-Int
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第六篇 Retrofit中添加自定义请求头</title>
    <link href="http://www.orzangleli.com/2017/01/13/2017-01-13_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E5%85%AD%E7%AF%87%20Retrofit%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%A4%B4/"/>
    <id>http://www.orzangleli.com/2017/01/13/2017-01-13_[跟orzangleli一起学Retrofit2]  第六篇 Retrofit中添加自定义请求头/</id>
    <published>2017-01-13T04:00:00.000Z</published>
    <updated>2017-01-14T14:59:44.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-跟orzangleli一起学Retrofit2-第六篇-Retrofit中添加自定义请求头"><a href="#6-跟orzangleli一起学Retrofit2-第六篇-Retrofit中添加自定义请求头" class="headerlink" title="6. [跟orzangleli一起学Retrofit2]  第六篇 Retrofit中添加自定义请求头"></a>6. [跟orzangleli一起学Retrofit2]  第六篇 Retrofit中添加自定义请求头</h1><p><strong>目录</strong><br><!-- MarkdownTOC --></p>
<ul>
<li><a href="#一、-定义自定义请求头">一、 定义自定义请求头</a><ul>
<li><a href="#11-静态请求头">1.1 静态请求头</a></li>
<li><a href="#12-动态请求头">1.2 动态请求头</a></li>
<li><a href="#retrofit-2中覆盖已存在的请求头">Retrofit 2中覆盖已存在的请求头</a></li>
</ul>
</li>
<li><a href="#二、-在github中实战">二、 在Github中实战</a><ul>
<li><a href="#31-创建评论">3.1 创建评论</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<p>本文将为你展示如何在接口内部通过<code>@Header</code>注解添加自定义请求头，以及通过拦截请求添加自定义请求头。</p>
<h2 id="一、-定义自定义请求头"><a href="#一、-定义自定义请求头" class="headerlink" title="一、 定义自定义请求头"></a>一、 定义自定义请求头</h2><p>Retrofit提供两种方式定义HTTP请求头：静态和动态方式。静态请求头在发送不同请求时不能改变。请求头的键值对在接口方法上是固定不变的。</p>
<p>相反地，动态的请求头可以对每一个请求单独设置。</p>
<h3 id="1-1-静态请求头"><a href="#1-1-静态请求头" class="headerlink" title="1.1 静态请求头"></a>1.1 静态请求头</h3><p>添加静态请求头第一步要做的事是定义请求头，用注解的形式把请求头中的内容添加到你的API方法上。每次调用这个方法的请求都会自动的添加定义好的请求头。注解可以用键值的对构成的字符串的形式或者字符串数组的形式定义。现在来看看两个具体的请求头定义步骤：</p>
<pre><code>public interface UserService {  
    @Headers(&quot;Cache-Control: max-age=640000&quot;)
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks();
}
</code></pre><p>这个例子将键值对定义成静态请求头。当然，你也可以把很多组键值对包裹在花括号<code>{}</code>中作为请求头。就像下面这样：</p>
<pre><code>public interface UserService {  
    @Headers({
        &quot;Accept: application/vnd.yourapi.v1.full+json&quot;,
        &quot;User-Agent: Your-App-Name&quot;
    })
    @GET(&quot;/tasks/{task_id}&quot;)
    Call&lt;Task&gt; getTask(@Path(&quot;task_id&quot;) long taskId);
}
</code></pre><p>除此之外，你还可以通过Retrofit中<code>RequestInterceptor</code> 的<code>intercept</code>方法（需要自行实现<code>Interceptor</code>接口）定义静态请求头。</p>
<p>在Retrofit 2中，你需要拦截OkHttp提供的网络层请求。</p>
<pre><code>OkHttpClient.Builder httpClient = new OkHttpClient.Builder();  
httpClient.addInterceptor(new Interceptor() {  
    @Override
    public Response intercept(Interceptor.Chain chain) throws IOException {
        Request original = chain.request();

        Request request = original.newBuilder()
            .header(&quot;User-Agent&quot;, &quot;Your-App-Name&quot;)
            .header(&quot;Accept&quot;, &quot;application/vnd.yourapi.v1.full+json&quot;)
            .method(original.method(), original.body())
            .build();

        return chain.proceed(request);
    }
}

OkHttpClient client = httpClient.build();  
Retrofit retrofit = new Retrofit.Builder()  
    .baseUrl(API_BASE_URL)
    .addConverterFactory(GsonConverterFactory.create())
    .client(client)
    .build();
</code></pre><p>如你所见，上面的代码分别设置了<code>User-Agent</code>和<code>Accept</code>的内容。这些值会传递到Retrofit中所有使用这个<code>Interceptor</code> 发出的请求。</p>
<h3 id="1-2-动态请求头"><a href="#1-2-动态请求头" class="headerlink" title="1.2 动态请求头"></a>1.2 动态请求头</h3><p>想要定制化程度高点就需要使用动态请求头了。动态请求头像参数一样传递到方法中。给定的参数值将会在请求被执行钱被Retrofit映射到请求头中。看个小栗子吧：</p>
<pre><code>public interface UserService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks(@Header(&quot;Content-Range&quot;) String contentRange);
}
</code></pre><p>看到没，动态请求头中，你可以为不同的请求传递不同的参数。上面这段代码就是传递动态的<code>Content-Range</code> 到请求头中。</p>
<h3 id="Retrofit-2中覆盖已存在的请求头"><a href="#Retrofit-2中覆盖已存在的请求头" class="headerlink" title="Retrofit 2中覆盖已存在的请求头"></a>Retrofit 2中覆盖已存在的请求头</h3><p>与Retrofit v1版本不同，Retrofit 2中可以覆盖已存在的请求头字段（言下之意就是Retrofit不支持覆盖）。你可以在传递到OkHttp的client对象中的<code>Interceptor</code>的接口实现中完成对这些字段的覆盖。<code>Request.Builder</code>提供两种添加请求头的方法：</p>
<ol>
<li><code>.header(key, value)</code>： 如果请求头中已经存在这个字段的话就覆盖</li>
<li><code>.addHeader(key, value)</code>: 即使请求头中已经存在这个字段，也是照样添加，这样请求头中某个字段可能有多个值</li>
</ol>
<h2 id="二、-在Github中实战"><a href="#二、-在Github中实战" class="headerlink" title="二、 在Github中实战"></a>二、 在Github中实战</h2><p>在<a href="http://www.orzangleli.com/">5. [跟orzangleli一起学Retrofit2]  第五篇 在Retrofit的请求主体中发送对象</a>的Github实战中，我们在请求主体中发送评论，之前采用的认证方式是添加查询参数token,其实除了这种认证方式，我们还可以在请求头中添加token信息,下面我们就使用这种方法来发表评论。</p>
<h3 id="3-1-创建评论"><a href="#3-1-创建评论" class="headerlink" title="3.1 创建评论"></a>3.1 创建评论</h3><p>为了与第五篇文章的实验不冲突，我新建了一个<a href="https://gist.github.com/hust201010701/6582fb0808c585fddb5808b547bfbebf" target="_blank" rel="external">Gist片段</a>。</p>
<p>这里简单说明下，在请求中添加token的格式是：</p>
<pre><code>Authorization: token OAUTH-TOKEN
</code></pre><p>这样，我们简单修改下GithubClient接口：</p>
<pre><code>public interface GithubClient {
    @POST(&quot;/gists/{gist_id}/comments&quot;)
    Call&lt;ResponseBody&gt; commentGist(
      @Path(&quot;gist_id&quot;) String gist_id,
      @Body GistComment comment,
      @Header(&quot;Authorization&quot;) String token
    );

    class GistComment{
        String body;
        public GistComment(String body) {
            this.body = body;
        }
    }
}
</code></pre><p>然后把MainActivity.java中的Gist_id修改成<code>6582fb0808c585fddb5808b547bfbebf</code>,并且修改下<code>commentGist</code>中的参数：</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private final static String TAG = &quot;ILearnRetrofit&quot;;
    private final String Gist_id = &quot;6582fb0808c585fddb5808b547bfbebf&quot;;
    private final String Github_Token = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Utils.init(this);

        GithubClient client = ServiceGenerator.createService(GithubClient.class);
        GithubClient.GistComment comment = new GithubClient.GistComment(&quot;这是Retrofit 2在请求头中使用token认证发出来的评论，发送人是orzangleli&quot;); // 可以把我的id orzangleli 修改成你自己的
        Call&lt;ResponseBody&gt; call = client.commentGist(Gist_id, comment, &quot; token &quot;+Github_Token);
        call.enqueue(new Callback&lt;ResponseBody&gt;() {
            @Override
            public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) {
                if (response.isSuccessful())
                    i(TAG, &quot;评论成功：&quot; + response.raw());
                else
                    i(TAG, &quot;评论失败：&quot; + response.errorBody());
            }

            @Override
            public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) {
                i(TAG, &quot;评论失败：&quot; + t.getMessage());
            }
        });

    }
}
</code></pre><p>代码中的Github_Token 需要换成你自己的，可以看这篇教程<strong>[Retrofit 2 番外篇]将Github作为Retrofit的测试对象</strong>,因为它只显示一次，所以记住将这个token保存在本地，以后的教程会经常用到这个token。</p>
<p>最后，你可以到<a href="https://gist.github.com/hust201010701/6582fb0808c585fddb5808b547bfbebf" target="_blank" rel="external">https://gist.github.com/hust201010701/6582fb0808c585fddb5808b547bfbebf</a>中看看，你的评论是否正常的发出了。</p>
<p>我的已经成功了：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-13_13_56_05_请求头中token认证.png" alt=""></p>
<blockquote>
<p>本教程所有源码参见此网页：[留白]</p>
</blockquote>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;6-跟orzangleli一起学Retrofit2-第六篇-Retrofit中添加自定义请求头&quot;&gt;&lt;a href=&quot;#6-跟orzangleli一起学Retrofit2-第六篇-Retrofit中添加自定义请求头&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第五篇 在Retrofit的请求主体中发送对象</title>
    <link href="http://www.orzangleli.com/2017/01/12/2017-01-12_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E4%BA%94%E7%AF%87%20%E5%9C%A8Retrofit%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%BB%E4%BD%93%E4%B8%AD%E5%8F%91%E9%80%81%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.orzangleli.com/2017/01/12/2017-01-12_[跟orzangleli一起学Retrofit2]  第五篇 在Retrofit的请求主体中发送对象/</id>
    <published>2017-01-12T04:30:00.000Z</published>
    <updated>2017-01-14T14:59:31.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-跟orzangleli一起学Retrofit2-第五篇-在Retrofit的请求主体中发送对象"><a href="#5-跟orzangleli一起学Retrofit2-第五篇-在Retrofit的请求主体中发送对象" class="headerlink" title="5. [跟orzangleli一起学Retrofit2]  第五篇 在Retrofit的请求主体中发送对象"></a>5. [跟orzangleli一起学Retrofit2]  第五篇 在Retrofit的请求主体中发送对象</h1><p><strong>目录</strong><br><!-- MarkdownTOC --></p>
<ul>
<li><a href="#一、-在请求主体中发送对象">一、 在请求主体中发送对象</a></li>
<li><a href="#二、-举个栗子">二、 举个栗子</a></li>
<li><a href="#三、-在github中实战">三、 在Github中实战</a><ul>
<li><a href="#31-创建评论">3.1 创建评论</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<h2 id="一、-在请求主体中发送对象"><a href="#一、-在请求主体中发送对象" class="headerlink" title="一、 在请求主体中发送对象"></a>一、 在请求主体中发送对象</h2><p>Retrofit能够在请求主体中发送对象，通过使用<code>@Body</code>注解将这些对象指定为HTTP请求主体的内容。相对于之前的版本来说，Retrofit 2中 <code>@Body</code>功能并没有发生变化。</p>
<pre><code>public interface TaskService {  
    @POST(&quot;/tasks&quot;)
    Call&lt;Task&gt; createTask(@Body Task task);
}
</code></pre><p>事先定义好的<code>Retrofit</code>的转换器（如Gson）将会把传入的对象<code>task</code>映射成JSON格式，最终以请求主体的名义发送到你的服务器上。</p>
<h2 id="二、-举个栗子"><a href="#二、-举个栗子" class="headerlink" title="二、 举个栗子"></a>二、 举个栗子</h2><p>看个具体的例子吧。</p>
<pre><code>public class Task {  
    private long id;
    private String text;

    public Task(long id, String text) {
        this.id = id;
        this.text = text;
    }
}
</code></pre><p>初始化一个<code>Task</code>对象，然后对它的<code>id</code>和<code>text</code>赋值。这样，当你把这个<code>Task</code>对象传给service类的时候，对象的变量名和值会被转化为JSON格式。</p>
<pre><code>Task task = new Task(1, &quot;my task title&quot;);  
Call&lt;Task&gt; call = taskService.createTask(task);  
call.enqueue(new Callback&lt;Task&gt;() {});  
</code></pre><p>调用service中<code>createTask</code>方法，将会把<code>task</code>中的属性转化为JSON格式。<code>task</code>转化后的JSON格式内容像下面这样：</p>
<pre><code>{
    &quot;id&quot;: 1,
    &quot;text&quot;: &quot;my task title&quot;
}
</code></pre><h2 id="三、-在Github中实战"><a href="#三、-在Github中实战" class="headerlink" title="三、 在Github中实战"></a>三、 在Github中实战</h2><p>本次我们选用Github中的gist作为操作对象，关于gist是什么，可以参考<a href="http://group.jobbole.com/9655/" target="_blank" rel="external">http://group.jobbole.com/9655/</a>,Github的gist官网是<a href="https://gist.github.com/" target="_blank" rel="external">https://gist.github.com/</a>。</p>
<p>当然，gist并不是私有的，别人也是可以访问的，所以你们没有必要再自己创建一个gist片段，可以直接使用我的<a href="https://gist.github.com/hust201010701/04793d3d5b53e43d2f6a71b7c3103ea4" target="_blank" rel="external">https://gist.github.com/hust201010701/04793d3d5b53e43d2f6a71b7c3103ea4</a>。其中<code>04793d3d5b53e43d2f6a71b7c3103ea4</code>为gist的id.</p>
<p>因为本节我们我要实战的是<code>在Retrofit的请求主体中发送对象</code>，所以HTTP的请求方式很明显应该为<code>POST</code>,从Github中关于Gist的API<a href="https://developer.github.com/v3/gists/comments/" target="_blank" rel="external">https://developer.github.com/v3/gists/comments/</a>中，选取 <code>Create a comment</code> 创建一个评论作为我们的目标。</p>
<h3 id="3-1-创建评论"><a href="#3-1-创建评论" class="headerlink" title="3.1 创建评论"></a>3.1 创建评论</h3><p>API是这样： <code>POST /gists/:gist_id/comments</code><br>参数表：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>名称</strong></th>
<th style="text-align:center"><strong>类型</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">body</td>
<td style="text-align:center">string</td>
<td style="text-align:center">必需，评论内容</td>
</tr>
</tbody>
</table>
<p>这里这说明下，涉及到Github的API，所有请求的基本地址都是： <code>https://api.github.com</code>。地址中的:gist_id就是我们想要访问的gist的id，对本例就是<code>04793d3d5b53e43d2f6a71b7c3103ea4</code>。 下面我们来试试牛刀吧~</p>
<p>首先是Github请求客户端接口，<code>GistComment</code>为封装好的评论类，发出评论的方法<code>commentGist</code>使用POST方式，url中<code>{gist_id}</code>是动态的可以修改的Gist片段的id,<code>@Query(&quot;access_token&quot;)</code>则表示发表评论时所需要的token参数：</p>
<pre><code>public interface GithubClient {
    @POST(&quot;/gists/{gist_id}/comments&quot;)
    Call&lt;ResponseBody&gt; commentGist(
      @Path(&quot;gist_id&quot;) String gist_id,
      @Body GistComment comment,
      @Query(&quot;access_token&quot;) String token
    );

    class GistComment{
        String body;

        public GistComment(String body) {
            this.body = body;
        }
    }
}
</code></pre><p>在MainActivity中调用的代码如下所示：</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private final static String TAG = &quot;ILearnRetrofit&quot;;
    private final String Gist_id = &quot;04793d3d5b53e43d2f6a71b7c3103ea4&quot;;
    private final String Github_Token = &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Utils.init(this);

        GithubClient client = ServiceGenerator.createService(GithubClient.class);
        GithubClient.GistComment comment = new GithubClient.GistComment(&quot;这是Retrofit 2程序发出来的，发送人是orzangleli&quot;); // 可以把我的id orzangleli 修改成你自己的
        Call&lt;ResponseBody&gt; call = client.commentGist(Gist_id, comment, Github_Token);
        call.enqueue(new Callback&lt;ResponseBody&gt;() {
            @Override
            public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) {
                if (response.isSuccessful())
                    i(TAG, &quot;评论成功：&quot; + response.raw());
                else
                    i(TAG, &quot;评论失败：&quot; + response.errorBody());
            }

            @Override
            public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) {
                i(TAG, &quot;评论失败：&quot; + t.getMessage());
            }
        });

    }
}
</code></pre><p>代码中的Github_Token 需要换成你自己的，可以看这篇教程<strong>[Retrofit 2 番外篇]将Github作为Retrofit的测试对象</strong>,因为它只显示一次，所以记住将这个token保存在本地，以后的教程会经常用到这个token。</p>
<p>最后，你可以到<a href="https://gist.github.com/hust201010701/04793d3d5b53e43d2f6a71b7c3103ea4" target="_blank" rel="external">https://gist.github.com/hust201010701/04793d3d5b53e43d2f6a71b7c3103ea4</a>中看看，你的评论是否正常的发出了。</p>
<p>我的已经成功了：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-13_13_56_05_请求主体中发送对象.png" alt=""></p>
<blockquote>
<p>本教程所有源码参见此网页：[留白]</p>
</blockquote>
<p>Enjoy Coding! 如果在阅读本教程的过程中有任何疑问或者需要帮助，可以随时在微博上联系我，我的微博是 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzanglei</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;5-跟orzangleli一起学Retrofit2-第五篇-在Retrofit的请求主体中发送对象&quot;&gt;&lt;a href=&quot;#5-跟orzangleli一起学Retrofit2-第五篇-在Retrofit的请求主体中发送对象&quot; class=&quot;headerlink&quot; t
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第四篇__同步和异步请求</title>
    <link href="http://www.orzangleli.com/2017/01/12/2017-01-12_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E5%9B%9B%E7%AF%87__%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"/>
    <id>http://www.orzangleli.com/2017/01/12/2017-01-12_[跟orzangleli一起学Retrofit2]  第四篇__同步和异步请求/</id>
    <published>2017-01-12T04:00:00.000Z</published>
    <updated>2017-01-14T14:59:44.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-Retrofit-2的同步和异步请求"><a href="#4-Retrofit-2的同步和异步请求" class="headerlink" title="4. Retrofit 2的同步和异步请求"></a>4. Retrofit 2的同步和异步请求</h1><!-- MarkdownTOC -->
<ul>
<li><a href="#同步请求">同步请求</a></li>
<li><a href="#同步请求获取数据">同步请求获取数据</a></li>
<li><a href="#异步请求">异步请求</a></li>
<li><a href="#异步请求获取数据">异步请求获取数据</a></li>
<li><a href="#获取原始http响应数据">获取原始HTTP响应数据</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>之前的文章，我们带你学习了在web服务或者API请求中Retrofit要设置的东西。本文将给你展示如何通过同步或异步的方式完成真实的请求。</p>
<p>Retrofit支持同步和异步的方式执行请求。从使用者的观点来看，这两种方式的不同之处在于：</p>
<ul>
<li>同步——使用者通过单个线程调用服务；该线程发送请求，在服务运行时阻塞，并且等待响应。</li>
<li>异步——使用者通过两个线程调用服务；一个线程发送请求，而另一个单独的线程接收响应。</li>
</ul>
<h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><p>同步请求和异步请求在Retrofit 2中，在声明客户端（Client）的时候并没有区别，这与Retrofit 1.9不同，Retrofit 1.9是通过修改返回类型和方法参数来声明同步请求。</p>
<p>下面这个例子，当执行<code>getTasks</code> 时期望获取一组Task类型的链表。</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks();
}
</code></pre><p>在Retrofit 2中，每个请求都被一个<code>Call</code>对象包裹。实际上，同步或者异步请求是用后面创建的<code>call</code>对象使用特定的方法用不同方式执行的。但是，在定义接口上，Retrofit 2的同步请求和异步请求没有区别。</p>
<p>同步请求是执行在主线程上的。这就意味着UI线程会在请求执行的时候阻塞，在此期间，用户的交互操作无法响应。</p>
<blockquote>
<p>警告： 同步请求可能会导致Android 4.0+的系统的APP 的崩溃。将会产生<code>NetworkOnMainThreadException</code>错误。</p>
</blockquote>
<p>同步方法能够直接返回数据，因为网络请求操作阻塞了所有其他的操作。<br>对于非UI线程，你需要在自己建的单独线程中执行请求。这就意味着，你可以在等待网络响应的过程中继续与APP进行交互。</p>
<h2 id="同步请求获取数据"><a href="#同步请求获取数据" class="headerlink" title="同步请求获取数据"></a>同步请求获取数据</h2><p>现在来看看同步请求的实战操作。我们就假设你已经对前面几篇文章介绍的<code>ServiceGenerator</code>很熟悉了，下面的代码片段就阐述了同步请求的做法。</p>
<pre><code>TaskService taskService = ServiceGenerator.createService(TaskService.class);  
Call&lt;List&lt;Task&gt;&gt; call = taskService.getTasks();  
List&lt;Task&gt;&gt; tasks = call.execute().body(); 
</code></pre><p>Retrofit 2中通过<code>call</code>对象调用<code>.execute()</code>方法，将在执行同步请求。可以通过在响应对象上执行<code>.body()</code>方法获取反序列化的响应内容。</p>
<h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>除了同步请求，Retrofit对异步请求的支持也属于开箱即用（直白点就是用起来很简单）。Retrofit 2在定义接口上，同步和异步是没有区别的，这一点之前说过了。</p>
<pre><code>public interface TaskService {  
    @GET(&quot;/tasks&quot;)
    Call&lt;List&lt;Task&gt;&gt; getTasks();
}
</code></pre><p>异步请求中Retrofit 是在单独的线程中执行和处理网络请求的。一般来说使用<code>Callback</code>类，用它来映射你定义好的返回类型。我们的例子就是返回一组<code>Task</code>类型的链表，这一点在<code>Callback</code>内部就会自动映射好的。</p>
<h2 id="异步请求获取数据"><a href="#异步请求获取数据" class="headerlink" title="异步请求获取数据"></a>异步请求获取数据</h2><p>使用异步请求，你需要实现<code>Callback</code>的两个回调方法：<code>onResponse</code>和<code>onFailure</code>。当从服务类中调用异步请求<code>getTask()</code>方法时，你需要实现一个新的<code>Callback</code>接口，并且定义你需要在请求完成时要做的处理。下面的代码片段就简要说明了一个典型的实现方法。</p>
<pre><code>TaskService taskService = ServiceGenerator.createService(TaskService.class);  
Call&lt;List&lt;Task&gt;&gt; call = taskService.getTasks();  
call.enqueue(new Callback&lt;List&lt;Task&gt;&gt;() {  
    @Override
    public void onResponse(Call&lt;List&lt;Task&gt;&gt; call, Response&lt;List&lt;Task&gt;&gt; response) {
        if (response.isSuccessful()) {
            // 执行成功
        } else {
            // 响应错误，没有权限访问？
        }
    }

    @Override
    public void onFailure(Call&lt;List&lt;Task&gt;&gt; call, Throwable t) {
        // 出错了（如网络没有连接）
        Log.d(&quot;Error&quot;, t.getMessage());
    }
}
</code></pre><h2 id="获取原始HTTP响应数据"><a href="#获取原始HTTP响应数据" class="headerlink" title="获取原始HTTP响应数据"></a>获取原始HTTP响应数据</h2><p>在Retrofit 2中，获取原始响应数据的方式可以在异步的请求中获取。异步请求的回调方法<code>onResponse()</code>中可以获取<code>Response</code>类型的原始响应对象。具体看代码：</p>
<pre><code>call.enqueue(new Callback&lt;List&lt;Task&gt;&gt;() {  
    @Override
    public void onResponse(Call&lt;List&lt;Task&gt;&gt; call, Response&lt;List&lt;Task&gt;&gt; response) {
        // 获取原始响应对象
        Response raw = response.raw();
    }

    @Override
    public void onFailure(Call&lt;List&lt;Task&gt;&gt; call, Throwable t) {}
}
</code></pre><p>Happy coding! 如果你在阅读本教程中有任何困难或者需要帮助，随时可以在微博上联系我，我的微博是<a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzangleli</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;4-Retrofit-2的同步和异步请求&quot;&gt;&lt;a href=&quot;#4-Retrofit-2的同步和异步请求&quot; class=&quot;headerlink&quot; title=&quot;4. Retrofit 2的同步和异步请求&quot;&gt;&lt;/a&gt;4. Retrofit 2的同步和异步请求&lt;/h1
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第二篇__API描述的基础知识</title>
    <link href="http://www.orzangleli.com/2017/01/11/2017-01-11_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E4%BA%8C%E7%AF%87__API%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.orzangleli.com/2017/01/11/2017-01-11_[跟orzangleli一起学Retrofit2]  第二篇__API描述的基础知识/</id>
    <published>2017-01-11T04:30:00.000Z</published>
    <updated>2017-01-14T14:59:17.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-Retrofit-2-—API描述基础知识"><a href="#2-Retrofit-2-—API描述基础知识" class="headerlink" title="2. Retrofit 2 —API描述基础知识"></a>2. Retrofit 2 —API描述基础知识</h1><p><strong>目录</strong></p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#如何描述api">如何描述API</a><ul>
<li><a href="#http-请求方式">HTTP 请求方式</a></li>
<li><a href="#http资源位置">HTTP资源位置</a></li>
<li><a href="#方法名和返回类型">方法名和返回类型</a></li>
<li><a href="#路径参数">路径参数</a></li>
<li><a href="#查询参数">查询参数</a></li>
</ul>
</li>
<li><a href="#下节预告">下节预告</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>在上一节Retrofit入门教程中，你已经完成对Github网站的第一次请求了。希望你对Retrofit更多功能的试验仍保持热情。本节教程中你将学会Retrofit中描述API的更多细节。</p>
<h2 id="如何描述API"><a href="#如何描述API" class="headerlink" title="如何描述API"></a>如何描述API</h2><p>正如你第一节学到的，我们描述Retrofit所有的请求都是通过接口完成的。在第一个案例中，我们就展示一点点的功能，如下：</p>
<pre><code>public interface GitHubClient {  
    @GET(&quot;/users/{user}/repos&quot;)
    Call&lt;List&lt;GitHubRepo&gt;&gt; reposForUser(
        @Path(&quot;user&quot;) String user
    );
}
</code></pre><p>现在我们来具体看看这些配置项：</p>
<h3 id="HTTP-请求方式"><a href="#HTTP-请求方式" class="headerlink" title="HTTP 请求方式"></a>HTTP 请求方式</h3><p>看来你已经知道，我们在java接口的方法上使用注解来描述API.首先你要定义的是HTTP请求方式，如<code>GET</code> ,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>等。Retrofit为每一种标准的请求方式提供了一个注解。你可以想下面这样简单的方式使用Retrofit注解描述HTTP请求方式：</p>
<pre><code>@GET, @POST, @PUT, @DELETE, @PATCH, @HEAD.
</code></pre><p>你必须明确的支出这个API请求使用什么方式进行请求。如果你从来没有听过HTTP请求方式，，你可以看看这个网址 <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods" target="_blank" rel="external">HTTP维基百科</a> ，要是打不开就看看国内的吧:<a href="http://www.runoob.com/http/http-methods.html" target="_blank" rel="external">http://www.runoob.com/http/http-methods.html</a>。</p>
<p><code>@GET</code>, <code>@PUT</code> 和 <code>@DELETE</code>的使用简单例子：</p>
<pre><code>public interface FutureStudioClient {  
    @GET(&quot;/user/info&quot;)
    Call&lt;UserInfo&gt; getUserInfo();

    @PUT(&quot;/user/info&quot;)
    Call&lt;UserInfo&gt; updateUserInfo(
        @Body UserInfo userInfo
    );

    @DELETE(&quot;/user&quot;)
    Call&lt;Void&gt; deleteUser();
}
</code></pre><h3 id="HTTP资源位置"><a href="#HTTP资源位置" class="headerlink" title="HTTP资源位置"></a>HTTP资源位置</h3><p>你要把API中的相对地址作为String类型的参数传递给注解，例如<code>@GET(&quot;/user/info&quot;)</code>。<br>大部分情况，你只需要传递相对地址，而不是完整的地址（如<code>http://futurestud.io/api/user/info</code>）。这样做有一个优点，Retrofit只需要请求基本地址 （<code>http://futurestud.io</code>）一次就可以。如果你改变API的基本地址，你也只需要修改一次即可。除此之外，它还让实现一些高级的功能，如动态基本地址，变得更加容易。如果你想继续学些URL处理和怎么将基本地址和相对地址连接到一起的话，欢迎阅读我们的教程  <a href="https://futurestud.io/tutorials/retrofit-2-url-handling-resolution-and-parsing" target="_blank" rel="external">URL handling, resolution and parsing</a>.</p>
<p>我们再看个简单的例子：</p>
<pre><code>public interface FutureStudioClient {  
    @GET(&quot;/user/info&quot;)
    Call&lt;UserInfo&gt; getUserInfo();

    @PUT(&quot;/user/info&quot;)
    Call&lt;UserInfo&gt; updateUserInfo(
        @Body UserInfo userInfo
    );

    @DELETE(&quot;/user&quot;)
    Call&lt;Void&gt; deleteUser();

    // example for passing a full URL
    @GET(&quot;https://futurestud.io/tutorials/rss/&quot;)
    Call&lt;FutureStudioRssFeed&gt; getRssFeed();
}
</code></pre><h3 id="方法名和返回类型"><a href="#方法名和返回类型" class="headerlink" title="方法名和返回类型"></a>方法名和返回类型</h3><p>现在你应该知道HTTP请求方式注解是干什么用的了。可是，我们还没有提及Java方法声明：<code>Call&lt;UserInfo&gt; getUserInfo();</code> . 这里面涉及三个部分：</p>
<ol>
<li>方法名</li>
<li>方法返回类型</li>
<li>方法参数</li>
</ol>
<p>先从最简单的开始：方法名。你可以随意定义方法名，Retrofit并不在意，而且它对功能也不会产生影响。不过，你还是应该取一个能够帮助其他开发者理解你这个API是干嘛的名字。</p>
<p>方法的返回类型则颇为严格。你需要定义你想要从服务器获取什么样的数据。例如，当你请求用户信息的时候，你可能会把返回类型写成<code>Call&lt;UserInfo&gt;</code>。 <code>UserInfo</code> 这个类包含一些 带有用户数据的 变量。Retrofit会自动把服务器返回数据映射到UserInfo类的对象中，不需要手动解析。如果你想要原始响应数据，你可以在返回类型中使用<code>ResponseBody</code> 替代 <code>UserInfo</code> 。如果你不关心服务器的响应，你也可以直接使用<code>Void</code>。以上所有情形，都需要包裹在Retrofit的<code>Call&lt;&gt;</code>类中。</p>
<p>最后，也是主要决定API网址末端部分，你可以传递参数到方法中。这些参数有很多种，这里我们就列出一些出来：</p>
<ul>
<li><code>@Body</code>:把java对象当做请求主体发送出去</li>
<li><code>@Url</code>：使用动态地址</li>
<li><code>@Field</code>:以form-urlencoded格式发送数据</li>
</ul>
<p>再看看使用案例：</p>
<pre><code>public interface FutureStudioClient {  
    @GET(&quot;/user/info&quot;)
    Call&lt;UserInfo&gt; getUserInfo();

    @PUT(&quot;/user/info&quot;)
    Call&lt;Void&gt; updateUserInfo(
        @Body UserInfo userInfo
    );

    @GET
    Call&lt;ResponseBody&gt; getUserProfilePhoto(
        @Url String profilePhotoUrl
    );
}
</code></pre><p>因为路径和查询参数很普遍，所以我们会在接下来的两段中讲述它们。</p>
<h3 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h3><p>REST APIs 是建议在动态URL的基础上的（关于REST可进入<a href="http://kb.cnblogs.com/page/132129/" target="_blank" rel="external">http://kb.cnblogs.com/page/132129/</a>了解）。你可以通过替换部分URL地址访问资源，如，想要获得hust201010701的CouponView仓库的所有贡献者，可以访问<a href="https://api.github.com/repos/hust201010701/CouponView/contributors" target="_blank" rel="external">https://api.github.com/repos/hust201010701/CouponView/contributors</a>,其中<code>hust201010701/CouponView</code>就是明确你要访问谁的哪个仓库。Retrofit提供了一种简单的方式替换这些路径参数。你应该在入门指南的教程中看到过了吧。</p>
<pre><code>public interface GitHubClient {  
    @GET(&quot;/users/{user}/repos&quot;)
    Call&lt;List&lt;GitHubRepo&gt;&gt; reposForUser(
        @Path(&quot;user&quot;) String user
    );
}
</code></pre><p>这里<code>{user}</code>告诉Retrofit，这个值是动态的，当请求发出时会被设置进去。如果你要把一个路径参数放到URL中，你需要给方法的参数添加<code>@Path()</code>标记，<code>@Path</code>标记的值就会替换掉URL的占位符（本例中就是@Path(“user”)）。如果有必要，你可以使用多个占位符。只需要保证你匹配参数的总量。你还可以使用[optional path parameters]（<a href="https://futurestud.io/tutorials/retrofit-optional-path-parameters）。" target="_blank" rel="external">https://futurestud.io/tutorials/retrofit-optional-path-parameters）。</a></p>
<h3 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h3><p>动态URL另一大类就是查询参数。如果你之前使用过过滤器，你应该看过这个网站：<code>https://www.baidu.com/s?wd=123</code> . <code>?wd=123</code>就是一个查询参数，它表明你要搜索的内容,又例如<code>https://futurestud.io/tutorials?filter=video</code>中的<code>?filter=video</code>描述了请求的资源。。和路径参数不同，你不要把它们添加到注解的URL中。你可以很简单的使用<code>@Qurey</code>来添加一个方法的参数和名字。Retrofit会自动把它加到请求中去。如果你传递了<code>null</code>作为查询参数，Retrofit就会忽略这个参数。你可以添加 <a href="https://futurestud.io/tutorials/retrofit-2-add-multiple-query-parameter-with-querymap" target="_blank" rel="external">multiple query parameters</a>。</p>
<pre><code>public interface FutureStudioClient {  
    @GET(&quot;/tutorials&quot;)
    Call&lt;List&lt;Tutorial&gt;&gt; getTutorials(
        @Query(&quot;page&quot;) Integer page
    );

    @GET(&quot;/tutorials&quot;)
    Call&lt;List&lt;Tutorial&gt;&gt; getTutorials(
            @Query(&quot;page&quot;) Integer page,
            @Query(&quot;order&quot;) String order,
            @Query(&quot;author&quot;) String author,
            @Query(&quot;published_at&quot;) Date date
    );
}   
</code></pre><p>上面这个例子，使用第二个方法，后面三个参数的值都传递<code>null</code>，这样，你就可以移除第一个<code>getTutorials()</code>方法了。</p>
<h2 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h2><p>这只是一个描述API末端的介绍而已。目前你应该学会了怎么添加新的请求地址到你的接口上去了吧。你可以调整资源的位置，HTTP请求方式，返回类型，路径参数和查询参数。</p>
<p>Retrofit提供了很多选项去进一步修改请求。例如，我们还没有说到的headers(请求头)。接下来还有很多需要学，所以继续学习教程吧！</p>
<p>欢迎大家关注我的<a href="https://github.com/hust201010701" target="_blank" rel="external">Github</a> 和微博 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzangleli</a> 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2-Retrofit-2-—API描述基础知识&quot;&gt;&lt;a href=&quot;#2-Retrofit-2-—API描述基础知识&quot; class=&quot;headerlink&quot; title=&quot;2. Retrofit 2 —API描述基础知识&quot;&gt;&lt;/a&gt;2. Retrofit 2 —A
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第一篇_Retrofit入门指南及创建一个Android客户端</title>
    <link href="http://www.orzangleli.com/2017/01/11/2017-01-11_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E4%B8%80%E7%AF%87_Retrofit%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E5%8F%8A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAAndroid%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>http://www.orzangleli.com/2017/01/11/2017-01-11_[跟orzangleli一起学Retrofit2]  第一篇_Retrofit入门指南及创建一个Android客户端/</id>
    <published>2017-01-11T04:00:00.000Z</published>
    <updated>2017-01-14T14:59:44.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-跟orzangleli一起学Retrofit2-第一篇-Retrofit入门指南及创建一个Android客户端"><a href="#1-跟orzangleli一起学Retrofit2-第一篇-Retrofit入门指南及创建一个Android客户端" class="headerlink" title="1. [跟orzangleli一起学Retrofit2]  第一篇  Retrofit入门指南及创建一个Android客户端"></a>1. [跟orzangleli一起学Retrofit2]  第一篇  Retrofit入门指南及创建一个Android客户端</h1><blockquote>
<p>本系列文章是作者orzangleli基于<a href="https://futurestud.io/tutorials/retrofit-getting-started-and-android-client" target="_blank" rel="external">FutureStudio</a>中的教程经过亲自试验和修改，删除文章中关于1.9版本Retrofit的介绍，让初学者更加方便和清晰地学习Retrofit2.0，并对原文章中部分代码及API作了修改和补充，以达到正常试验效果。<br>本系列文章所有权归orzangleli.com所有，任何人有权转载，但需要标明出处。</p>
</blockquote>
<p>本文是Retrofit教程系列的第一篇。本系列通过使用一些案例深入了解Retrofit，并从功能和可扩展性的方面来测试Retrofit.</p>
<h2 id="跟orzangleli一起学Retrofit2-系列总览"><a href="#跟orzangleli一起学Retrofit2-系列总览" class="headerlink" title="[跟orzangleli一起学Retrofit2]系列总览"></a>[跟orzangleli一起学Retrofit2]系列总览</h2><ol>
<li>将Github作为Retrofit的测试对象</li>
<li>入门指南及创建一个Android客户端</li>
<li>API 基础</li>
<li>创建一个持久化的Android客户端</li>
<li>同步和异步请求</li>
<li>在Request Body中发送对象</li>
<li>添加自定义请求头</li>
<li>Retrofit 2——在OkHttp Interceptor中管理请求头</li>
</ol>
<p>本篇文章我们将一起学习Retrofit的基础知识，以及对API或者HTTP请求创建一个Android 客户端。</p>
<p>但是，这篇文章并没有涉及很多入门信息和也没有解释Retrofit究竟是什么。对于这些内容，请访问<a href="http://square.github.io/retrofit/" target="_blank" rel="external">projects homepage</a></p>
<h2 id="Retrofit是什么"><a href="#Retrofit是什么" class="headerlink" title="Retrofit是什么"></a>Retrofit是什么</h2><p>Retrofit官方主页这样描述它：</p>
<blockquote>
<p>A type-safe REST client for Android and Java.(Android和Java的类型安全的REST客户端)</p>
</blockquote>
<p>本系列中你将学会使用注解描述HTTP请求，URL参数的替换和查询参数。另外，Retrofit还提供对multipart请求主体和文件的上传功能。</p>
<h2 id="如何申明（API）请求"><a href="#如何申明（API）请求" class="headerlink" title="如何申明（API）请求"></a>如何申明（API）请求</h2><p>请访问阅读<a href="http://square.github.io/retrofit/#api-declaration" target="_blank" rel="external">Retrofit homepage</a>中API申明部分，好好理解如何构造请求。你将会找到所有重要的信息，而且他们都有着很详细的代码描述。</p>
<h2 id="Android项目的准备工作"><a href="#Android项目的准备工作" class="headerlink" title="Android项目的准备工作"></a>Android项目的准备工作</h2><p>现在我们言归正传，如果你已经创建了你的Android项目，直接从下一段开始吧。如果没有，请先在你最新最喜欢的IDE中创建一个项目。我们喜欢使用Gradle作为构建系统，但是你也可以使用Maven.</p>
<h3 id="申明依赖项：Gradle或者Maven"><a href="#申明依赖项：Gradle或者Maven" class="headerlink" title="申明依赖项：Gradle或者Maven"></a>申明依赖项：Gradle或者Maven</h3><p>现在我们把Retrofit添加到你项目的依赖项中。选择你使用的构建系统，在pom.xml或build.gradle中定义Retrofit及其依赖项。当运行命令构建你的代码时，构建系统则会为你的项目自动下载Retrofit库。我们建议将OkHttp配合Retrofit使用，OkHttp还对Okio有依赖性，所以Okio也需要声明依赖性。</p>
<h4 id="Retrofit-1-9"><a href="#Retrofit-1-9" class="headerlink" title="Retrofit 1.9"></a><strong>Retrofit 1.9</strong></h4><p>本系列译文仅讲述Retrofit2.0,若需要了解之前的版本，请查看<a href="https://futurestud.io/tutorials/retrofit-getting-started-and-android-client" target="_blank" rel="external">英文原版</a>文章。</p>
<h4 id="Retrofit-2"><a href="#Retrofit-2" class="headerlink" title="Retrofit 2"></a><strong>Retrofit 2</strong></h4><p><strong>pom.xml</strong></p>
<pre><code>&lt;dependency&gt;  
    &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt;
    &lt;artifactId&gt;retrofit&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;  
&lt;dependency&gt;  
    &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt;
    &lt;artifactId&gt;converter-gson&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p><strong>build.gradle</strong></p>
<pre><code>dependencies {  
    // Retrofit &amp; OkHttp
    compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos;
    compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos;
}
</code></pre><p>Retrofit 2默认使用OkHttp作为网络层，而且OkHttp也内置到Retrofit2中了，所以你是用OkHttp时不需要在项目中再次声明依赖项了，除非你对OkHttp的版本有特殊要求。（译者注：Retrofit，OkHttp,Okio都是Square公司出品的）</p>
<p>现在，你的项目已经准备好整合Retrofit了，我们一起来创建一个持久的Android API/HTTP 客户端吧~</p>
<h2 id="持久的Android-客户端"><a href="#持久的Android-客户端" class="headerlink" title="持久的Android 客户端"></a>持久的Android 客户端</h2><p>在对已经存在的Retrofit客户端的研究中，发现了<a href="https://github.com/bkiers/retrofit-oauth/tree/master/src/main/java/nl/bigo/retrofitoauth" target="_blank" rel="external">example repository of Bart Kiers</a>.实际上，这是个使用Retrofit进行OAuth认证的案例。但是，它提供一个可持久化Android客户端的所有必需的基本知识。这就是为什么我们以后会把它作为坚实基础，并且在以后需要使用认证的文章中拿它来扩展。</p>
<p>下面的类定义了我们的android 客户端的基本信息：<strong>ServiceGenerator</strong></p>
<h3 id="ServiceGenerator"><a href="#ServiceGenerator" class="headerlink" title="ServiceGenerator"></a>ServiceGenerator</h3><p><strong>ServiceGenerator</strong>就是我们的API/HTTP客户端的核心，目前来说，它只是定义了一个为给定类和接口创建REST适配器的方法。代码如下：</p>
<pre><code>public class ServiceGenerator {

    public static final String API_BASE_URL = &quot;http://your.api-base.url&quot;;

    private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder();

    private static Retrofit.Builder builder =
            new Retrofit.Builder()
                    .baseUrl(API_BASE_URL)
                    .addConverterFactory(GsonConverterFactory.create());

    public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass) {
        Retrofit retrofit = builder.client(httpClient.build()).build();
        return retrofit.create(serviceClass);
    }
}
</code></pre><p>这个 <code>ServiceGenerator</code> 类使用Retrofit的<code>RestAdapter</code>来创建一个新的带有基本API地址（base URL）的REST客户端.例如，Github的API基本地址是：<code>https://api.github.com/</code>。<code>serviceClass</code>指的是对API请求有注解的类或者接口。以下部分展示Retrofit的具体使用以及如何定义一个典型的客户端。</p>
<h2 id="JSON-映射"><a href="#JSON-映射" class="headerlink" title="JSON 映射"></a>JSON 映射</h2><p>Retrofit 1.9 默认使用的是Google的Gson库。你所需要做的事就是定义你的响应对象的类，响应数据会自动被映射的。</p>
<p>使用Retrofit2时，你需要明确地为Retrofit指定一个解析器。例如前面，我们已经添加了下面这行代码到<code>build.gradle</code>文件，导入Gson 解析器到Retrofit2中。</p>
<pre><code>compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos;  
</code></pre><p>现在你需要添加你的解析器到Retrofit对象中。在Retrofit的builder中调用<code>.addConverterFactory(GsonConverterFactory.create())</code>整合Gson作为默认Json解析器。</p>
<h2 id="使用Retrofit"><a href="#使用Retrofit" class="headerlink" title="使用Retrofit"></a>使用Retrofit</h2><p>好，我们器来看一个例子，定义一个REST客户端，从Github上请求数据。首先，我们得创建一个接口，定义一些需要的方法。</p>
<h3 id="Github客户端"><a href="#Github客户端" class="headerlink" title="Github客户端"></a>Github客户端</h3><p>下面的代码定义了<code>GithubClient</code>接口，里面有一个方法请求获取某一个repository（仓库）的所有contributors（贡献者）。它还举例说明了Retrofit的参数替换功能的使用，当请求方法<code>contributors</code>时，会把GET注解参数中{owner} 和 {repo} 替换成给定的变量。</p>
<pre><code>public interface GitHubClient {  
    @GET(&quot;/repos/{owner}/{repo}/contributors&quot;)
    Call&lt;List&lt;Contributor&gt;&gt; contributors(
        @Path(&quot;owner&quot;) String owner,
        @Path(&quot;repo&quot;) String repo
    );
}
</code></pre><p>这里有一个<code>Contributor</code>类，这个类包含一些需要的，对应响应数据中的属性。</p>
<pre><code>static class Contributor {  
    String login;
    int contributions;
}
</code></pre><p>完整代码如下：</p>
<pre><code>public interface GitHubClient {  
    @GET(&quot;/repos/{owner}/{repo}/contributors&quot;)
    Call&lt;List&lt;Contributor&gt;&gt; contributors(
        @Path(&quot;owner&quot;) String owner,
        @Path(&quot;repo&quot;) String repo
    );
    static class Contributor {  
        String login;
        int contributions;
    }
}
</code></pre><p>关于前面提到的JSON映射：<code>GitHubClient</code>中定义了一个叫<code>contributors</code>的方法，返回值类型是<code>Call&lt;List&lt;Contributor&gt;&gt;</code>。Retrofit确保服务响应映射正确。</p>
<p><strong>译者注：</strong><code>Contributor</code>中定义的字段并不能随意命名，需要根据服务器返回的json格式的数据做出对应的调整。因为基本地址是：<a href="https://api.github.com/" target="_blank" rel="external">https://api.github.com/</a>，我们手动补全获取所有贡献者的API地址，以我的<a href="https://github.com/hust201010701/CouponView/" target="_blank" rel="external">CouponView</a>为例，完整的请求地址是 <a href="https://api.github.com/repos/hust201010701/CouponView/contributors" target="_blank" rel="external">https://api.github.com/repos/hust201010701/CouponView/contributors</a>.我们通过观察返回数据（如下图所示），选取其中的login和contributions作为我们想提取的数据，当然你可以自己再添加其他的关键字。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-11_22_00_28_github_contributors.png" alt=""></p>
<h2 id="API请求案例"><a href="#API请求案例" class="headerlink" title="API请求案例"></a>API请求案例</h2><p>下面这一段举例说明了使用<code>ServiceGenerator</code>初始化你的客户端，具体指的就是Github客户端，用创建的这个客户端获取仓库的贡献者。这个片段修改自<a href="https://github.com/square/retrofit/tree/master/samples/src/main/java/com/example/retrofit" target="_blank" rel="external">Retrofit github-client example</a>。</p>
<p>你需要手动在<code>ServiceGenerator</code>中定义基本地址为<code>https://api.github.com/</code>，你还可以在<code>ServiceGenerator</code>中再创建一个包含两个参数的<code>createService()</code>，这两个参数分别是客户端类和基本地址。</p>
<p>首先你需要在AndroidManifest.xml中声明权限（有些权限是以后会用到的）：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;
&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;&gt;&lt;/uses-permission&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;
</code></pre><p>如果你是android 6.0以上系统，还需要在java代码中申请权限，相关代码请自行搜索：<code>Android6.0 申请读写权限</code></p>
<p>在MainActivity中增加以下代码：</p>
<pre><code>new Thread(new Runnable(){
            @Override
            public void run() {

                GithubClient client = ServiceGenerator.createService(GithubClient.class);
                Call&lt;List&lt;GithubClient.Contributor&gt;&gt; call= client.contributors(&quot;square&quot;,&quot;retrofit&quot;);

                contributors = new ArrayList&lt;GithubClient.Contributor&gt;();

                try {
                    contributors = call.execute().body();
                } catch (IOException e) {
                    e.printStackTrace();
                }

                for(GithubClient.Contributor contributor : contributors)
                {
                    i(contributor.login+&quot;(&quot;+contributor.contributions+&quot;)&quot;);
                }

            }
        }).start();
</code></pre><h2 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h2><p>下一篇文章我们将学习如何使用Retrofit实现基本的认证。我们将给出程序案例，实现带有用户名、邮箱、密码等的web服务或API的认证。进一步地，后面的文章会介绍带token的API认证（包括OAuth）。</p>
<p>希望你能喜欢这个系列的文章。</p>
<p>本文是由orzangleli翻译，原文地址：<a href="https://futurestud.io/tutorials/retrofit-getting-started-and-android-client" target="_blank" rel="external">Getting Started and Creating an Android Client</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-跟orzangleli一起学Retrofit2-第一篇-Retrofit入门指南及创建一个Android客户端&quot;&gt;&lt;a href=&quot;#1-跟orzangleli一起学Retrofit2-第一篇-Retrofit入门指南及创建一个Android客户端&quot; clas
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>第零篇_将Github作为Retrofit的测试对象</title>
    <link href="http://www.orzangleli.com/2017/01/10/2017-01-10_%5B%E8%B7%9Forzangleli%E4%B8%80%E8%B5%B7%E5%AD%A6Retrofit2%5D%20%20%E7%AC%AC%E9%9B%B6%E7%AF%87_%E5%B0%86Github%E4%BD%9C%E4%B8%BARetrofit%E7%9A%84%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.orzangleli.com/2017/01/10/2017-01-10_[跟orzangleli一起学Retrofit2]  第零篇_将Github作为Retrofit的测试对象/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2017-01-14T14:56:59.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Retrofit-2-番外篇-将Github作为Retrofit的测试对象"><a href="#Retrofit-2-番外篇-将Github作为Retrofit的测试对象" class="headerlink" title="[Retrofit 2 番外篇]将Github作为Retrofit的测试对象"></a>[Retrofit 2 番外篇]将Github作为Retrofit的测试对象</h1><p><strong>目录</strong><br><!-- MarkdownTOC --></p>
<ul>
<li><a href="#一、-申请认证token">一、 申请认证token</a></li>
<li><a href="#二、-准备原始数据">二、 准备原始数据</a><ul>
<li><a href="#21-创建你的第一个仓库">2.1 创建你的第一个仓库</a></li>
<li><a href="#22-关注一些人">2.2 关注一些人</a></li>
<li><a href="#23-创建issues">2.3 创建Issues</a></li>
<li><a href="#24-star-自己的仓库">2.4 Star 自己的仓库</a></li>
</ul>
</li>
<li><a href="#三、-github-api大全">三、 Github API大全</a></li>
<li><a href="#四、-善后工作">四、 善后工作</a></li>
</ul>
<!-- /MarkdownTOC -->
<p>本文将阐述，将Github作为Retrofit 2学习时的测试对象要做的准备工作。因为在<strong>[跟orzangleli一起学Retrofit2]</strong>这个教程中，译者将全部使用Github中的API进行测试实验。</p>
<h2 id="一、-申请认证token"><a href="#一、-申请认证token" class="headerlink" title="一、 申请认证token"></a>一、 申请认证token</h2><p>因为Github中的部分API是需要认证的，Github中认证有多种方式，但是token认证较为方便，所以选择token认证。我们到<a href="https://github.com/settings/tokens" target="_blank" rel="external">这个网页</a>获取token,我建议你新建一个全新的token,命名为RetrofitTest,然后勾上所有的权限，最后点击生成,然后你可以看到一串字符串，这个字符串就是token,将它保存在一个你可以随时找到的位置，<strong>因为这个token只会显示一次，以后在找就找不到了。</strong></p>
<h2 id="二、-准备原始数据"><a href="#二、-准备原始数据" class="headerlink" title="二、 准备原始数据"></a>二、 准备原始数据</h2><h3 id="2-1-创建你的第一个仓库"><a href="#2-1-创建你的第一个仓库" class="headerlink" title="2.1 创建你的第一个仓库"></a>2.1 创建你的第一个仓库</h3><p>如果你之前创建过仓库可以不用再看这一段。</p>
<p>如图所示，新建一个仓库，命名为RetrofitTest。<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-13_10_59_43_创建仓库.png" alt=""></p>
<h3 id="2-2-关注一些人"><a href="#2-2-关注一些人" class="headerlink" title="2.2 关注一些人"></a>2.2 关注一些人</h3><p>因为后面的教程中，会有关于Following API的测试，我们建议你关注一些人。当然我希望你能够关注我的Github:<a href="https://github.com/hust201010701" target="_blank" rel="external">@hust201010701</a>,这里我还推荐一些大牛的Github:</p>
<ul>
<li><a href="https://github.com/hust201010701" target="_blank" rel="external">@hust201010701</a> : 本教程译者（非大牛，正在朝大牛方向努力）</li>
<li><a href="https://github.com/JakeWharton" target="_blank" rel="external">JakeWharton</a>: Square Inc.的大牛</li>
<li><a href="https://github.com/hongyangAndroid" target="_blank" rel="external">hongyangAndroid</a>: 鸿洋</li>
<li><a href="https://github.com/kymjs" target="_blank" rel="external">kymjs</a>: 张涛-开源实验室</li>
</ul>
<h3 id="2-3-创建Issues"><a href="#2-3-创建Issues" class="headerlink" title="2.3 创建Issues"></a>2.3 创建Issues</h3><p>找到自己刚刚创建的RetrofitTest仓库，然后如图所示，创建一个Issue,Issue的标题可以和图中一样，方便标识，Issue的内容可以自由发挥，随意填写。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-13_11_24_03_创建Issue.png" alt=""></p>
<h3 id="2-4-Star-自己的仓库"><a href="#2-4-Star-自己的仓库" class="headerlink" title="2.4 Star 自己的仓库"></a>2.4 Star 自己的仓库</h3><p>在进入RetrofitTest仓库详情页时，右上方的Star按钮，可以自己点一下，这样就相当于自己粉了自己的项目。这样我们以后通过API获取关注者时就不会返回空数据了。</p>
<h2 id="三、-Github-API大全"><a href="#三、-Github-API大全" class="headerlink" title="三、 Github API大全"></a>三、 Github API大全</h2><p>Github的所有API可以从<a href="https://api.github.com/" target="_blank" rel="external">https://api.github.com/</a>获取到。</p>
<p>另外，<a href="https://developer.github.com/v3/" target="_blank" rel="external">Github开发者页</a>也对Github的API有详细的描述，有兴趣的可以自己深入研究。</p>
<h2 id="四、-善后工作"><a href="#四、-善后工作" class="headerlink" title="四、 善后工作"></a>四、 善后工作</h2><p>本教程如果学习完了，你又不想让Github中的仓库有任何风险，你可以自行进入<a href="https://github.com/settings/tokens" target="_blank" rel="external">https://github.com/settings/tokens</a>删除之前创建的RetrofitTest token。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Retrofit-2-番外篇-将Github作为Retrofit的测试对象&quot;&gt;&lt;a href=&quot;#Retrofit-2-番外篇-将Github作为Retrofit的测试对象&quot; class=&quot;headerlink&quot; title=&quot;[Retrofit 2 番外篇]将G
    
    </summary>
    
      <category term="Retrofit教程" scheme="http://www.orzangleli.com/categories/Retrofit%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="android" scheme="http://www.orzangleli.com/tags/android/"/>
    
      <category term="Retrofit" scheme="http://www.orzangleli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Python节日倒计时软件</title>
    <link href="http://www.orzangleli.com/2017/01/07/2017-01-07_Python%E8%8A%82%E6%97%A5%E5%80%92%E8%AE%A1%E6%97%B6%E8%BD%AF%E4%BB%B6/"/>
    <id>http://www.orzangleli.com/2017/01/07/2017-01-07_Python节日倒计时软件/</id>
    <published>2017-01-06T16:00:00.000Z</published>
    <updated>2017-01-10T14:12:03.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-节日倒计时软件制作"><a href="#Python-节日倒计时软件制作" class="headerlink" title="Python 节日倒计时软件制作"></a>Python 节日倒计时软件制作</h1><h2 id="一-项目描述"><a href="#一-项目描述" class="headerlink" title="一. 项目描述"></a>一. 项目描述</h2><p>本次项目以Python3 作为编程语言，制作一款能够倒计时节日的图形化软件。</p>
<h3 id="1-1-项目动机"><a href="#1-1-项目动机" class="headerlink" title="1.1 项目动机"></a>1.1 项目动机</h3><p>本次项目的开发动机是：</p>
<blockquote>
<p>我想做一个类似于微博上 <a href="http://weibo.com/p/1005052493180882/home?profile_ftype=1&amp;is_all=1#_0" target="_blank" rel="external">@古城钟楼</a> 的报时程序，只是我报的时间是节日的倒计时，还想加上 “历史上的今天” 的功能。我关注的一个博主 <a href="http://weibo.com/xinlangwx?refer_flag=1001030101_" target="_blank" rel="external">@新浪无锡</a> 这位小编也会做一个倒计时的话题的微博，我问他是怎么做的，他跟我说他是数出来的，然后我就想帮帮他并且自己也练习练习，于是就想着开发一款这样的软件。<br>同时，也欢迎大家关注我的微博 <a href="http://weibo.com/androidjiqiaogonglue" target="_blank" rel="external">@orzangleli</a></p>
</blockquote>
<h3 id="1-2-知识点"><a href="#1-2-知识点" class="headerlink" title="1.2 知识点"></a>1.2 知识点</h3><ol>
<li>PyQt5库</li>
<li>requests库</li>
<li>datetime库</li>
<li>BeautifulSoup库</li>
</ol>
<h3 id="1-3-效果截图"><a href="#1-3-效果截图" class="headerlink" title="1.3 效果截图"></a>1.3 效果截图</h3><p>默认选中最近一个月的所有传统节日和24节气。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-07_17_26_01_daojishi.png" alt=""></p>
<h2 id="二、附加依赖安装"><a href="#二、附加依赖安装" class="headerlink" title="二、附加依赖安装"></a>二、附加依赖安装</h2><h3 id="2-1-PyQt安装"><a href="#2-1-PyQt安装" class="headerlink" title="2.1 PyQt安装"></a>2.1 PyQt安装</h3><p>Qt 是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱。也可用于开发非GUI程序，比如控制台工具和服务器。</p>
<p>参考：<a href="https://zh.wikipedia.org/wiki/Qt" target="_blank" rel="external">wiki–Qt</a></p>
<h4 id="2-1-1-Windows平台"><a href="#2-1-1-Windows平台" class="headerlink" title="2.1.1 Windows平台"></a>2.1.1 Windows平台</h4><p>首先下载PyQt5,注意不要下载最新版v5.7.1，最新版目前只有源码，没有可执行(exe)安装包，推荐安装和我相同的版本。进入<a href="https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/" target="_blank" rel="external">https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/</a> 下载 PyQt GPL v5.4.1 for Pythonv3.4(x64) 。注意到底是下载x86还是x64请根据自己系统的位数决定，这里需要注意的是：<strong>Python版本的位数需要跟系统保持一致，也就是如果你是64位系统，请一定要安装64位的Python</strong></p>
<p>关于Python版本：</p>
<p>我之前使用的是Python3.5，然后知道引用pyqt库时会一直出错，最后发现Python3.5和PyQt5好像是不兼容的，因为从上面的链接<a href="https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/" target="_blank" rel="external">https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4.1/</a>，打开网址就可以看到，人家只适配了Python 3.4版本的，所以乖乖的降级使用吧~</p>
<h4 id="2-1-2-Linux平台"><a href="#2-1-2-Linux平台" class="headerlink" title="2.1.2 Linux平台"></a>2.1.2 Linux平台</h4><p>如果 Linux 中默认的 python 3 为 3.5 版本，可以通过以下指令切换到 3.4 。</p>
<pre><code>$ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.4 70 --slave /usr/bin/python3m python3m /usr/bin/python3.4m
</code></pre><p>安装 PyQt5 。</p>
<pre><code>$ sudo apt-get install python3-pyqt5
</code></pre><p>安装完成之后，立马进入 Python 命令行交互界面测试是否正确安装。</p>
<pre><code>&gt;&gt;&gt; import PyQt5
</code></pre><p>如果执行以上的命令没有任何提示，说明成功安装。</p>
<h3 id="2-2-requests库安装"><a href="#2-2-requests库安装" class="headerlink" title="2.2 requests库安装"></a>2.2 requests库安装</h3><p>在cmd命令行中输入 <code>pip install requests</code></p>
<h3 id="2-3-datetime库"><a href="#2-3-datetime库" class="headerlink" title="2.3 datetime库"></a>2.3 datetime库</h3><p>datetime库不用安装，是Python自带的</p>
<h3 id="2-4-BeautifulSoup库"><a href="#2-4-BeautifulSoup库" class="headerlink" title="2.4 BeautifulSoup库"></a>2.4 BeautifulSoup库</h3><pre><code>pip install bs4
</code></pre><h2 id="三、编程实现"><a href="#三、编程实现" class="headerlink" title="三、编程实现"></a>三、编程实现</h2><h3 id="3-1-datetime使用"><a href="#3-1-datetime使用" class="headerlink" title="3.1 datetime使用"></a>3.1 datetime使用</h3><p>因为要计算倒计时，所以需要知道今天的日期，而且要计算两个日期之前有多少天。</p>
<p><strong>获取当前时间</strong></p>
<pre><code>from datetime import date
now = date.today()
print(now.strftime(&quot;%Y-%m-%d&quot;))
</code></pre><p><strong>获取日期差</strong></p>
<pre><code>from datetime import date
now = date.today()
chunjie = date(2017,1,28)  #春节的日期
chazhi = chunjie - now     #相差时间
print(chazhi.days)         #只需要知道相差时间的天数
</code></pre><p>现在只要的datetime的这两个用法就够了，其他的如果有兴趣可以去 <a href="http://www.wklken.me/posts/2015/03/03/python-base-datetime.html#1-datetime" target="_blank" rel="external">这里</a> 查看。</p>
<h3 id="3-2-requests库"><a href="#3-2-requests库" class="headerlink" title="3.2 requests库"></a>3.2 requests库</h3><p>因为我们要计算节日倒计时必须要知道今年哪些天是节日，而且节日数目比较多，程序员总不能一个个地手动添加到程序中吧，所以我们选择一个可以看到全年节日的网站<a href="http://tools.2345.com/jieri.htm" target="_blank" rel="external">http://tools.2345.com/jieri.htm</a> ，别看2345流氓软件一大堆，2345实用查询还是有点用的。</p>
<p>首先准备一个节日的Entity 类</p>
<pre><code>from datetime import date


class DayEntity(object):
    def __init__(self,dateStr,festival,type):
        self.dateStr = &quot;2017/&quot;+dateStr
        self.year = int(self.dateStr.split(&quot;/&quot;)[0])
        self.month = int(self.dateStr.split(&quot;/&quot;)[1])
        self.day = int(self.dateStr.split(&quot;/&quot;)[2])
        self.festival = festival
        self.type = type

    def getDate(self):
        d = date(self.year,self.month,self.day)
        return d

    def getDateString(self):
        return str(self.year)+&quot;年&quot;+str(self.month)+&quot;月&quot;+str(self.day)+&quot;日&quot;

    def getFestival(self):
        return self.festival

    def getType(self):
        return self.type
</code></pre><p>添加所有的节日，包括最后添加高考和考研日期</p>
<pre><code>result = requests.get(&quot;http://tools.2345.com/jieri.htm&quot;)
html_data = result.content.decode(&quot;gb2312&quot;)
soup = BeautifulSoup(html_data,&quot;html5lib&quot;)
year = soup.find(&quot;div&quot;,class_ = &quot;jieri&quot;)
clearfix = year.find_all(&quot;dl&quot;,class_=&quot;clearfix&quot;)
allFestival = list()

for month in clearfix:
    days = month.find(&quot;dd&quot;).find(&quot;ul&quot;).find_all(&quot;li&quot;)
    for day in days:
        a_tag = day.find(&quot;a&quot;)
        type = &quot;中国传统节日&quot;
        if &quot;cRed&quot; in str(a_tag[&quot;class&quot;]):
            type = &quot;中国传统节日&quot;
        elif &quot;cGreen&quot; in str(a_tag[&quot;class&quot;]):
            type = &quot;公众 / 国际节日&quot;
        elif &quot;cBlue&quot; in str(a_tag[&quot;class&quot;]):
            type = &quot;24节气&quot;
        else:
            type = &quot;中国传统节日&quot;
        dayEntity = DayEntity(day.text.split(&quot;[&quot;)[1][:-1],day.text.split(&quot;[&quot;)[0],type)
        allFestival.append(dayEntity)

allFestival.append(DayEntity(&quot;6/7&quot;,&quot;2017高考&quot;,&quot;中国传统节日&quot;))
allFestival.append(DayEntity(&quot;12/24&quot;, &quot;2017考研&quot;, &quot;中国传统节日&quot;))
</code></pre><h3 id="3-3-Qt界面"><a href="#3-3-Qt界面" class="headerlink" title="3.3 Qt界面"></a>3.3 Qt界面</h3><p>最终要做出来的程序是需要有界面的，而不是终端中显示结果，所以需要使用Qt进行界面设计。</p>
<h4 id="3-3-1-Pycharm中PyQt5的配置"><a href="#3-3-1-Pycharm中PyQt5的配置" class="headerlink" title="3.3.1 Pycharm中PyQt5的配置"></a>3.3.1 Pycharm中PyQt5的配置</h4><p>主要是添加三个External Tool,具体添加教程可以参考 <a href="http://blog.csdn.net/a359680405/article/details/45074761" target="_blank" rel="external">http://blog.csdn.net/a359680405/article/details/45074761</a></p>
<h4 id="3-3-2-使用QtDesigner-设计界面"><a href="#3-3-2-使用QtDesigner-设计界面" class="headerlink" title="3.3.2 使用QtDesigner 设计界面"></a>3.3.2 使用QtDesigner 设计界面</h4><p>在项目名上右键选择external tool打开<code>qtdesiginer</code> .</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_14_55_39_qtdesigner.png" alt=""></p>
<p> 这是图形化设计界面的工具，可以直接在窗口中拖动控件，并会保存为.ui格式。如图所示，设计界面。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_14_58_33_jiemian.png" alt=""></p>
<p>对象结构如下所示：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_14_57_44_jiegou.png" alt=""></p>
<p>保存文件，生成的文件形如 <code>window.ui</code> .</p>
<h4 id="3-3-3-使用QtDesigner-设计界面"><a href="#3-3-3-使用QtDesigner-设计界面" class="headerlink" title="3.3.3 使用QtDesigner 设计界面"></a>3.3.3 使用QtDesigner 设计界面</h4><p>在生成的 <code>window.ui</code> 上右键，选择external tool中的PyUIC,然后会自动生成window.py文件，打开后可以看到，里面是UI的程序。</p>
<h4 id="3-3-4-打包资源"><a href="#3-3-4-打包资源" class="headerlink" title="3.3.4 打包资源"></a>3.3.4 打包资源</h4><p>需要注意的是，如果程序中使用到了图片资源，虽然可以直接引用图片的资源文件，如下面的代码：</p>
<pre><code>self.buttonList[i].setStyleSheet(&quot;background-image:url(checked.png)&quot;)
</code></pre><p><code>checked.png</code> 是放在项目根目录下的一个图片资源，直接运行是没有问题的，但是如果打包程序，在生成的dist文件夹中只有exe文件，并没有<code>checked.png</code>资源，运行就会没有效果甚至出错，当然你可以把图片复制到dist文件中，但是如果图片很多呢？而且也不便于传播，一个完整exe程序，双击打开就能用是最好的。</p>
<p>所以就需要使用qt的资源包，在qtdesigner中右下角的资源浏览器中，点击“铅笔”图标，添加资源文件。然后点击新建资源文件（弹出的对话框中有6个图标，第一个是新建资源文件），然后点击添加新前缀，取个名字如button,然后选中刚刚新建的button这个前缀，添加文件（倒数第二个图标），这样把需要用到的图标添加进去，可以自己根据需要调整分类。添加好之后的资源文件形如下图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2017-01-09_15_12_14_ziyuan.png" alt=""></p>
<h4 id="3-3-5-显示窗口"><a href="#3-3-5-显示窗口" class="headerlink" title="3.3.5 显示窗口"></a>3.3.5 显示窗口</h4><p>在主入口文件中 定义一个窗口类。</p>
<pre><code>class MainWindow(QMainWindow):
    def __init__(self,allFestival,parent = None):
        QMainWindow.__init__(self,parent)
        self.ui = Ui_mainWindow()
        self.ui.setupUi(self)
        self.ui.setFestivalList(allFestival)
        for festival in allFestival:
            text = festival.getFestival()+&quot;\n&quot;+festival.getDateString()
            left_date = festival.getDate() - now
            if left_date.days &gt; 0  and left_date.days &lt; 30 and festival.getType() != &quot;公众 / 国际节日&quot;:
                self.ui.addWidgetIntoGridLayout(text,True)
            else:
                self.ui.addWidgetIntoGridLayout(text, False)

app = QApplication(sys.argv)
mainWindow = MainWindow(allFestival)
mainWindow.show()
app.exec_()
</code></pre><p>其中addWidgetIntoGridLayout是我自己在Window.py中添加的一个函数，主要目的是动态添加一个按钮到GridLayout中</p>
<pre><code>def addWidgetIntoGridLayout(self,text,state):
    button = QtWidgets.QPushButton(text)

    if self.currentColumn &lt; self.maxColumn - 1:
        self.currentColumn = self.currentColumn + 1
    else:
        self.currentRow = self.currentRow + 1
        self.currentColumn = 0
    if state:
        button.setStyleSheet(&quot;background-image:url(:checkbox/checked.png)&quot;)
    else:
        button.setStyleSheet(&quot;background-image:none&quot;)
    button.setObjectName(str(self.currentRow*self.maxColumn + self.currentColumn))
    button.clicked.connect(lambda: self.changeState(int(button.objectName())))
    self.buttonList.append(button)
    self.gridLayout.addWidget(button, self.currentRow, self.currentColumn)
    self.stateList.append(state)
</code></pre><h4 id="3-3-6-统计倒计时结果"><a href="#3-3-6-统计倒计时结果" class="headerlink" title="3.3.6 统计倒计时结果"></a>3.3.6 统计倒计时结果</h4><p>程序中使用了一个list来保存GridLayout中所有的按钮的状态，点击一次按钮时为选中状态，再点击一次就会变成非选中状态。<br>还是用了一个festivalList保存所有的节日信息。<br>点击计算倒计时按钮的时候，就会遍历这个list,如果button为选中状态，那么根据按钮的下标在festivalList查询中查询节日信息，从而计算倒计时时间，具体代码：</p>
<pre><code>def calculate(self):
    now = date.today()
    flag = True
    resultStr = &quot;今天是&quot;+str(now.year)+&quot;年&quot;+str(now.month)+&quot;月&quot;+str(now.day)+&quot;日，星期&quot;+self.getChineseStr(now.weekday())+&quot;。今天&quot;
    for i in range(len(self.stateList)):
        if self.stateList[i]:
            festival = self.festivalList[i]
            resultStr += &quot;距%s还有%d天,&quot;%(festival.getFestival(),(festival.getDate() - now).days)
        if now == self.festivalList[i].getDate() and flag:
            resultStr = &quot;今天是&quot; + str(now.year) + &quot;年&quot; + str(now.month) + &quot;月&quot; + str(
                now.day) + &quot;日，星期&quot; + self.getChineseStr(now.weekday()) + &quot;。今天是&quot;+self.festivalList[i].getFestival()+&quot;。今天&quot;
            flag = False
    resultStr = resultStr[:-1]+&quot;。&quot;
    self.textEdit.clear()
    self.textEdit.append(resultStr)
</code></pre><h2 id="四-程序发布"><a href="#四-程序发布" class="headerlink" title="四. 程序发布"></a>四. 程序发布</h2><h3 id="4-1-安装PyInstaller"><a href="#4-1-安装PyInstaller" class="headerlink" title="4.1 安装PyInstaller"></a>4.1 安装PyInstaller</h3><p>使用 <code>pip install pyinstaller</code>安装 PyInstaller.</p>
<h3 id="4-2-打包程序"><a href="#4-2-打包程序" class="headerlink" title="4.2 打包程序"></a>4.2 打包程序</h3><p>首先注意打包过程可能出现各种错误，先做好心理准备。</p>
<p>按照网络上的一般教程，使用pyqt库时候，一般是在主入口文件中添加，无论这个文件是否使用到，都需要导入以下库：</p>
<pre><code>from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
</code></pre><p>但是这样，在我的机器上是无法成功打包程序的，经常之前大量的尝试和搜索，找到了解决方案，需要在上面的库之前再加上一行：</p>
<pre><code>from PyQt5 import *
</code></pre><p>告诉打包程序需要使用PyQt5.</p>
<p>打包命令使用  </p>
<pre><code>pyinstaller --hidden-import queue -F -w GetFestivalDate.py
</code></pre><p>其中<code>--hidden-import queue</code> 很重要，如果不加上，可以生成exe但是运行时会闪退。</p>
<ul>
<li>-F 代表生成一个整体exe文件.</li>
<li>-w 代表生成的是图形化程序，对应-c 代表控制台程序。</li>
</ul>
<p>然后在生成的dist文件夹下就能找到生成的exe文件了，赶紧双击打开试试吧。生成的exe是可以直接拷贝到其他电脑运行的，只是需要注意的是，如果运行的系统的位数需要和你打包程序时的系统一致。</p>
<h2 id="五-后记"><a href="#五-后记" class="headerlink" title="五.后记"></a>五.后记</h2><p>以上就是整个程序的开发过程，特记录下来，有两个目的，一个是希望后来的初学者不要步入这些坑了，另一个是帮助自己记录这些细节，方便以后查阅。</p>
<p>代码我上传到Github上了，欢迎大家Star her和 Follow me.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-节日倒计时软件制作&quot;&gt;&lt;a href=&quot;#Python-节日倒计时软件制作&quot; class=&quot;headerlink&quot; title=&quot;Python 节日倒计时软件制作&quot;&gt;&lt;/a&gt;Python 节日倒计时软件制作&lt;/h1&gt;&lt;h2 id=&quot;一-项目描述&quot;&gt;&lt;
    
    </summary>
    
      <category term="Python" scheme="http://www.orzangleli.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.orzangleli.com/tags/Python/"/>
    
      <category term="软件" scheme="http://www.orzangleli.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结</title>
    <link href="http://www.orzangleli.com/2016/12/29/2016-12-29_2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://www.orzangleli.com/2016/12/29/2016-12-29_2016年度总结/</id>
    <published>2016-12-28T16:00:00.000Z</published>
    <updated>2017-01-10T14:13:17.551Z</updated>
    
    <content type="html"><![CDATA[<p>今年做了四件事：</p>
<ol>
<li><p>找工作</p>
</li>
<li><p>Android </p>
</li>
<li><p>Unity</p>
</li>
<li><p>Python</p>
</li>
</ol>
<h2 id="1-找工作"><a href="#1-找工作" class="headerlink" title="1. 找工作"></a>1. 找工作</h2><p>今年9月份开始回的武汉找工作，到11月份回无锡，正好两个月时间。因为9月份就找到了比较合适的，所以找工作主要集中在9月份，10月份在武汉基本没怎么去面试，就在剩下的时间里开始了自学Python。</p>
<p>一共找到以下几家公司的Offer,在我所在的学院里，既不算多的，也不算好的。</p>
<ol>
<li>斗鱼TV      <em>一家总部在武汉的视频直播公司，以前一家独大</em></li>
<li>中兴   <em>面试的岗位是移动开发工程师，主要觉得没有发展前景</em></li>
<li>58同城  <em>在北京，远，岗位挺好的，转转里的Android开发</em></li>
<li>华信证券  <em>在上海，工资一般，但是android团队竟然只有4个人，感觉没有任何希望</em></li>
<li>善行医疗  <em>在深圳，做医疗VR的，但是工资低</em></li>
</ol>
<p>以上几家公司，我选择了58同城，因为相对来说，它是技术上能够拿得有进步的，而且前景也比较好，虽然公司前景跟个人没啥根本利益关系，但是在一家有互联网氛围的公司学习工作也是一种好的体验。</p>
<h2 id="2-Android"><a href="#2-Android" class="headerlink" title="2. Android"></a>2. Android</h2><p>今年基本上结束了前几年开发android的方式，前几年是利用老的技术不断去开发各种APP,然后上传到应用市场，拿去售卖，再获得广告收入。<br>改变的原因有两个：一方面，我认为加广告对用户体验有很大影响，不愿意使用广告；另一方面，这些广告的收入也是很微薄。所以我就没有必要去为了挣钱去做那些没有特殊意义，为了迎合别人的APP了，我要做我自己想做的APP，学自己想学的技术。</p>
<p>今年Android方面的热门技术都有一些大致的了解：</p>
<ul>
<li>图片加载库： UIL,Picasso,Glide,Fresco.</li>
<li>网络通信库： Volley,OkHttp,NoHttp</li>
<li>MultiDex与热修复: 阿里的AndFix，QQ空间的HotFix,微信的Tinker（还没了解） </li>
</ul>
<h3 id="1-开源控件"><a href="#1-开源控件" class="headerlink" title="1. 开源控件"></a>1. 开源控件</h3><p>自己也还写了几个开源控件，都上传都Github上了，Github上的图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_27_34_github_contributions.png" alt=""></p>
<p><strong>1.<a href="https://github.com/hust201010701/RoateIndicatorViewDemo" target="_blank" rel="external">RoateIndicatorViewDemo</a></strong></p>
<p>高仿转转APP中的轮播图片的指示器</p>
<p><img src="http://lxctest.qiniudn.com/2016-11-10_15:57:31_zhuanzhuan2.webp" alt=""></p>
<p><strong>2.<a href="https://github.com/hust201010701/Danmu" target="_blank" rel="external">Danmu</a></strong></p>
<p>弹幕控件，可以切换弹幕水平/竖直运动方向,可以控制弹幕正向/逆向运动</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_09_04_danmu.gif" alt=""></p>
<p><strong>3. <a href="https://github.com/hust201010701/CouponView" target="_blank" rel="external">CouponView</a></strong></p>
<p>卡券视图: CouponView 是一个继承自LinearLayout的布局View,边缘可以实现自动裁剪效果，所以用来做优惠券等视图效果很好。</p>
<p><img src="http://i.imgur.com/pj4XTxr.png" alt=""></p>
<h3 id="2-Android项目"><a href="#2-Android项目" class="headerlink" title="2. Android项目"></a>2. Android项目</h3><p><strong>1. Hust-Wuxi 考勤查询系统</strong></p>
<p>因为官方的APP中，没有给考勤查询的功能，要查看考勤只能登陆网页，这很不方便，所以我通过分析网络请求找到了查询的API，然后自己写了一个客户端，用颜色标识考勤结果。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_09_04_kaoqin1.png" alt=""><br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_09_04_kaoqin2.png" alt=""><br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_22_08_55_kaoqin3.png" alt=""></p>
<p><strong>2. 校招宝</strong></p>
<p>一款获取海投网上宣讲会数据的APP,自己利用Bmob增加了评论和收藏的功能。海投网API老是变，我这会写总结的时候，APP又挂了。</p>
<p><strong>3. LOL视频宝</strong></p>
<p>这款软件使用了Python爬虫获取多玩饭盒APP中LOL视频资源，然后存到LeanCloud云端数据库，android端再通过SDK获取云端数据库资源。还未发布，目前正在内测和修改中。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol1.png" alt=""></p>
<p>主页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol2.png" alt=""></p>
<p>关注页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol3.png" alt=""></p>
<p>详情页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol4.png" alt=""></p>
<p>下载页</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_10_54_28_lol5.png" alt=""></p>
<p>首页菜单</p>
<h2 id="3-Unity3D"><a href="#3-Unity3D" class="headerlink" title="3. Unity3D"></a>3. Unity3D</h2><p>今年的主要任务也是Unity3D,本身是一款游戏引擎，我们拿来做工业VR应用也是可以的。<br>因为一直没有接到正式的项目，所以在探索与尝试加上导师的指示中做了以下几点工作：</p>
<p><strong>1. TQ的发动机装配生产线的监控系统</strong></p>
<p>因为没有传感器数据，自己根据动画生成了数据库，然后又根据这些数据来模拟车间机械结构动作，只是模型好像有点问题，播放起来有点卡。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_13_39_tq1.png" alt=""></p>
<p><strong>2. 某起重机的模拟</strong></p>
<p>这个做了两个项目，一个是在Oculus Rift Dk2下做的，因为oculus这款不带交互设备，只能通过目光中心选取物体，所以动画都是半自动的，点一个按钮，动画就会播放，不可以控制运动过程。</p>
<p>后面Htc Vive眼镜到货了，就开始使用这款眼镜，自带定位器和控制器，所以利用了这个做了一个可以控制运动过程的系统，而且还单独配了一套使用LeapMotion的系统，可以用手直接操作VR场景中的物体。</p>
<p><strong>3. 车床切削过程的VR模拟系统</strong></p>
<p>选取了一款简单的车床，模拟车削加工过程。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_13_39_chexie.png" alt=""></p>
<p><strong>4. 发动机侧护板装配VR系统</strong></p>
<p>在VR系统中操作吊机完成侧护板的装配，还可以监控车间的状态参数。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_13_39_cehuban.png" alt=""></p>
<h2 id="4-Python"><a href="#4-Python" class="headerlink" title="4. Python"></a>4. Python</h2><p>有人说，人生苦短，我用Python. 真的，自从11月份开始学习Python来，我越来越认同这个观点。Python的强大第三方库，让我渐渐见识到一个新的世界。</p>
<p><strong>1. 七牛文件上传器</strong></p>
<p>利用七牛云，可以把电脑上的文件上传到云空间中，对于图片还可以自动生成Markdown格式外链，方便写博客的时候插入链接，我这篇文章用的就是自己的软件上传的图片。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/8cb58cc2gw1faq1vvmv5gj20vh0ho0y3.jpg" alt=""></p>
<p><strong>2. 博客迁移爬虫</strong></p>
<p>之前的博客在主机公园上，真的差，打开首页都要10几秒，后来用了Hexo+Github Pages.<br>要是一份份的复制粘贴之前的博客文章也是效率低，于是写了一个爬虫将博客文章，按照日期保存到本地。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_30_49_blogqianyi.png" alt=""></p>
<p><strong>3. LOL视频宝的视频数据爬虫</strong></p>
<p> 之前本来想在年前做一款新闻阅读APP的，至于为什么要改成做LOL视频咨询客户端，原因如下：</p>
<blockquote>
<p>因为我认为一款新闻客户端是否优秀不在于它交互方式或者UI多么炫酷，而在于新闻的内在质量和推荐算法，就算我能够爬到很多新闻源，也不能将它们堆砌的提交给用户，这是对用户不负责任，所以筛选算法和推荐算法很重要，出于能力问题，这一块我决定放弃。</p>
<p>为什么我要做LOL视频合集，因为现在在PC上找不到完整的LOL分类，大都是零散的，混乱的，不便于用户使用；而目前APP上，我也只看到多玩饭盒做的还可以，有很详细的分类，但是仍然不够好，曾经因为一段时间主播跳槽，虎牙将主播封杀，该主播视频就没有，另一方面，它们这些APP永远在做加法，功能越来越臃肿，我作为LOL玩家，我只想关于LOL的新闻咨询或者视频，不想玩你的社区，不想看你的美女视频，我只想静静的看视频。</p>
</blockquote>
<p>所以宗旨是：给用户一个干净的，完整的LOL视频观看体验。</p>
<p>利用Packet Capture和浏览器的F12功能，推理+解析了很久，终于剥离出查询的API.然后赶紧写了一个python把服务器中的视频资源存到数据库中。视频资源挺丰富，数据量有20k.</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_11_30_49_shipinbao.png" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>2016年，我主要的我就是四件事情，很惭愧，就做了一点微小的工作，谢谢大家。2017年，继续加油。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年做了四件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;找工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unity&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-找工作&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="未分类" scheme="http://www.orzangleli.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="未分类" scheme="http://www.orzangleli.com/tags/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>侧护板装配VR系统技术细节</title>
    <link href="http://www.orzangleli.com/2016/12/14/2016-12-14_%E4%BE%A7%E6%8A%A4%E6%9D%BF%E8%A3%85%E9%85%8DVR%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    <id>http://www.orzangleli.com/2016/12/14/2016-12-14_侧护板装配VR系统技术细节/</id>
    <published>2016-12-13T16:00:00.000Z</published>
    <updated>2017-01-10T14:13:30.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li>模型格式转化和处理</li>
<li>装配流程设计</li>
<li>动画设计</li>
<li>第三方库（VRTK，DOTween）的使用</li>
<li>交互方式设计</li>
</ol>
<h2 id="一-模型格式转化和处理"><a href="#一-模型格式转化和处理" class="headerlink" title="一.模型格式转化和处理"></a>一.模型格式转化和处理</h2><p>在任意的VR系统都有大量的模型需求，我总结了以下两种模型获取方式：</p>
<h3 id="1-使用三维绘图软件绘制模型并转换格式"><a href="#1-使用三维绘图软件绘制模型并转换格式" class="headerlink" title="1. 使用三维绘图软件绘制模型并转换格式"></a>1. 使用三维绘图软件绘制模型并转换格式</h3><p>以我常用的Catia为例，先绘制出模型，然后将模型转为CGR格式，注意一定要这个格式，经过我的测试，如果不是这个格式再接下来转换格式时会失败。</p>
<h3 id="2-使用3Ds-Max绘制模型"><a href="#2-使用3Ds-Max绘制模型" class="headerlink" title="2. 使用3Ds Max绘制模型"></a>2. 使用3Ds Max绘制模型</h3><p>这需要会使用3Ds Max的人员来做，由于我们这边缺乏这样的人，所以一般使用3Ds Max的模型都是从网络上下载下来的。</p>
<h2 id="二-装配流程设计"><a href="#二-装配流程设计" class="headerlink" title="二. 装配流程设计"></a>二. 装配流程设计</h2><p>根据三维仿真视频，可以看出装配流程如下所示：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_10_37_34_流程图.png" alt="去"></p>
<p>为了增强交互性，动画中人模型所做的事，将在VR系统中以第一人称的视角完成所有装配。</p>
<h2 id="三-动画设计"><a href="#三-动画设计" class="headerlink" title="三. 动画设计"></a>三. 动画设计</h2><p>可以从动画中看出有几处机构的运动形式：</p>
<ol>
<li>吊机的控制</li>
<li>侧护板的移动</li>
<li>夹具的夹紧和松开动作</li>
</ol>
<p>这几种是比较典型的几种运动形式，针对不同的运动形式，需要进行不用的动画设计。</p>
<h3 id="1-吊机的控制"><a href="#1-吊机的控制" class="headerlink" title="1. 吊机的控制"></a>1. 吊机的控制</h3><p>吊机的示意图如下：<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_10_59_38_吊机结构.png" alt=""></p>
<p>吊机的控制，这个是最基本的，就是通Transform组件，对物体进行移动。只不过这些需要注意的是，不同方向的移动是针对不同物体的，例如，上下方向移动是挂钩的移动，而左右移动是电机的移动，前后的移动是横梁的移动。</p>
<p>在程序，我定义了一个枚举类型，表示吊机目前的状态：</p>
<pre><code>public enum State {UP,DOWN,FRONT,BACK,LEFT,RIGHT,IDLE};
</code></pre><p>其中<code>IDLE</code>表示吊机静止状态。</p>
<p><strong>需要注意的细节</strong></p>
<p>这里有一个技术细节：连接电机和挂钩的『绳子』，它的长度是变化的，需要和挂钩保持同步。在VR系统中它并不是真正的绳子，而是一个圆柱体，绳子长度变化的时候，实际上是圆柱体沿竖直方向的scale值变化。另外，因为绳子总是从电机出发出，所以需要将圆柱体的锚点设置在电机处，否则绳子在变长到一定程度时，会看到绳子已经穿过了电机。</p>
<h3 id="2-侧护板的移动"><a href="#2-侧护板的移动" class="headerlink" title="2. 侧护板的移动"></a>2. 侧护板的移动</h3><p>相对来说，侧护板的移动不是一种『自主运动』，它是被吊机吊起来的，所以这种运动是不同于上述方法的处理。对于侧护板需要事先添加碰撞器，并添加脚本，碰撞器添加在挂带的中心位置，这样当挂钩碰到中心位置时，就能检测到。<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_11_26_52_侧护板碰撞器.png" alt=""><br>在检测到碰撞后，判断如果碰撞器如果是来自侧护板，就代表现在用户想使用挂钩将侧护板吊起来。在<code>OnTriggerEnter</code>中，将侧护板的parent设置为挂钩，这样侧护板就能够跟着挂钩移动了。</p>
<pre><code>collider.transform.parent = this.transform;
collider.transform.position = bornPlace.position;
</code></pre><h3 id="3-夹具的夹紧和松开动作"><a href="#3-夹具的夹紧和松开动作" class="headerlink" title="3. 夹具的夹紧和松开动作"></a>3. 夹具的夹紧和松开动作</h3><p>夹具的动作包括张开和闭合，动画如图所示：<br><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_13_47_43_夹具.gif" alt=""><br>夹具的动作很复杂，基本上无法通过脚本控制实现，所以，最好使用Unity中的Animation完成动画，而且夹具的动作张开和闭合是对称的，所以只需要完成闭合的动作就可以了，张开的动作可以将动画的播放速度调整为-1即可倒着播放。另外，在夹具闭合的时候，要把护板添加到夹具的两侧中，以达到夹具加紧侧护板的视觉效果。下面就是夹具闭合的代码：</p>
<pre><code>public void bihe()
{
    AnimatorStateInfo info = animator.GetCurrentAnimatorStateInfo(0);
    if ((info.IsName(&quot;jiaju_zhangkai&quot;) &amp;&amp; info.normalizedTime &gt;= 1) || info.IsName(&quot;idle&quot;))
    {

        //将左右护板添加到夹具中
        Transform yeyazhijia = this.transform.parent;
        Transform left_huban = yeyazhijia.FindChild(&quot;huban_guadai_left(Clone)&quot;);
        Transform right_huban = yeyazhijia.FindChild(&quot;huban_guadai_right(Clone)&quot;);
        Transform zuodangban = this.transform.FindChild(&quot;jiajuzhengti_copy/jiaju/zuodangban&quot;);
        Transform youdangban = this.transform.FindChild(&quot;jiajuzhengti_copy/jiaju/youdangban&quot;);

        if (Vector3.Distance(left_huban.position, zuodangban.position) &gt; Vector3.Distance(left_huban.position, youdangban.position))
        {
            normal = false;
            if (left_huban != null)
                left_huban.parent = youdangban;
            if (right_huban != null)
                right_huban.parent = zuodangban;
        }
        else
        {
            normal = true;
            if (left_huban != null)
                left_huban.parent = zuodangban;
            if (right_huban != null)
                right_huban.parent = youdangban;
        }

        animator.Play(&quot;jiaju_bihe&quot;);
        biheButton.interactable = false;
        zhangkaiButton.interactable = true;

        //同时使碰撞器失效，防止在未松开之前拉上去
        this.GetComponent&lt;Collider&gt;().enabled = false;
        stepHint.text = &quot;夹紧操作完成，请点击菜单中的『夹具张开』按钮&quot;;
    }
}
</code></pre><h2 id="四-第三方库（VRTK，DOTween）的使用"><a href="#四-第三方库（VRTK，DOTween）的使用" class="headerlink" title="四. 第三方库（VRTK，DOTween）的使用"></a>四. 第三方库（VRTK，DOTween）的使用</h2><p>本VR系统中主要使用了两个第三方库：</p>
<ul>
<li><p><strong>VRTK</strong>    <em>这个工具包提供了很多Unity3d里的常用VR功能，如下（但并不局限于此）：</em></p>
<ul>
<li>带有通用别名的控制器按钮事件</li>
<li>控制器世界指针（如激光指针）</li>
<li>玩家传送</li>
<li>用控制器抓取对象</li>
<li>用控制器和对象交互</li>
</ul>
</li>
<li><p><strong>DOTween</strong>  <em>DOTween是Unity中具有强大功能的动画插件</em></p>
</li>
</ul>
<h3 id="1-VRTK的使用"><a href="#1-VRTK的使用" class="headerlink" title="1. VRTK的使用"></a>1. VRTK的使用</h3><h4 id="1）-VRTK的安装"><a href="#1）-VRTK的安装" class="headerlink" title="1）. VRTK的安装"></a>1）. VRTK的安装</h4><p>VRTK从Assets Store中下载，下载完成后导入即可。</p>
<h4 id="2）-VRTK-射线的使用"><a href="#2）-VRTK-射线的使用" class="headerlink" title="2）. VRTK 射线的使用"></a>2）. VRTK 射线的使用</h4><p>在SteamVR包中[CameraRig]的Controller(right)上添加脚本VRTK_UI_Pointer,这是射线基本脚本，可以设置射线何时显示，比如按住按钮或者切换按钮或者一直显示等。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_35_51_VRTK_UI_Pointer.png" alt=""></p>
<p>还需要添加<code>VRTK_Simple_Pointer</code>脚本，这是直线射线发射脚本，除此之外还可以使用 <code>VRTK_Bezier_Pointer</code><br>它是贝泽尔曲线脚本。要指定按钮按住之后发射射线，还需要添加<code>VRTK_Controller Events</code>脚本，可以设置按下哪个按钮后发出射线。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_37_27_VRTK_ControllerEvents.png" alt=""></p>
<h4 id="3）-VRTK-中UI的使用"><a href="#3）-VRTK-中UI的使用" class="headerlink" title="3）. VRTK 中UI的使用"></a>3）. VRTK 中UI的使用</h4><p>VRTK中UI使用非常简单，只需要在普通的UGUI的Canvas上添加<code>VRTK_UI Canvas</code>脚本即可。</p>
<h3 id="2-DOTween的使用"><a href="#2-DOTween的使用" class="headerlink" title="2. DOTween的使用"></a>2. DOTween的使用</h3><p>DOTween十分强大，但是我在本系统中也只是使用到了其中的一部分功能。</p>
<h4 id="1-物体的移动"><a href="#1-物体的移动" class="headerlink" title="1). 物体的移动"></a>1). 物体的移动</h4><p>比如场景中，装配完成后，让生产线移动，实际上就是使用DOTween中的DOMove方法</p>
<pre><code>go.transform.DOLocalMoveZ(go.transform.localPosition.z - 1200f, 60).SetEase(Ease.Linear);
</code></pre><p>DOLocalMoveZ指的是在局部坐标系的Z轴方向上移动到go.transform.localPosition.z - 1200f这个位置，实际上就是向Z轴反方向移动1200，所用的时间是60秒，动画插值器使用的是线性插值。</p>
<h4 id="2-物体的缩放"><a href="#2-物体的缩放" class="headerlink" title="2). 物体的缩放"></a>2). 物体的缩放</h4><p>在菜单显示和关闭的时候，增加一个缩放的动画可以增强用户体验</p>
<pre><code>toolbox.transform.DOScale(0.005f, 0.5f);
</code></pre><p>这句代码的意思就是将菜单的大小放大到0.005,使用的时间是0.5秒。</p>
<h4 id="3-滚动数码管显示器"><a href="#3-滚动数码管显示器" class="headerlink" title="3). 滚动数码管显示器"></a>3). 滚动数码管显示器</h4><p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_51_22_显示器.gif" alt=""></p>
<p>要实现以上效果，需要在Canvas下添加一个遮罩层(Image组件)，给遮罩层添加Mask脚本，并且给Image指定一个图片，这个图片就是指定的Mask的遮罩形状，这样在遮罩层以外的UI都不会显示了。</p>
<p>要实现文字连续滚动，事先添加两个Text，如图所示，由于有Mask层存在，第二个是看不到的。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_14_56_26_状态监测UI.png" alt=""></p>
<p>然后给这两个Text上添加脚本，让他们移动。</p>
<pre><code>this.transform.DOLocalMoveX(this.transform.localPosition.x -1000f,5).SetEase(Ease.Linear).SetLoops(-1,LoopType.Restart);
</code></pre><p>数码管的长度正好为1000，让两个文字一起在5秒中内向左移动1000，移动完成后重新启动动画(复位)，这样就实现了文字无限循环的滚动了。</p>
<h2 id="五-交互方式设计"><a href="#五-交互方式设计" class="headerlink" title="五. 交互方式设计"></a>五. 交互方式设计</h2><p>系统做出来是给人使用的，交互设计也是十分重要，虽然目前我对本系统的交互设计上也有点意见，但是目前尚未找到更好的方案，下面将详细说明。</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_15_16_34_手柄按键说明.png" alt=""></p>
<h3 id="1-左手手柄"><a href="#1-左手手柄" class="headerlink" title="1. 左手手柄"></a>1. 左手手柄</h3><ul>
<li>左手手柄的触摸板，轻触时显示控制吊机移动的菜单，滑动可以选择菜单，按下时将执行动作。</li>
<li>左手手柄的Grip键(侧面的两个按钮)是旋转挂钩的方向的。</li>
<li>Application键用来显示和隐藏手柄上的提示文字</li>
</ul>
<h3 id="2-右手手柄"><a href="#2-右手手柄" class="headerlink" title="2. 右手手柄"></a>2. 右手手柄</h3><ul>
<li><p>触摸板按下时发出射线</p>
<ul>
<li>若发出的射线指向地面，松开触摸板即可瞬移到该位置</li>
<li>若发出的射线指向UI界面，配合Trigger(扳机键)可以实现点击按钮的操作。</li>
</ul>
</li>
<li><p>Grip键(侧面的两个按钮)是用于显示和关闭菜单的</p>
</li>
</ul>
<h3 id="3-目前方案存在的问题"><a href="#3-目前方案存在的问题" class="headerlink" title="3.目前方案存在的问题"></a>3.目前方案存在的问题</h3><p>之前说过这个方案是有不足的，主要在于吊机的控制。吊机需要6个按钮来控制，分别是上下东西南北，如果要将这6个按钮显示在一起，就是上面的方案，可以看到无论怎么分布，使用无法保证东西南北的四个方向与真实的场景中的方向一致，所以在操作吊机时，不熟悉的使用者需要一直看着手柄进行操作。</p>
<h3 id="4-潜在的解决方法"><a href="#4-潜在的解决方法" class="headerlink" title="4.潜在的解决方法"></a>4.潜在的解决方法</h3><h4 id="1-分解菜单"><a href="#1-分解菜单" class="headerlink" title="1). 分解菜单"></a>1). 分解菜单</h4><p>在展会的时候，有人就提出了这个问题，后来我问他有什么好的建议，他说可以把东西南北做到左手手柄上，将上下两个按钮做到右手手柄上，这样右手手柄上发射射线的按钮就需要修改下了，不过这也是一种方案。</p>
<h4 id="2-将6等分菜单变为8等分菜单"><a href="#2-将6等分菜单变为8等分菜单" class="headerlink" title="2). 将6等分菜单变为8等分菜单"></a>2). 将6等分菜单变为8等分菜单</h4><p>很简单的原理，示意图如下所示：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-14_15_51_08_按键方案2.png" alt=""></p>
<p>至于哪种方案好，我暂时也没有办法判断，所以只好先全部记录下来了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;模型格式转化和处理&lt;/li&gt;
&lt;li&gt;装配流程设计&lt;/li&gt;
&lt;li&gt;动画设计&lt;/li&gt;
&lt;li&gt;第三方库（VRTK，DOTwe
    
    </summary>
    
      <category term="unity3D" scheme="http://www.orzangleli.com/categories/unity3D/"/>
    
    
      <category term="unity3D" scheme="http://www.orzangleli.com/tags/unity3D/"/>
    
  </entry>
  
  <entry>
    <title>pyqt打包失败.md</title>
    <link href="http://www.orzangleli.com/2016/12/13/2016-12-13_pyqt%E6%89%93%E5%8C%85%E5%A4%B1%E8%B4%A5/"/>
    <id>http://www.orzangleli.com/2016/12/13/2016-12-13_pyqt打包失败/</id>
    <published>2016-12-12T16:00:00.000Z</published>
    <updated>2016-12-29T13:51:57.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题"><a href="#pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题" class="headerlink" title="pyqt 打包失败 出现pyi_rth_qt4plugins 找不到的问题"></a>pyqt 打包失败 出现pyi_rth_qt4plugins 找不到的问题</h1><ol>
<li><p>pyqt5的位数和系统位数要一致。</p>
</li>
<li><p>pyqt版本为：PyQt GPL v5.4.1 for Pythonv3.4(x64)</p>
</li>
</ol>
<p>环境截图：</p>
<p><img src="http://7bvaky.com2.z0.glb.qiniucdn.com/2016-12-29_09_59_32_python环境截图.png" alt=""></p>
<p>使用下面的语句进行打包：<br>pyinstaller –hidden-import queue -F -w MainWindow.py</p>
<p>后来由出现QtCore可以找到，但是QtWidgets找不到，但是不知道怎么回事，重新打包了n次后就自动好了，不知道是不是之前设置的环境变量要过一会才会生效，设置的环境变量就是QtCore,QtGui,QtWidgets三个dll文件。</p>
<p>在管理员模式下运行命令行，进行PyInstaller安装</p>
<p>加上这句话：<br>    from PyQt5 import *<br>这句话才是精髓，不加就不能运行，加了就可以。。。额！</p>
<p>C:\Users\Administrator\AppData\Roaming\pyinstaller\bincache00_py34_64bit\qt5gui.dll 可能是去这个目录找那个dll，然后没找到。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题&quot;&gt;&lt;a href=&quot;#pyqt-打包失败-出现pyi-rth-qt4plugins-找不到的问题&quot; class=&quot;headerlink&quot; title=&quot;pyqt 打包失败 出现pyi_rt
    
    </summary>
    
      <category term="python" scheme="http://www.orzangleli.com/categories/python/"/>
    
    
      <category term="python" scheme="http://www.orzangleli.com/tags/python/"/>
    
  </entry>
  
</feed>
