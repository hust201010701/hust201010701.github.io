<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>orzangleli</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="华中科技大学 本科10级 硕士14级 努力学习中">
<meta property="og:type" content="website">
<meta property="og:title" content="orzangleli">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="orzangleli">
<meta property="og:description" content="华中科技大学 本科10级 硕士14级 努力学习中">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="orzangleli">
<meta name="twitter:description" content="华中科技大学 本科10级 硕士14级 努力学习中">
  
    <link rel="alternative" href="/atom.xml" title="orzangleli" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/img/favicon.ico">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/assets/avatar.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">orzangleli</a></h1>
		</hgroup>

		
		<p class="header-subtitle">活在梦里的程序员和设计师</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/techs">技术</a></li>
	        
				<li><a href="/chats">闲聊</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/hust201010701" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/androidjiqiaogonglue" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">orzangleli</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/assets/avatar.gif" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">orzangleli</h1>
			</hgroup>
			
			<p class="header-subtitle">活在梦里的程序员和设计师</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/techs">技术</a></li>
		        
					<li><a href="/chats">闲聊</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/hust201010701" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/androidjiqiaogonglue" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-2016-07-01_如何让NavigationView不遮挡ToolBar呢" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/01/2016-07-01_如何让NavigationView不遮挡ToolBar呢/">如何让NavigationView不遮挡ToolBar呢</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如何让NavigationView不遮挡ToolBar呢？改变toolbar和DrawerLayout的嵌套关系，把他们放在Linearlayout中就行。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;include layout=&quot;@layout/toolbar_actionbar&quot;/&gt;

    &lt;android.support.v4.widget.DrawerLayout
        android:id=&quot;@+id/drawer_layout&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;!-- Content --&gt;
        &lt;FrameLayout
            android:id=&quot;@+id/content_layout&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;/&gt;

        &lt;!-- Drawer --&gt;
        &lt;android.support.design.widget.NavigationView
            android:id=&quot;@+id/navigation&quot;
            android:layout_width=&quot;240dp&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_gravity=&quot;start&quot;
            app:menu=&quot;@menu/activity_main_drawer&quot;/&gt;
    &lt;/android.support.v4.widget.DrawerLayout&gt;
&lt;/LinearLayout&gt;
</code></pre><p><img src="http://upload-
images.jianshu.io/upload_images/111373-c8e1f1f48f908f5f.png?imageMogr2/auto-
orient/strip%7CimageView2/2/w/1240" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/07/01/2016-07-01_如何让NavigationView不遮挡ToolBar呢/" class="archive-article-date">
  	<time datetime="2016-06-30T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-07-01</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-2016-06-30_Android Studio Gradle 更新失败 Plugin is too old,please update to a more recent version,or set ANDROID_DAILY_OVERRIDE.." class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/30/2016-06-30_Android Studio Gradle 更新失败 Plugin is too old,please update to a more recent version,or set ANDROID_DAILY_OVERRIDE../">Android Studio Gradle 更新失败 Plugin is too old,please update to a more recent version,or set ANDROID_DAILY_OVERRIDE..</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>打开AS，发现报错：</p>
<p>Plugin is too old,please update to a more recent version,or set<br>ANDROID_DAILY_OVERRIDE..</p>
<p>点下面的Fix plugin version and sync project 也不管用</p>
<p>经过大量测试，找到解决方法：</p>
<p><img src="http://www.orzangleli.com/wp-
content/uploads/2016/06/q20160630170954.png" alt="q20160630170954"></p>
<p>可以看到这里有很多版本的Gradle,当前使用的使用2.2.0-alpha1会报错，在修改Project下的build.gradle文件中的classpath为</p>
<pre><code>classpath &apos;com.android.tools.build:gradle:2.0.0&apos;
</code></pre><p>然后Sync，再弹出的对话框中</p>
<p><img src="http://www.orzangleli.com/wp-
content/uploads/2016/06/q20160630171220.jpg" alt="q20160630171220"></p>
<p>选择第二项，Remind me later ，然后就成功了。</p>
<p>声明：这是本人通过大量测试得出的解决方案，请尊重劳动成果，转载请注明出处，谢谢!</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/06/30/2016-06-30_Android Studio Gradle 更新失败 Plugin is too old,please update to a more recent version,or set ANDROID_DAILY_OVERRIDE../" class="archive-article-date">
  	<time datetime="2016-06-29T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-06-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-2016-06-14_使用Github中的项目 SwipeBackLayout 侧滑关闭 黑屏解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/14/2016-06-14_使用Github中的项目 SwipeBackLayout 侧滑关闭 黑屏解决方案/">使用Github中的项目 SwipeBackLayout 侧滑关闭 黑屏解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在生活中，大量APP使用了侧滑退出功能，微信中使用犹为频繁，在进入朋友圈时，右滑就能退出这个界面，返回上一层，使用起来很方便。</p>
<p>Github上有一个开源项目，使用这个库就能方便的实现该功能。</p>
<p>这个控件的名称为：WP Reposidget</p>
<p><a href="https://github.com/myst729/wp-reposidget" target="_blank" rel="external">GitHub 仓库挂件 WordPress 插件</a></p>
<h2 id="hust201010701"><a href="#hust201010701" class="headerlink" title="hust201010701 /"></a><a href="https://github.com/hust201010701" target="_blank" rel="external">hust201010701</a> /</h2><p><a href="https://github.com/hust201010701/SwipeBackLayout" target="_blank" rel="external"><strong>SwipeBackLayout</strong></a></p>
<p>An Android library that help you to build app with swipe back gesture.</p>
<p><a href="https://github.com/hust201010701/SwipeBackLayout" target="_blank" rel="external"><strong>https://github.com/hust201010701/SwipeBackLayout</strong></a></p>
<p>00 <a href="https://github.com/hust201010701/SwipeBackLayout/archive/master.zip" target="_blank" rel="external">Download<br>ZIP</a></p>
<p>使用起来也是很方便，将默认继承的Activity修改为SwipeBackActivity，然后设置下滑动方向即可。</p>
<pre><code>mSwipeBackLayout = getSwipeBackLayout();
mSwipeBackLayout.setEdgeTrackingEnabled(edgeFlag);
</code></pre><p>套路人家做出来的程序，给出效果图。</p>
<p><img src="https://github.com/Issacw0ng/SwipeBackLayout/blob/master/art/screenshot.png?raw=true" alt=""></p>
<p>注意一定要加上这句话：</p>
<pre><code>Make window translucent by adding &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt; to your theme.
</code></pre><p>否则就会出现，侧滑时，背景为黑色。</p>
<p>另外，滑动到哪里才会返回，是设置一个阈值，使用下面代码：</p>
<pre><code>mSwipeBackLayout.setScrollThresHold(0.6f);
</code></pre><p><a href="http://www.orzangleli.com/wp-
content/uploads/2016/03/screenshot_2016-03-31-23-36-58.png" target="_blank" rel="external"><img src="http://www.orzangleli.com/wp-
content/uploads/2016/03/screenshot_2016-03-31-23-36-58.png" alt="image"></a></p>
<p>完整代码如下：</p>
<pre><code>mSwipeBackLayout = getSwipeBackLayout();
       mSwipeBackLayout.setEdgeTrackingEnabled(SwipeBackLayout.EDGE_LEFT);
       mSwipeBackLayout.setScrollThresHold(0.4f);
       mSwipeBackLayout.addSwipeListener(new SwipeBackLayout.SwipeListener() {
           @Override
           public void onScrollStateChange(int state, float scrollPercent) {

           }
           @Override
           public void onEdgeTouch(int edgeFlag) {

           }
           @Override
           public void onScrollOverThreshold() {
           }
       });
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/06/14/2016-06-14_使用Github中的项目 SwipeBackLayout 侧滑关闭 黑屏解决方案/" class="archive-article-date">
  	<time datetime="2016-06-13T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-06-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-2016-06-14_【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/14/2016-06-14_【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（二）/">【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文转载自<a href="https://onevcat.com/#blog" title="link to homepage for OneV&#39;s Den" target="_blank" rel="external">OneV’s Den</a> 的博客，OneV’s Den<br>真是一位值得我们程序员学习的榜样，写的文章通俗易懂而且有深度，有兴趣的可以关注他的<a href="http://weibo.com/onevcat" target="_blank" rel="external">微博</a>。</p>
<p>以下部分是正文：</p>
<hr>
<p>#</p>
<h1 id="猫都能学会的Unity3D-Shader入门指南（二）"><a href="#猫都能学会的Unity3D-Shader入门指南（二）" class="headerlink" title="猫都能学会的Unity3D Shader入门指南（二）"></a>猫都能学会的Unity3D Shader入门指南（二）</h1><h2 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h2><p>这是Unity3D<br>Shader入门指南系列的第二篇，本系列面向的对象是新接触Shader开发的Unity3D使用者，因为我本身自己也是Shader初学者，因此可能会存在错误或者疏漏，如果您在Shader开发上有所心得，很欢迎并恳请您指出文中纰漏，我会尽快改正。在<a href="http://onevcat.com/2013/07/shader-
tutorial-1/" target="_blank" rel="external">之前的开篇</a>中介绍了一些Shader的基本知识，包括ShaderLab的基本结构和语法，以及简单逐句地讲解了一个基本的shader。在具有这些基础知识后，阅读简单的shader应该不会有太大问题，在继续教程之前简单阅读一下Unity的<a href="http://docs.unity3d.com/Documentation/Components/SL-
SurfaceShaderExamples.html" target="_blank" rel="external">Surface<br>Shader Example</a>，以检验您是否掌握了上一节的内容。如果您对阅读大部分示例Shader并没有太大问题，可以正确地指出Shader的结构，声明和使用的话，就说明您已经准备好继续阅读本节的内容了。</p>
<h2 id="法线贴图-Normal-Mapping"><a href="#法线贴图-Normal-Mapping" class="headerlink" title="法线贴图(Normal Mapping)"></a>法线贴图(Normal Mapping)</h2><p>法线贴图是凸凹贴图(Bump<br>mapping)的一种常见应用，简单说就是在不增加模型多边形数量的前提下，通过渲染暗部和亮部的不同颜色深度，来为原来的贴图和模型增加视觉细节和真实效果。简单原理是在普通的贴图的基础上，再另外提供一张对应原来贴图的，可以表示渲染浓淡的贴图。通过将这张附加的表示表面凸凹的贴图的因素于实际的原贴图进行运算后，可以得到新的细节更加丰富富有立体感的渲染效果。在本节中，我们将首先实现一个法线贴图的Shader，然后对Unity<br>Shader的光照模型进行一些讨论，并实现一个自定义的光照模型。最后再通过更改shader模拟一个石头上的积雪效果，并对模型顶点进行一些修改使积雪效果看起来比较真实。在本节结束的时候，我们就会有一个比较强大的可以满足一些真实开发工作时可用的shader了，而且更重要的是，我们将会掌握它是如何被创造出来的。</p>
<p>关于法线贴图的效果图，可以对比看看下面。模型面数为500，左侧只使用了简单的Diffuse着色，右侧使用了法线贴图。比较两张图片不难发现，使用了法线贴图的石头在暗部和亮部都有着更好的表现。整体来说，凸凹感比Diffuse的结果增强许多，石头看起来更真实也更具有质感。</p>
<p><img src="https://onevcat.com/assets/images/2013/shader-tutorial2-compare.jpg" alt="image"></p>
<p>本节中需要用到的上面的素材可以<a href="http://vdisk.weibo.com/s/y-NNpUsxhYhZI" target="_blank" rel="external">在这里下载</a>，其中包括上面的石块的模型，一张贴图以及对应的法线贴图。将下载的package导入到工程中，并新建一个material，使用简单的Diffuse的Shader（比如上一节我们实现的），再加上一个合适的平行光光源，就可以得到我们左图的效果。另外，本节以及以后都会涉及到一些Unity内建的Shader的内容，比如一些标准常用函数和常量定义等，相关内容可以在Unity的内建Shader中找到，内建Shader可以在<a href="http://unity3d.com/unity/download/archive" target="_blank" rel="external">Unity下载页面</a>的版本右侧找到。</p>
<p>接下来我们实现法线贴图。在实现之前，我们先简单地稍微多了解一些法线贴图的基本知识。大多数法线图一般都和下面的图类似，是一张以蓝紫色为主的图。这张法线图其实是一张RGB贴图，其中红，绿，蓝三个通道分别表示由高度图转换而来的该点的法线指向：Nx、Ny、Nz。在其中绝大部分点的法线都指向z方向，因此图更偏向于蓝色。在shader进行处理时，我们将光照与该点的法线值进行点积后即可得到在该光线下应有的明暗特性，再将其应用到原图上，即可反应在一定光照环境下物体的凹凸关系了。关于法向贴图的更多信息，可以参考<a href="http://en.wikipedia.org/wiki/Normal_mapping" target="_blank" rel="external">wiki上的相关条目</a>。</p>
<p><img src="https://onevcat.com/assets/images/2013/shader-
tutorial2-normal.jpg" alt="一张典型的法线图"></p>
<p>回到正题，我们现在考虑的主要是Shader入门，而不是图像学的原理。再上一节我们写的Shader的基础上稍微做一些修改，就可以得到适应并完成法线贴图渲染的新Shader。新加入的部分进行了编号并在之后进行说明。</p>
<pre><code>Shader &quot;Custom/Normal Mapping&quot; {
    Properties {
        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {}

        //1
        _Bump (&quot;Bump&quot;, 2D) = &quot;bump&quot; {}
    }
    SubShader {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
        LOD 200

        CGPROGRAM
        #pragma surface surf Lambert

        sampler2D _MainTex;

        //2
        sampler2D _Bump;                

        struct Input {
            float2 uv_MainTex;

            //3
            float2 uv_Bump;
        };

        void surf (Input IN, inout SurfaceOutput o) {
            half4 c = tex2D (_MainTex, IN.uv_MainTex);

            //4
            o.Normal = UnpackNormal(tex2D(_Bump, IN.uv_Bump);

            o.Albedo = c.rgb;
            o.Alpha = c.a;
        }
        ENDCG
    } 
    FallBack &quot;Diffuse&quot;
}
</code></pre><ol>
<li>声明并加入一个显示名称为<code>Bump</code>的贴图，用于放置法线图</li>
<li>为了能够在CG程序中使用这张贴图，必须加入一个sample，希望你还记得～</li>
<li>获取Bump的uv信息作为输入</li>
<li>从法线图中提取法线信息，并将其赋予相应点的输出的Normal属性。<code>UnpackNormal</code>是定义在UnityCG.cginc文件中的方法，这个文件中包含了一系列常用的CG变量以及方法。<code>UnpackNormal</code>接受一个fixed4的输入，并将其转换为所对应的法线值（fixed3）。在解包得到这个值之后，将其赋给输出的Normal，就可以参与到光线运算中完成接下来的渲染工作了。</li>
</ol>
<p>现在保存并且编译这个Shader，创建新的material并使用这个shader，将石头的材质贴图和法线图分别拖放到Base和Bump里，再将其应用到石头模型上，应该就可以看到右侧图的效果了。</p>
<h2 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h2><p>在我们之前的看到的Shader中（其实也就上一节的基本diffuse和这里的normal<br>mapping），都只使用了Lambert的光照模型（#pragma surface surf<br>Lambert），这是一个很经典的漫反射模型，光强与入射光的方向和反射点处表面法向夹角的余弦成正比。关于Lambert和漫反射的一些详细的计算和推论，可以参看wiki（<a href="http://en.wikipedia.org/wiki/Lambertian_reflectance" target="_blank" rel="external">Lambert</a>，<a href="http://en.wikipedia.org/wiki/Diffuse_reflection" target="_blank" rel="external">漫反射</a>）或者其他地方的介绍。一句话的简单解释就是一个点的反射光强是和该点的法线向量和入射光向量和强度和夹角有关系的，其结果就是这两个向量的点积。既然已经知道了光照计算的原理，我们先来看看如何实现一个自己的光照模型吧。</p>
<p>在刚才的Shader上进行如下修改。</p>
<ul>
<li>首先将原来的<code>#pragma</code>行改为这样</li>
</ul>
<pre><code>#pragma surface surf CustomDiffuse
</code></pre><ul>
<li>然后在SubShader块中添加如下代码</li>
</ul>
<pre><code>inline float4 LightingCustomDiffuse (SurfaceOutput s, fixed3 lightDir, fixed atten) {
    float difLight = max(0, dot (s.Normal, lightDir));
    float4 col;
    col.rgb = s.Albedo * _LightColor0.rgb * (difLight * atten * 2);
    col.a = s.Alpha;
    return col;
}
</code></pre><ul>
<li>最后保存，回到Unity。Shader将编译，如果一切正常，你将不会看到新的shader和之前的在材质表现上有任何不同。但是事实上我们现在的shader已经与Unity内建的diffuse光照模型撇清了关系，而在使用我们自己设定的光照模型了。</li>
</ul>
<p>喵的，这些代码都干了些什么！相信你一定会有这样的疑惑…没问题，没有疑惑的话那就不叫初学了，还是一行行讲来。首先正像我们上一篇所说，<code>#pragma</code>语句在这里声明了接下来的Shader的类型，计算调用的方法名，以及指定光照模型。在之前我们一直指定Lambert为光照模型，而现在我们将其换为了CustomDiffuse。</p>
<p>接下来添加的代码是计算光照的实现。shader中对于方法的名称有着比较严格的约定，想要创建一个光照模型，首先要做的是按照规则声明一个光照计算的函数名字，即<code>Lighting&lt;Your
Chosen
Name&gt;</code>。对于我们的光照模型CustomDiffuse，其计算函数的名称自然就是<code>LightingCustomDiffuse</code>了。光照模型的计算是在surf方法的表面颜色之后，根据输入的光照条件来对原来的颜色在这种光照下的表现进行计算，最后输出新的颜色值给渲染单元完成在屏幕的绘制。</p>
<p>也许你已经猜到了，我们之前用的Lambert光照模型是不是也有一个名字叫LightingLambert的光照计算函数呢？Bingo。在Unity的内建Shader中，有一个Lighting.cginc文件，里面就包含了LightingLambert的实现。也许你也注意到了，我们所实现的LightingCustomDiffuse的内容现在和Unity内建中的LightingLambert是完全一样的，这也就是使用新的shader的原来视觉上没有区别的原因，因为实现确实是完全一样的。</p>
<p>首先来看输入量，<code>SurfaceOutput s</code>这个就是经过表面计算函数surf处理后的输出，我们讲对其上的点根据光线进行处理，<code>fixed3
lightDir</code>是光线的方向，<code>fixed atten</code>表示光衰减的系数。在计算光照的代码中，我们先将输入的s的法线值（在Normal<br>mapping中的话这个值已经是法线图中的对应量了）和输入光线进行点积（dot函数是CG中内置的数学函数，希望你还记得，可以<a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter05.html" target="_blank" rel="external">参考这里</a>）。点积的结果在-1至1之间，这个值越大表示法线与光线间夹角越小，这个点也就应该越亮。之后使用max来将这个系数结果限制在0到1之间，是为了避免负数情况的存在而导致最终计算的颜色变为负数，输出一团黑，一般来说这是我们不愿意看到的。接下来我们将surf输出的颜色与光线的颜色<code>_LightColor0.rgb</code>（由Unity根据场景中的光源得到的，它在Lighting.cginc中有声明）进行乘积，然后再与刚才计算的光强系数和输入的衰减系数相乘，最后得到在这个光线下的颜色输出（关于difLight</p>
<ul>
<li>atten <em><br>2中为什么有个乘2，这是一个历史遗留问题，主要是为了进行一些光强补偿，可以参见[这里的讨论](<a href="http://forum.unity3d.com/threads/94711-Why-\(atten-" target="_blank" rel="external">http://forum.unity3d.com/threads/94711-Why-\(atten-</a></em>-2))）。</li>
</ul>
<p>在了解了基本实现方式之后，我们可以看看做一些修改玩玩儿。最简单的比如将这个Lambert模型改亮一些，比如换成Half Lambert模型。Half<br>Lambert是由Valve创造的可以使物体在低光线条件下增亮的技术，最早被用于半条命（Half<br>Life）中以避免在低光下物体的走形。简单说就是把光强系数先取一半，然后在加0.5，代码如下：</p>
<pre><code>inline float4 LightingCustomDiffuse (SurfaceOutput s, fixed3 lightDir, fixed atten) {
    float difLight = dot (s.Normal, lightDir);
    float hLambert = difLight * 0.5 + 0.5;
    float4 col;
    col.rgb = s.Albedo * _LightColor0.rgb * (hLambert * atten * 2);
    col.a = s.Alpha;
    return col;
}
</code></pre><p>这样一来，原来光强0的点，现在对应的值变为了0.5，而原来是1的地方现在将保持为1。也就是说模型贴图的暗部被增强变亮了，而亮部基本保持和原来一样，防止过曝。使用Half<br>Lambert前后的效果图如下，注意最右侧石头下方的阴影处细节更加明显了，而这一切都只是视觉效果的改变，不涉及任何贴图和模型的变化。</p>
<p><img src="https://onevcat.com/assets/images/2013/shader-
toturial-hl.jpg" alt="Half Lambert下发现贴图的表现"></p>
<h2 id="表面贴图的追加效果"><a href="#表面贴图的追加效果" class="headerlink" title="表面贴图的追加效果"></a>表面贴图的追加效果</h2><p>OK，对于光线和自定义光照模型的讨论暂时到此为止，因为如果展开的话这将会一个庞大的图形学和经典光学的话题了。我们回到Shader，并且一起实现一些激动人心的效果吧。比如，在你的游戏场景中有一幕是雪地场景，而你希望做一些石头上白雪皑皑的覆盖效果，应该怎么办呢？难道让你可爱的3D设计师再去出一套覆雪的贴图然后使用新的贴图？当然不，不是不能，而是不该。因为新的贴图不仅会增大项目的资源包体积，更会增大之后修改和维护的难度，想想要是有好多石头需要实现同样的覆雪效果，或者是要随着游戏时间堆积的雪逐渐变多的话，你应该怎么办？难道让设计师再把所有的石头贴图都盖上雪，然后再按照雪的厚度出5套不同的贴图么？相信我，他们会疯的。</p>
<p>于是，我们考虑用Shader来完成这件工作吧！先考虑下我们需要什么，积雪效果的话，我们需要积雪等级（用来表示积雪量），雪的颜色，以及积雪的方向。基本思路和实现自定义光照模型类似，通过计算原图的点在世界坐标中的法线方向与积雪方向的点积，如果大于设定的积雪等级的阈值的话则表示这个方向与积雪方向是一致的，其上是可以积雪的，显示雪的颜色，否则使用原贴图的颜色。废话不再多说，上代码，在上面的Shader的基础上，更改Properties里的内容为</p>
<pre><code>Properties {
    _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {}
    _Bump (&quot;Bump&quot;, 2D) = &quot;bump&quot; {}
    _Snow (&quot;Snow Level&quot;, Range(0,1) ) = 0
    _SnowColor (&quot;Snow Color&quot;, Color) = (1.0,1.0,1.0,1.0)
    _SnowDirection (&quot;Snow Direction&quot;, Vector) = (0,1,0)
}
</code></pre><p>没有太多值得说的，唯一要提一下的是_SnowDirection设定的默认值为(0,1,0)，这表示我们希望雪是垂直落下的。对应地，在CG程序中对这些变量进行声明：</p>
<pre><code>sampler2D _MainTex;
sampler2D _Bump;
float _Snow;
float4 _SnowColor;
float4 _SnowDirection;
</code></pre><p>接下来改变Input的内容：</p>
<pre><code>struct Input {
    float2 uv_MainTex;
    float2 uv_Bump;
    float3 worldNormal; INTERNAL_DATA
};
</code></pre><p>相对于上面的Shader输入来说，加入了一个<code>float3 worldNormal;
INTERNAL_DATA</code>，如果SurfaceOutput中设定了Normal值的话，通过worldNormal可以获取当前点在世界中的法线值。详细的解说可以参见<a href="http://docs.unity3d.com/Documentation/Components/SL-
SurfaceShaders.html" target="_blank" rel="external">Unity的Shader文档</a>。接下来可以改变surf函数，实装积雪效果了。</p>
<pre><code>void surf (Input IN, inout SurfaceOutput o) {
    half4 c = tex2D (_MainTex, IN.uv_MainTex);
    o.Normal = UnpackNormal(tex2D(_Bump, IN.uv_Bump));

    if (dot(WorldNormalVector(IN, o.Normal), _SnowDirection.xyz) &gt; lerp(1,-1,_Snow)) {
        o.Albedo = _SnowColor.rgb;
    } else {
        o.Albedo = c.rgb;
    }

    o.Alpha = c.a;
}
</code></pre><p>和上面相比，加入了一个if…else…的判断。首先看这个条件的不等式的左侧，我们对雪的方向和和输入点的世界法线方向进行点积。<code>WorldNormalVector</code>通过输入的点及这个点的法线值，来计算它在世界坐标中的方向；右侧的lerp函数相信只要对插值有概念的同学都不难理解：当_Snow取最小值0时，这个函数将返回1，而_Snow取最大值时，返回-1。这样我们就可以通过设定_Snow的值来控制积雪的阈值，要是积雪等级_Snow是0时，不等式左侧不可能大于右侧，因此完全没有积雪；相反要是_Snow取最大值1时，由于左侧必定大于-1，所以全模型积雪。而随着取中间值的变化，积雪的情况便会有所不同。</p>
<p>应用这个Shader，并且适当地调节一下积雪等级和颜色，可以得到如下右边的效果。</p>
<p><img src="https://onevcat.com/assets/images/2013/shader-
tutorial2-snow.jpg" alt="添加了积雪效果的Shader"></p>
<h2 id="更改顶点模型"><a href="#更改顶点模型" class="headerlink" title="更改顶点模型"></a>更改顶点模型</h2><p>到现在位置，我们还仅指是在原贴图上进行操作，不管是用法线图使模型看起来凸凹有致，还是加上积雪，所有的计算和颜色的输出都只是“障眼法”，并没有对模型有任何实质的改动。但是对于积雪效果来说，实际上积雪是附加到石头上面，而不应当简单替换掉原来的颜色。但是具体实施起来，最简单的办法还是直接替换颜色，但是我们可以稍微变更一下模型，使原来的模型在积雪的方向稍微变大一些，这样来达到一种雪是附加到石头上的效果。</p>
<p>我们继续修改之前的Shader，首先我们需要告诉surface shadow我们要改变模型的顶点。首先将#param行改为</p>
<p><code>#pragma surface surf CustomDiffuse vertex:vert</code></p>
<p>这告诉Shader我们想要改变模型顶点，并且我们会写一个叫做<code>vert</code>的函数来改变顶点。接下来我们再添加一个参数，在Properties中声明一个<code>_SnowDepth</code>变量，表示积雪的厚度，当然我们也需要在CG段中进行声明：</p>
<pre><code>//In Properties{…}
_SnowDepth (&quot;Snow Depth&quot;, Range(0,0.3)) = 0.1

//In CG declare
float _SnowDepth;
</code></pre><p>接下来实现vert方法，和之前积雪的运算其实比较类似，判断点积大小来决定是否需要扩大模型以及确定模型扩大的方向。在CG段中加入以下vert方法</p>
<pre><code>void vert (inout appdata_full v) {
    float4 sn = mul(transpose(_Object2World) , _SnowDirection);
    if(dot(v.normal, sn.xyz) &gt;= lerp(1,-1, (_Snow * 2) / 3)) {
        v.vertex.xyz += (sn.xyz + v.normal) * _SnowDepth * _Snow;
    }
}
</code></pre><p>和surf的原理差不多，系统会输入一个当前的顶点的值，我们根据需要计算并填上新的值作为返回即可。上面第一行中使用<code>transpose</code>方法输出原矩阵的转置矩阵，在这里_Object2World是Unity<br>ShaderLab的内建值，它表示将当前模型转换到世界坐标中的矩阵，将其与积雪方向做矩阵乘积得到积雪方向在物体的世界空间中的投影（把积雪方向转换到世界坐标中）。之后我们计算了这个世界坐标中实际的积雪方向和当前点的法线值的点积，并将结果与使用积雪等级的2/3进行比较lerp后的阈值比较。这样，当前点如果和积雪方向一致，并且积雪较为完整的话，将改变该点的模型顶点高度。</p>
<p>加入模型更改前后的效果对比如下图，加入模型调整的右图表现要更为丰满真实。</p>
<p><img src="https://onevcat.com/assets/images/2013/shader-tutorial2-snow-
vert.jpg" alt="image"></p>
<p>这节就到这里吧。本节中实现的Shader可以<a href="https://gist.github.com/onevcat/6396814" target="_blank" rel="external">在这里找到完整版本</a>进行参考，希望大家周末愉快～</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/06/14/2016-06-14_【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（二）/" class="archive-article-date">
  	<time datetime="2016-06-13T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-06-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shader/">Shader</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unity3D/">unity3D</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Shader/">Shader</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-2016-06-14_【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/14/2016-06-14_【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（一）/">【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文转载自<a href="https://onevcat.com/#blog" title="link to homepage for OneV&#39;s Den" target="_blank" rel="external">OneV’s Den</a> 的博客，OneV’s Den 真是一位值得我们程序员学习的榜样，写的文章通俗易懂而且有深度，有兴趣的可以关注他的<a href="http://weibo.com/onevcat" target="_blank" rel="external">微博
</a>。</p>
<p>以下部分是正文：</p>
<hr>
<h1 id="猫都能学会的Unity3D-Shader入门指南（一）"><a href="#猫都能学会的Unity3D-Shader入门指南（一）" class="headerlink" title="猫都能学会的Unity3D Shader入门指南（一）"></a>猫都能学会的Unity3D Shader入门指南（一）</h1><p><img src="https://onevcat.com/assets/images/2013/shader-tutorial-
banner.jpg" alt="Unity Shader教程"></p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>自己使用Unity3D也有一段时间了，但是很多时候是流于表面，更多地是把这个引擎简单地用作脚本控制，而对更深入一些的层次几乎没有了解。虽然说Unity引擎设计的初衷就是创建简单的不需要开发者操心的谁都能用的3D引擎，但是只是肤浅的使用，可能是无法达到随心所欲的境地的，因此，这种状况必须改变！从哪里开始呢，貌似有句话叫做会写Shader的都是高手，于是，想大概看看从Shader开始能不能使自己到达的层次能再深入一些吧，再于是，有了这个系列（希望我能坚持写完它，虽然应该会拖个半年左右）。</p>
<p>Unity3D的所有渲染工作都离不开着色器（Shader），如果你和我一样最近开始对Shader编程比较感兴趣的话，可能你和我有着同样的困惑：如何开始？Unity3D提供了一些Shader的手册和文档（比如<a href="http://docs.unity3d.com/Documentation/Manual/Shaders.html" target="_blank" rel="external">这里</a>，<a href="http://docs.unity3d.com/Documentation/Components/Built-
inShaderGuide.html" target="_blank" rel="external">这里</a>和<a href="http://docs.unity3d.com/Documentation/Components/SL-
Reference.html" target="_blank" rel="external">这里</a>），但是一来内容比较分散，二来学习阶梯稍微陡峭了些。这对于像我这样之前完全没有接触过有关内容的新人来说是相当不友好的。国内外虽然也有一些Shader的介绍和心得，但是也同样存在内容分散的问题，很多教程前一章就只介绍了基本概念，接下来马上就搬出一个超复杂的例子，对于很多基本的用法并没有解释。也许对于Shader熟练使用的开发者来说是没有问题，但是我相信像我这样的入门者也并不在少数。在多方寻觅无果后，我觉得有必要写一份教程，来以一个入门者的角度介绍一些Shader开发的基本步骤。其实与其说是教程，倒不如说是一份自我总结，希望能够帮到有需要的人。</p>
<p>所以，本“教程”的对象是</p>
<ul>
<li>总的来说是新接触Shader开发的人：也许你知道什么是Shader，也会使用别人的Shader，但是仅限于知道一些基本的内建Shader名字，从来没有打开它们查看其源码。</li>
<li>想要更多了解Shader和有需求要进行Shader开发的开发者，但是之前并没有Shader开发的经验。</li>
</ul>
<p>当然，因为我本身在Shader开发方面也是一个不折不扣的大菜鸟，本文很多内容也只是在自己的理解加上一些可能不太靠谱的求证和总结。本文中的示例应该会有更好的方式来实现，因此您是高手并且恰巧路过的话，如果有好的方式来实现某些内容，恳请您不吝留下评论，我会对本文进行不断更新和维护。</p>
<h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><h3 id="Shader和Material"><a href="#Shader和Material" class="headerlink" title="Shader和Material"></a>Shader和Material</h3><p>如果是进行3D游戏开发的话，想必您对着两个词不会陌生。Shader（着色器）实际上就是一小段程序，它负责将输入的Mesh（网格）以指定的方式和输入的贴图或者颜色等组合作用，然后输出。绘图单元可以依据这个输出来将图像绘制到屏幕上。输入的贴图或者颜色等，加上对应的Shader，以及对Shader的特定的参数设置，将这些内容（Shader及输入参数）打包存储在一起，得到的就是一个Material（材质）。之后，我们便可以将材质赋予合适的renderer（渲染器）来进行渲染（输出）了。</p>
<p>所以说Shader并没有什么特别神奇的，它只是一段规定好输入（颜色，贴图等）和输出（渲染器能够读懂的点和颜色的对应关系）的程序。而Shader开发者要做的就是根据输入，进行计算变换，产生输出而已。</p>
<p>Shader大体上可以分为两类，简单来说</p>
<ul>
<li>表面着色器（Surface Shader） – 为你做了大部分的工作，只需要简单的技巧即可实现很多不错的效果。类比卡片机，上手以后不太需要很多努力就能拍出不错的效果。</li>
<li>片段着色器（Fragment Shader） – 可以做的事情更多，但是也比较难写。使用片段着色器的主要目的是可以在比较低的层级上进行更复杂（或者针对目标设备更高效）的开发。</li>
</ul>
<p>因为是入门文章，所以之后的介绍将主要集中在表面着色器上。</p>
<h3 id="Shader程序的基本结构"><a href="#Shader程序的基本结构" class="headerlink" title="Shader程序的基本结构"></a>Shader程序的基本结构</h3><p>因为着色器代码可以说专用性非常强，因此人为地规定了它的基本结构。一个普通的着色器的结构应该是这样的：</p>
<p><img src="https://onevcat.com/assets/images/2013/shader-structure.png" alt="一段Shader程序的结构"></p>
<p>首先是一些属性定义，用来指定这段代码将有哪些输入。接下来是一个或者多个的子着色器，在实际运行中，哪一个子着色器被使用是由运行的平台所决定的。子着色器是代码的主体，每一个子着色器中包含一个或者多个的Pass。在计算着色时，平台先选择最优先可以使用的着色器，然后依次运行其中的Pass，然后得到输出的结果。最后指定一个回滚，用来处理所有Subshader都不能运行的情况（比如目标设备实在太老，所有Subshader中都有其不支持的特性）。</p>
<p>需要提前说明的是，在实际进行表面着色器的开发时，我们将直接在Subshader这个层次上写代码，系统将把我们的代码编译成若干个合适的Pass。废话到此为止，下面让我们真正实际进入Shader的世界吧。</p>
<h2 id="Hello-Shader"><a href="#Hello-Shader" class="headerlink" title="Hello Shader"></a>Hello Shader</h2><p>百行文档不如一个实例，下面给出一段简单的Shader代码，然后根据代码来验证下上面说到的结构和阐述一些基本的Shader语法。因为本文是针对Unity3D来写Shader的，所以也使用Unity3D来演示吧。首先，新建一个Shader，可以在Project面板中找到，Create，选择Shader，然后将其命名为<code>Diffuse
Texture</code>：</p>
<p><img src="https://onevcat.com/assets/images/2013/shader-create-
in-unity.png" alt="在Unity3D中新建一个Shader"></p>
<p>随便用个文本编辑器打开刚才新建的Shader：</p>
<pre><code>Shader &quot;Custom/Diffuse Texture&quot; {
    Properties {
        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {}
    }
    SubShader {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
        LOD 200

        CGPROGRAM
        #pragma surface surf Lambert

        sampler2D _MainTex;

        struct Input {
            float2 uv_MainTex;
        };

        void surf (Input IN, inout SurfaceOutput o) {
            half4 c = tex2D (_MainTex, IN.uv_MainTex);
            o.Albedo = c.rgb;
            o.Alpha = c.a;
        }
        ENDCG
    } 
    FallBack &quot;Diffuse&quot;
}
</code></pre><p>如果您之前没怎么看过Shader代码的话，估计细节上会看不太懂。但是有了上面基本结构的介绍，您应该可以识别出这个Shader的构成，比如一个Properties部分，一个SubShader，以及一个FallBack。另外，第一行只是这个Shader的声明并为其指定了一个名字，比如我们的实例Shader，你可以在材质面板选择Shader时在对应的位置找到这个Shader。</p>
<p><img src="https://onevcat.com/assets/images/2013/shader-
select.png" alt="在Unity3D中找到刚才新建的Shader"></p>
<p><strong>接下来我们讲逐句讲解这个Shader，以期明了每一个语句的意义。</strong></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>在<code>Properties{}</code>中定义着色器属性，在这里定义的属性将被作为输入提供给所有的子着色器。每一条属性的定义的语法是这样的：</p>
<p><code>_Name(&quot;Display Name&quot;, type) = defaultValue[{options}]</code></p>
<ul>
<li>_Name – 属性的名字，简单说就是变量名，在之后整个Shader代码中将使用这个名字来获取该属性的内容</li>
<li>Display Name – 这个字符串将显示在Unity的材质编辑器中作为Shader的使用者可读的内容</li>
<li>type – 这个属性的类型，可能的type所表示的内容有以下几种： <ul>
<li>Color – 一种颜色，由RGBA（红绿蓝和透明度）四个量来定义；</li>
<li>2D – 一张2的阶数大小（256，512之类）的贴图。这张贴图将在采样后被转为对应基于模型UV的每个像素的颜色，最终被显示出来；</li>
<li>Rect – 一个非2阶数大小的贴图；</li>
<li>Cube – 即Cube map texture（立方体纹理），简单说就是6张有联系的2D贴图的组合，主要用来做反射效果（比如天空盒和动态反射），也会被转换为对应点的采样；</li>
<li>Range(min, max) – 一个介于最小值和最大值之间的浮点数，一般用来当作调整Shader某些特性的参数（比如透明度渲染的截止值可以是从0至1的值等）；</li>
<li>Float – 任意一个浮点数；</li>
<li>Vector – 一个四维数；</li>
</ul>
</li>
<li>defaultValue 定义了这个属性的默认值，通过输入一个符合格式的默认值来指定对应属性的初始值（某些效果可能需要某些特定的参数值来达到需要的效果，虽然这些值可以在之后在进行调整，但是如果默认就指定为想要的值的话就省去了一个个调整的时间，方便很多）。 <ul>
<li>Color – 以0～1定义的rgba颜色，比如(1,1,1,1)；</li>
<li>2D/Rect/Cube – 对于贴图来说，默认值可以为一个代表默认tint颜色的字符串，可以是空字符串或者”white”,”black”,”gray”,”bump”中的一个</li>
<li>Float，Range – 某个指定的浮点数</li>
<li>Vector – 一个4维数，写为 (x,y,z,w)</li>
</ul>
</li>
<li>另外还有一个{option}，它只对2D，Rect或者Cube贴图有关，在写输入时我们最少要在贴图之后写一对什么都不含的空白的{}，当我们需要打开特定选项时可以把其写在这对花括号内。如果需要同时打开多个选项，可以使用空白分隔。可能的选择有ObjectLinear, EyeLinear, SphereMap, CubeReflect, CubeNormal中的一个，这些都是OpenGL中TexGen的模式，具体的留到后面有机会再说。</li>
</ul>
<p>所以，一组属性的申明看起来也许会是这个样子的</p>
<pre><code>//Define a color with a default value of semi-transparent blue
_MainColor (&quot;Main Color&quot;, Color) = (0,0,1,0.5)
//Define a texture with a default of white
_Texture (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
</code></pre><p>现在看懂上面那段Shader（以及其他所有Shader）的Properties部分应该不会有任何问题了。接下来就是SubShader部分了。</p>
<h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p>表面着色器可以被若干的标签（tags）所修饰，而硬件将通过判定这些标签来决定什么时候调用该着色器。比如我们的例子中SubShader的第一句</p>
<p><code>Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }</code></p>
<p>告诉了系统应该在渲染非透明物体时调用我们。Unity定义了一些列这样的渲染过程，与RenderType是Opaque相对应的显而易见的是<code>&quot;RenderType&quot;
=
&quot;Transparent&quot;</code>，表示渲染含有透明效果的物体时调用。在这里Tags其实暗示了你的Shader输出的是什么，如果输出中都是非透明物体，那写在Opaque里；如果想渲染透明或者半透明的像素，那应该写在Transparent中。</p>
<p>另外比较有用的标签还有<code>&quot;IgnoreProjector&quot;=&quot;True&quot;</code>（不被<a href="http://docs.unity3d.com/Documentation/Components/class-
Projector.html" target="_blank" rel="external">Projectors</a>影响），<code>&quot;ForceNoShadowCasting&quot;=&quot;True&quot;</code>（从不产生阴影）以及<code>&quot;Queue&quot;=&quot;xxx&quot;</code>（指定渲染顺序队列）。这里想要着重说一下的是Queue这个标签，如果你使用Unity做过一些透明和不透明物体的混合的话，很可能已经遇到过不透明物体无法呈现在透明物体之后的情况。这种情况很可能是由于Shader的渲染顺序不正确导致的。Queue指定了物体的渲染顺序，预定义的Queue有：</p>
<ul>
<li>Background – 最早被调用的渲染，用来渲染天空盒或者背景</li>
<li>Geometry – 这是默认值，用来渲染非透明物体（普通情况下，场景中的绝大多数物体应该是非透明的）</li>
<li>AlphaTest – 用来渲染经过<a href="http://docs.unity3d.com/Documentation/Components/SL-AlphaTest.html" target="_blank" rel="external">Alpha Test</a>的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑</li>
<li>Transparent – 以从后往前的顺序渲染透明物体</li>
<li>Overlay – 用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）</li>
</ul>
<p>这些预定义的值本质上是一组定义整数，Background = 1000， Geometry = 2000, AlphaTest = 2450，<br>Transparent = 3000，最后Overlay =<br>4000。在我们实际设置Queue值时，不仅能使用上面的几个预定义值，我们也可以指定自己的Queue值，写成类似这样：<code>&quot;Queue&quot;=&quot;Transparent+100&quot;</code>，表示一个在Transparent之后100的Queue上进行调用。通过调整Queue值，我们可以确保某些物体一定在另一些物体之前或者之后渲染，这个技巧有时候很有用处。</p>
<h3 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h3><p>LOD很简单，它是Level of<br>Detail的缩写，在这里例子里我们指定了其为200（其实这是Unity的内建Diffuse着色器的设定值）。这个数值决定了我们能用什么样的Shader。在Unity的Quality<br>Settings中我们可以设定允许的最大LOD，当设定的LOD小于SubShader所指定的LOD时，这个SubShader将不可用。Unity内建Shader定义了一组LOD的数值，我们在实现自己的Shader的时候可以将其作为参考来设定自己的LOD数值，这样在之后调整根据设备图形性能来调整画质时可以进行比较精确的控制。</p>
<ul>
<li>VertexLit及其系列 = 100</li>
<li>Decal, Reflective VertexLit = 150</li>
<li>Diffuse = 200</li>
<li>Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit = 250</li>
<li>Bumped, Specular = 300</li>
<li>Bumped Specular = 400</li>
<li>Parallax = 500</li>
<li>Parallax Specular = 600</li>
</ul>
<h3 id="Shader本体"><a href="#Shader本体" class="headerlink" title="Shader本体"></a>Shader本体</h3><p>前面杂项说完了，终于可以开始看看最主要的部分了，也就是将输入转变为输出的代码部分。为了方便看，请容许我把上面的SubShader的主题部分抄写一遍</p>
<pre><code>CGPROGRAM
#pragma surface surf Lambert

sampler2D _MainTex;

struct Input {
    float2 uv_MainTex;
};

void surf (Input IN, inout SurfaceOutput o) {
    half4 c = tex2D (_MainTex, IN.uv_MainTex);
    o.Albedo = c.rgb;
    o.Alpha = c.a;
}
ENDCG
</code></pre><p>还是逐行来看，首先是CGPROGRAM。这是一个开始标记，表明从这里开始是一段CG程序（我们在写Unity的Shader时用的是Cg/HLSL语言）。最后一行的ENDCG与CGPROGRAM是对应的，表明CG程序到此结束。</p>
<p>接下来是是一个编译指令：<code>#pragma surface surf
Lambert</code>，它声明了我们要写一个表面Shader，并指定了光照模型。它的写法是这样的</p>
<p><code>#pragma surface surfaceFunction lightModel [optionalparams]</code></p>
<ul>
<li>surface – 声明的是一个表面着色器</li>
<li>surfaceFunction – 着色器代码的方法的名字</li>
<li>lightModel – 使用的光照模型。</li>
</ul>
<p>所以在我们的例子中，我们声明了一个表面着色器，实际的代码在surf函数中（在下面能找到该函数），使用Lambert（也就是普通的diffuse）作为光照模型。</p>
<p>接下来一句<code>sampler2D
_MainTex;</code>，sampler2D是个啥？其实在CG中，sampler2D就是和texture所绑定的一个数据容器接口。等等..这个说法还是太复杂了，简单理解的话，所谓加载以后的texture（贴图）说白了不过是一块内存存储的，使用了RGB（也许还有A）通道，且每个通道8bits的数据。而具体地想知道像素与坐标的对应关系，以及获取这些数据，我们总不能一次一次去自己计算内存地址或者偏移，因此可以通过sampler2D来对贴图进行操作。更简单地理解，sampler2D就是GLSL中的2D贴图的类型，相应的，还有sampler1D，sampler3D，samplerCube等等格式。</p>
<p>解释通了sampler2D是什么之后，还需要解释下为什么在这里需要一句对<code>_MainTex</code>的声明，之前我们不是已经在<code>Properties</code>里声明过它是贴图了么。答案是我们用来实例的这个shader其实是由两个相对独立的块组成的，外层的属性声明，回滚等等是Unity可以直接使用和编译的ShaderLab；而现在我们是在<code>CGPROGRAM...ENDCG</code>这样一个代码块中，这是一段CG程序。对于这段CG程序，要想访问在<code>Properties</code>中所定义的变量的话，<strong>必须使用和之前变量相同的名字进行声明</strong>。于是其实<code>sampler2D
_MainTex;</code>做的事情就是再次声明并链接了_MainTex，使得接下来的CG程序能够使用这个变量。</p>
<p>终于可以继续了。接下来是一个struct结构体。相信大家对于结构体已经很熟悉了，我们先跳过之，直接看下面的的surf函数。上面的#pragma段已经指出了我们的着色器代码的方法的名字叫做surf，那没跑儿了，就是这段代码是我们的着色器的工作核心。我们已经说过不止一次，着色器就是给定了输入，然后给出输出进行着色的代码。CG规定了声明为表面着色器的方法（就是我们这里的surf）的参数类型和名字，因此我们没有权利决定surf的输入输出参数的类型，只能按照规定写。这个规定就是第一个参数是一个Input结构，第二个参数是一个inout的SurfaceOutput结构。</p>
<p>它们分别是什么呢？Input其实是需要我们去定义的结构，这给我们提供了一个机会，可以把所需要参与计算的数据都放到这个Input结构中，传入surf函数使用；SurfaceOutput是已经定义好了里面类型输出结构，但是一开始的时候内容暂时是空白的，我们需要向里面填写输出，这样就可以完成着色了。先仔细看看INPUT吧，现在可以跳回来看上面定义的INPUT结构体了：</p>
<pre><code>struct Input {
    float2 uv_MainTex;
};
</code></pre><p>作为输入的结构体必须命名为Input，这个结构体中定义了一个float2的变量…你没看错我也没打错，就是float2，表示浮点数的float后面紧跟一个数字2，这又是什么意思呢？其实没什么魔法，float和vec都可以在之后加入一个2到4的数字，来表示被打包在一起的2到4个同类型数。比如下面的这些定义：</p>
<pre><code>//Define a 2d vector variable
vec2 coordinate;
//Define a color variable
float4 color;
//Multiply out a color
float3 multipliedColor = color.rgb * coordinate.x;
</code></pre><p>在访问这些值时，我们即可以只使用名称来获得整组值，也可以使用下标的方式（比如.xyzw，.rgba或它们的部分比如.x等等）来获得某个值。在这个例子里，我们声明了一个叫做<code>uv_MainTex</code>的包含两个浮点数的变量。</p>
<p>如果你对3D开发稍有耳闻的话，一定不会对uv这两个字母感到陌生。UV<br>mapping的作用是将一个2D贴图上的点按照一定规则映射到3D模型上，是3D渲染中最常见的一种顶点处理手段。在CG程序中，我们有这样的约定，在一个贴图变量（在我们例子中是<code>_MainTex</code>）之前加上uv两个字母，就代表提取它的uv值（其实就是两个代表贴图上点的二维坐标<br>）。我们之后就可以在surf程序中直接通过访问uv_MainTex来取得这张贴图当前需要计算的点的坐标值了。</p>
<p>如果你坚持看到这里了，那要恭喜你，因为离最后成功读完一个Shader只有一步之遥。我们回到surf函数，它的两有参数，第一个是Input，我们已经明白了：在计算输出时Shader会多次调用surf函数，每次给入一个贴图上的点坐标，来计算输出。第二个参数是一个可写的SurfaceOutput，SurfaceOutput是预定义的输出结构，我们的surf函数的目标就是根据输入把这个输出结构填上。SurfaceOutput结构体的定义如下</p>
<pre><code>struct SurfaceOutput {
    half3 Albedo;     //像素的颜色
    half3 Normal;     //像素的法向值
    half3 Emission;   //像素的发散颜色
    half Specular;    //像素的镜面高光
    half Gloss;       //像素的发光强度
    half Alpha;       //像素的透明度
};
</code></pre><p>这里的half和我们常见float与double类似，都表示浮点数，只不过精度不一样。也许你很熟悉单精度浮点数（float或者single）和双精度浮点数（double），这里的half指的是半精度浮点数，精度最低，运算性能相对比高精度浮点数高一些，因此被大量使用。</p>
<p>在例子中，我们做的事情非常简单：</p>
<pre><code>half4 c = tex2D (_MainTex, IN.uv_MainTex);
o.Albedo = c.rgb;
o.Alpha = c.a;
</code></pre><p>这里用到了一个<code>tex2d</code>函数，这是CG程序中用来在一张贴图中对一个点进行采样的方法，返回一个float4。这里对_MainTex在输入点上进行了采样，并将其颜色的rbg值赋予了输出的像素颜色，将a值赋予透明度。于是，着色器就明白了应当怎样工作：即找到贴图上对应的uv点，直接使用颜色信息来进行着色，over。</p>
<h2 id="接下来…"><a href="#接下来…" class="headerlink" title="接下来…"></a>接下来…</h2><p>我想现在你已经能读懂一些最简单的Shader了，接下来我推荐的是参考Unity的<a href="http://docs.unity3d.com/Documentation/Components/SL-
SurfaceShaderExamples.html" target="_blank" rel="external">Surface Shader<br>Examples</a>多接触一些各种各样的基本Shader。在这篇教程的基础上，配合一些google的工作，完全看懂这个shader示例页面应该不成问题。如果能做到无压力看懂，那说明你已经有良好的基础可以前进到Shader的更深的层次了（也许等不到我的下一篇教程就可以自己开始动手写些效果了）；如果暂时还是有困难，那也没有关系，Shader学习绝对是一个渐进的过程，因为有很多约定和常用技巧，多积累和实践自然会进步并掌握。</p>
<p>在接下来的教程里，打算通过介绍一些实际例子以及从基础开始实际逐步动手实现一个复杂一点的例子，让我们能看到shader在真正使用中的威力。我希望能尽快写完这个系列，但是无奈时间确实有限，所以我也不知道什么时候能出炉…写好的时候我会更改这段内容并指向新的文章。您要是担心错过的话，也可以使用<a href="http://eepurl.com/wNSkj" target="_blank" rel="external">邮件订阅</a>或者<a href="http://onevcat.com/atom.xml" target="_blank" rel="external">订阅本站的rss</a>(虽然Google<br>Reader已经关了- -)。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/06/14/2016-06-14_【绝世好文】【转】猫都能学会的Unity3D Shader入门指南（一）/" class="archive-article-date">
  	<time datetime="2016-06-13T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-06-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shader/">Shader</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unity3D/">unity3D</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Shader/">Shader</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-2016-06-13_Unity3D中铰链(HingeJoint)组件的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/2016-06-13_Unity3D中铰链(HingeJoint)组件的使用/">Unity3D中铰链(HingeJoint)组件的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HingeJoint-铰链关节"><a href="#HingeJoint-铰链关节" class="headerlink" title="HingeJoint(铰链关节)"></a>HingeJoint(铰链关节)</h2><h3 id="什么是铰链"><a href="#什么是铰链" class="headerlink" title="什么是铰链"></a>什么是铰链</h3><blockquote>
<p>铰链（英:<br>hinge），又称合页,是用来连接两个固体，并允许两者之间做转动的机械装置。铰链可能由可移动的组件构成，或者由可折叠的材料构成。最常见的是门窗上安装的铰链。</p>
</blockquote>
<p><img src="http://image.cn.made-in-
china.com/2f0j01EenQVjiWaYqG/%E5%90%88%E9%A1%B5.jpg" alt=""></p>
<h3 id="开始制作自己的铰链"><a href="#开始制作自己的铰链" class="headerlink" title="开始制作自己的铰链"></a>开始制作自己的铰链</h3><ul>
<li>在unity3D中新建一个Cube,然后将X轴方向的scale调整为10，然后添加RigidBody (刚体)组件，取消掉Use Gravity选项，设置x=0</li>
<li>将Cube选中，按住Ctrl+D复制一份，然后将新的Cube移动到x=-10的位置</li>
<li>给第一个Cube添加FixedJoint，不需要修改其中属性，完成后应该与下图一致</li>
</ul>
<p><img src="http://i.imgur.com/Psmz53y.jpg" alt=""></p>
<ul>
<li>给第二个Cube(1)添加HingeJoint，将Cube拖到Connected Body中，然后修改锚点为局部坐标下的(-0.5,0,0),同时设置旋转轴，为z轴(0,0,1),系统会自动计算出第一个Cube的锚点位置，完成后应该如下图。</li>
</ul>
<p><img src="http://i.imgur.com/eW9fCrh.jpg" alt=""></p>
<h3 id="让铰链运动起来"><a href="#让铰链运动起来" class="headerlink" title="让铰链运动起来"></a>让铰链运动起来</h3><p>因为铰链是一种物理结构，使用到物理引擎，所以控制铰链运动时，不可以使用transfrom,只能添加一个物理上的力或者速度，这里我们添加恒力。<br>因为要使铰链结构再xy平面内旋转，所以添加一个沿着局部坐标系下的y轴的力Relative Force(0,1,0),1代表单位力，可以改成其他数值。</p>
<h3 id="运动效果"><a href="#运动效果" class="headerlink" title="运动效果"></a>运动效果</h3><p>直接上图吧</p>
<p><img src="http://i.imgur.com/7bKDPqE.gif" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/06/13/2016-06-13_Unity3D中铰链(HingeJoint)组件的使用/" class="archive-article-date">
  	<time datetime="2016-06-12T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-06-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unity3D/">unity3D</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/unity3D/">unity3D</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-2016-06-12_VIVE普通车床车削2   完善与优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/12/2016-06-12_VIVE普通车床车削2   完善与优化/">VIVE普通车床车削2   完善与优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>增加了抓取动作和传送动作的实现</p>
<p>Share the video</p>
<ul>
<li><a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fwww.orzangleli.com%2F2016%2F06%2F12%2Fvive%25e6%2599%25ae%25e9%2580%259a%25e8%25bd%25a6%25e5%25ba%258a%25e8%25bd%25a6%25e5%2589%258a2-%25e5%25ae%258c%25e5%2596%2584%25e4%25b8%258e%25e4%25bc%2598%25e5%258c%2596%2F" target="_blank" rel="external">Facebook</a></li>
<li><a href="https://twitter.com/home?status=VIVE%E6%99%AE%E9%80%9A%E8%BD%A6%E5%BA%8A%E8%BD%A6%E5%89%8A2+++%E5%AE%8C%E5%96%84%E4%B8%8E%E4%BC%98%E5%8C%96+http%3A%2F%2Fwww.orzangleli.com%2F2016%2F06%2F12%2Fvive%25e6%2599%25ae%25e9%2580%259a%25e8%25bd%25a6%25e5%25ba%258a%25e8%25bd%25a6%25e5%2589%258a2-%25e5%25ae%258c%25e5%2596%2584%25e4%25b8%258e%25e4%25bc%2598%25e5%258c%2596%2F" target="_blank" rel="external">Twitter</a></li>
<li><a href="https://plus.google.com/share?url=http%3A%2F%2Fwww.orzangleli.com%2F2016%2F06%2F12%2Fvive%25e6%2599%25ae%25e9%2580%259a%25e8%25bd%25a6%25e5%25ba%258a%25e8%25bd%25a6%25e5%2589%258a2-%25e5%25ae%258c%25e5%2596%2584%25e4%25b8%258e%25e4%25bc%2598%25e5%258c%2596%2F" target="_blank" rel="external">Google+</a></li>
<li><a href="mailto:?body=Check%20the%20amazing%20video%20here%3A%20http%3A%2F%2Fwww.orzangleli.com%2F2016%2F06%2F12%2Fvive%25e6%2599%25ae%25e9%2580%259a%25e8%25bd%25a6%25e5%25ba%258a%25e8%25bd%25a6%25e5%2589%258a2-%25e5%25ae%258c%25e5%2596%2584%25e4%25b8%258e%25e4%25bc%2598%25e5%258c%2596%2F" target="_blank" rel="external">Email</a></li>
</ul>
<p><strong>Embed</strong></p>
<p>Copy and paste this HTML code into your webpage to embed.</p>
<hr>
<p><a href="http://flowplayer.org" target="_blank" rel="external">flowplayer</a></p>
<p><em>00:00</em> __ <em>00:00</em></p>
<p>##</p>
<p>Copy and paste this HTML code into your webpage to embed.</p>
<p>_space_play / pause</p>
<p>_q_unload | stop</p>
<p>_f_fullscreen</p>
<p>_↑__↓_volume</p>
<p>_m_mute</p>
<p>_←__→_seek</p>
<p>_ . _seek to previous</p>
<p><em>1__2</em>… <em>6</em> seek to 10%, 20% … 60%</p>
<ul>
<li>© 2015</li>
<li><a href="http://flowplayer.org" target="_blank" rel="external">About Flowplayer</a></li>
<li><a href="http://flowplayer.org/license" target="_blank" rel="external">GPL based license</a></li>
</ul>
<p><a href="http://flowplayer.org" target="_blank" rel="external"></a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/06/12/2016-06-12_VIVE普通车床车削2   完善与优化/" class="archive-article-date">
  	<time datetime="2016-06-11T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-06-12</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTC-VIVE/">HTC VIVE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unity3D/">unity3D</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/HTC-VIVE/">HTC VIVE</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-2016-06-05_HTC VIVE (VR)  普通车床切削过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/05/2016-06-05_HTC VIVE (VR)  普通车床切削过程/">HTC VIVE (VR)  普通车床切削过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Share the video</p>
<ul>
<li><a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fwww.orzangleli.com%2F2016%2F06%2F05%2Fhtc-vive-vr-%25e6%2599%25ae%25e9%2580%259a%25e8%25bd%25a6%25e5%25ba%258a%25e5%2588%2587%25e5%2589%258a%25e8%25bf%2587%25e7%25a8%258b%2F" target="_blank" rel="external">Facebook</a></li>
<li><a href="https://twitter.com/home?status=HTC+VIVE+%28VR%29++%E6%99%AE%E9%80%9A%E8%BD%A6%E5%BA%8A%E5%88%87%E5%89%8A%E8%BF%87%E7%A8%8B+http%3A%2F%2Fwww.orzangleli.com%2F2016%2F06%2F05%2Fhtc-vive-vr-%25e6%2599%25ae%25e9%2580%259a%25e8%25bd%25a6%25e5%25ba%258a%25e5%2588%2587%25e5%2589%258a%25e8%25bf%2587%25e7%25a8%258b%2F" target="_blank" rel="external">Twitter</a></li>
<li><a href="https://plus.google.com/share?url=http%3A%2F%2Fwww.orzangleli.com%2F2016%2F06%2F05%2Fhtc-vive-vr-%25e6%2599%25ae%25e9%2580%259a%25e8%25bd%25a6%25e5%25ba%258a%25e5%2588%2587%25e5%2589%258a%25e8%25bf%2587%25e7%25a8%258b%2F" target="_blank" rel="external">Google+</a></li>
<li><a href="mailto:?body=Check%20the%20amazing%20video%20here%3A%20http%3A%2F%2Fwww.orzangleli.com%2F2016%2F06%2F05%2Fhtc-vive-vr-%25e6%2599%25ae%25e9%2580%259a%25e8%25bd%25a6%25e5%25ba%258a%25e5%2588%2587%25e5%2589%258a%25e8%25bf%2587%25e7%25a8%258b%2F" target="_blank" rel="external">Email</a></li>
</ul>
<p><strong>Embed</strong></p>
<p>Copy and paste this HTML code into your webpage to embed.</p>
<hr>
<p><a href="http://flowplayer.org" target="_blank" rel="external">flowplayer</a></p>
<p><em>00:00</em> __ <em>00:00</em></p>
<p>##</p>
<p>Copy and paste this HTML code into your webpage to embed.</p>
<p>_space_play / pause</p>
<p>_q_unload | stop</p>
<p>_f_fullscreen</p>
<p>_↑__↓_volume</p>
<p>_m_mute</p>
<p>_←__→_seek</p>
<p>_ . _seek to previous</p>
<p><em>1__2</em>… <em>6</em> seek to 10%, 20% … 60%</p>
<ul>
<li>© 2015</li>
<li><a href="http://flowplayer.org" target="_blank" rel="external">About Flowplayer</a></li>
<li><a href="http://flowplayer.org/license" target="_blank" rel="external">GPL based license</a></li>
</ul>
<p><a href="http://flowplayer.org" target="_blank" rel="external"></a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/06/05/2016-06-05_HTC VIVE (VR)  普通车床切削过程/" class="archive-article-date">
  	<time datetime="2016-06-04T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-06-05</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTC-VIVE/">HTC VIVE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unity3D/">unity3D</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/HTC-VIVE/">HTC VIVE</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-2016-05-30_Arduino +W5100 +DS18B20 获取温度，上传到yeelink，成功经验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/30/2016-05-30_Arduino +W5100 +DS18B20 获取温度，上传到yeelink，成功经验/">Arduino +W5100 +DS18B20 获取温度，上传到yeelink，成功经验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MarkdownPad Document  </p>
<p>首先，从理论上来说，获取温度并上传并不算复杂，但是在尝试的过程中遇到各种坑，现在记录下来，希望后来者不要再次步入此坑。</p>
<h2 id="使用正确的连线"><a href="#使用正确的连线" class="headerlink" title="使用正确的连线"></a>使用正确的连线</h2><p>刚开始时，我从yeelink官网上看到一个demo，说的是LM35传感器获取温度，我从文章里看到连线图如下所示：<br><img src="http://img.yeelink.net/yeelink/resource/images/example_basic/3_LM35/13.jpg" alt=""><br>照着这个图连下来，然后再串口调试中看到输出的数据完全是错误的，有负数，有200多，完全不是室内温度，后来看到半天我才知道，原来我自己使用的温度传感器是DS18B20，并不是LM35,然后根据下面这张图连线：<br><img src="http://www.arduino.cn/data/attachment/forum/201208/01/2158082p12p1eplg16lvwj.jpg" alt=""></p>
<p>使用下面代码获取温度：</p>
<pre><code>#include &lt;OneWire.h&gt;
OneWire  ds(10);  // 连接arduino10引脚

void setup(void) {
  Serial.begin(9600);
}

void loop(void) {
  byte i;
  byte present = 0;
  byte type_s;
  byte data[12];
  byte addr[8];
  float celsius, fahrenheit;

  if ( !ds.search(addr)) {
Serial.println(&quot;No more addresses.&quot;);
Serial.println();
ds.reset_search();
delay(250);
return;
  }

  Serial.print(&quot;ROM =&quot;);
  for( i = 0; i &lt; 8; i++) {
Serial.write(&apos; &apos;);
Serial.print(addr[i], HEX);
  }

  if (OneWire::crc8(addr, 7) != addr[7]) {
  Serial.println(&quot;CRC is not valid!&quot;);
  return;
  }
  Serial.println();

  // the first ROM byte indicates which chip
  switch (addr[0]) {
case 0x10:
  Serial.println(&quot;  Chip = DS18S20&quot;);  // or old DS1820
  type_s = 1;
  break;
case 0x28:
  Serial.println(&quot;  Chip = DS18B20&quot;);
  type_s = 0;
  break;
case 0x22:
  Serial.println(&quot;  Chip = DS1822&quot;);
  type_s = 0;
  break;
default:
  Serial.println(&quot;Device is not a DS18x20 family device.&quot;);
  return;
  } 

  ds.reset();
  ds.select(addr);
  ds.write(0x44,1); // start conversion, with parasite power on at the end

  delay(1000); // maybe 750ms is enough, maybe not
  // we might do a ds.depower() here, but the reset will take care of it.

  present = ds.reset();
  ds.select(addr);
  ds.write(0xBE); // Read Scratchpad

  Serial.print(&quot;  Data = &quot;);
  Serial.print(present,HEX);
  Serial.print(&quot; &quot;);
  for ( i = 0; i &lt; 9; i++) {   // we need 9 bytes
data[i] = ds.read();
Serial.print(data[i], HEX);
Serial.print(&quot; &quot;);
  }
  Serial.print(&quot; CRC=&quot;);
  Serial.print(OneWire::crc8(data, 8), HEX);
  Serial.println();

  // convert the data to actual temperature

  unsigned int raw = (data[1] &lt;&lt; 8) | data[0];
  if (type_s) {
raw = raw &lt;&lt; 3; // 9 bit resolution default
if (data[7] == 0x10) {
  // count remain gives full 12 bit resolution
  raw = (raw &amp; 0xFFF0) + 12 - data[6];
}
  } else {
byte cfg = (data[4] &amp; 0x60);
if (cfg == 0x00) raw = raw &lt;&lt; 3;  // 9 bit resolution, 93.75 ms
else if (cfg == 0x20) raw = raw &lt;&lt; 2; // 10 bit res, 187.5 ms
else if (cfg == 0x40) raw = raw &lt;&lt; 1; // 11 bit res, 375 ms
// default is 12 bit resolution, 750 ms conversion time
  }
  celsius = (float)raw / 16.0;
  fahrenheit = celsius * 1.8 + 32.0;
  Serial.print(&quot;  Temperature = &quot;);
  Serial.print(celsius);
  Serial.print(&quot; Celsius, &quot;);   
  Serial.print(fahrenheit);
  Serial.println(&quot; Fahrenheit&quot;);
}
</code></pre><h2 id="使用正确的上传数据代码"><a href="#使用正确的上传数据代码" class="headerlink" title="使用正确的上传数据代码"></a>使用正确的上传数据代码</h2><p>什么是最坑的？最坑的不过是yeelink官网给我们的demo，无法运行取得正确的结果。<br>官网给的例子：<a href="http://www.yeelink.net/developer/doc/48" target="_blank" rel="external">http://www.yeelink.net/developer/doc/48</a><br>代码如下：<br><a href="https://github.com/Yeelink/example_basic_3_LM35/blob/master/LM35.ino" target="_blank" rel="external">https://github.com/Yeelink/example_basic_3_LM35/blob/master/LM35.ino</a></p>
<p>经过测试，发现这段代码根本无法上传数据，并不知道是为什么，而且从yeelink官网上的blog专栏也可以看到，之前别人使用的都是使用EthernetClient<br>上传数据。<a href="http://blog.yeelink.net/?p=94" target="_blank" rel="external">http://blog.yeelink.net/?p=94</a></p>
<p>所以，根据修改这篇文章里的<code>sendData(int data)</code> 发送数据到后台。</p>
<p>但是，这个函数只能发送int类型的变量，修改为float类型后发现并不能成功，原来在EthernetClient发送数据时，有一个数据长度校验位，Content-<br>Length，把这个后面的值修改为16就可以发送了。</p>
<h2 id="使用正确的引脚"><a href="#使用正确的引脚" class="headerlink" title="使用正确的引脚"></a>使用正确的引脚</h2><p>在网上看到好像W5100和10号引脚有冲突，由于我们在第一步中获取温度就是使用10号引脚，所以后来到上传数据时，并不能显示温度了。修改为5号引脚，问题解决。<br>然后把手指，放到传感器附近，可以看到数据的变化过程。</p>
<p><img src="http://i.imgur.com/WpmMbFQ.jpg" alt=""></p>
<p>这里如果需要设置报警时发送微博，可以参考这篇文章：<a href="http://www.yeelink.net/developer/doc/49" target="_blank" rel="external">http://www.yeelink.net/developer/doc/49</a></p>
<p>本文源代码在这里：<br><a href="https://github.com/hust201010701/Arduino_W5100_Yeelink_Temperature" target="_blank" rel="external">https://github.com/hust201010701/Arduino_W5100_Yeelink_Temperature</a></p>
<hr>
<p>好的，这篇文章就到这里，谢谢大家。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/05/30/2016-05-30_Arduino +W5100 +DS18B20 获取温度，上传到yeelink，成功经验/" class="archive-article-date">
  	<time datetime="2016-05-29T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-05-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Arduino/">Arduino</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/Arduino/">Arduino</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-2016-05-13_解决3ds max模型导出fbx到unity3d中蒙皮材质丢失的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/13/2016-05-13_解决3ds max模型导出fbx到unity3d中蒙皮材质丢失的问题/">解决3ds max模型导出fbx到unity3d中蒙皮材质丢失的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>经过大量的资料查询和测试，终于找到一种蒙皮的解决</p>
<p>人物蒙皮的方法：</p>
<ul>
<li>首先，在3ds max中把max格式的模型转为fbx格式的，注意勾选嵌入媒体。</li>
<li>将fbx模型拖到unity中，并把模型拖到scene中，可以看到有一个子对象上面有Skinned Mesh Render组件。</li>
<li>新建一个材质，把贴图文件的RGB和normalmap赋值给材质，然后把材质拖到第2步的那个子对象上。</li>
<li>然后就发现，模型有了材质了。</li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/05/13/2016-05-13_解决3ds max模型导出fbx到unity3d中蒙皮材质丢失的问题/" class="archive-article-date">
  	<time datetime="2016-05-12T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-05-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unity3D/">unity3D</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/unity3D/">unity3D</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 orzangleli
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Arduino/" style="font-size: 10px;">Arduino</a> <a href="/tags/HTC-VIVE/" style="font-size: 15px;">HTC VIVE</a> <a href="/tags/Kinect/" style="font-size: 12.5px;">Kinect</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Shader/" style="font-size: 12.5px;">Shader</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/api请求/" style="font-size: 10px;">api请求</a> <a href="/tags/unity3D/" style="font-size: 17.5px;">unity3D</a> <a href="/tags/其他/" style="font-size: 10px;">其他</a> <a href="/tags/面试/" style="font-size: 12.5px;">面试</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>